---
updated_at: 2026-02-12T14:20:09.829+10:00
---
**Издатель-Подписчик** ({{Publish-Subscribe|pub-sub}}) — это паттерн обмена сообщениями, в котором отправители ([[Publisher|издатели]]) не направляют сообщения непосредственно конкретным получателям, а присваивают опубликованным [[Event|событиям]] категории или темы. Получатели ([[Subscriber|подписчики]]) выражают интерес к одной или нескольким категориям и получают все события, опубликованные в этих категориях, без знания об издателях.

Паттерн реализуется либо через центральный посредник — [[Message Broker|брокер сообщений]], либо через распределённую шину, поддерживающую топики и подписки.

### Назначение
Применение паттерна «издатель-подписчик» решает задачи масштабирования и эволюции распределённых систем:

*   **[[Decoupling|Слабая связанность]]**. Издатели и подписчики не знают о существовании друг друга; им известен только формат событий и идентификаторы топиков. Это позволяет независимо изменять, добавлять или удалять компоненты.
*   **Масштабирование**. Множество подписчиков могут параллельно обрабатывать одни и те же события; множество издателей могут публиковать события в общие топики без координации.
*   **Асинхронность и отзывчивость**. Издатель не блокируется ожиданием ответа; события обрабатываются подписчиками в своём темпе.
*   **Поддержка широковещательной рассылки**. Одно событие может быть доставлено неограниченному числу подписчиков, что естественно для сценариев уведомлений, интеграционных событий и обновления кэшей.
*   **Интеграция гетерогенных систем**. Различные технологии и платформы могут взаимодействовать через общий протокол публикации/подписки.

### Ограничения
Применение паттерна сопряжено с рядом фундаментальных ограничений и проектных компромиссов:

1.  **Гарантии доставки и порядка**. Без централизованной координации сложно обеспечить exactly-once доставку и глобальный порядок событий для всех подписчиков. Различные брокеры предоставляют различные контракты (at-most-once, at-least-once, exactly-once) с соответствующими издержками.
2.  **Сложность мониторинга и трассировки**. Отсутствие прямой связи между издателем и подписчиком затрудняет сквозное наблюдение за потоком обработки запроса. Требуется внедрение распределённой трассировки и идентификаторов корреляции.
3.  **Управление подписками**. При динамическом изменении состава подписчиков или их отказах необходимо управлять квитированием, повторными доставками и очередями мёртвых писем.
4.  **Производительность при фильтрации**. Если подписчики используют сложные, контент-ориентированные фильтры, брокер может испытывать высокую нагрузку на маршрутизацию.
5.  **Семантическая связность**. Издатель и подписчики должны разделять общий контракт — схему событий. Эволюция схемы без нарушения совместимости требует дисциплины и инструментов.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к эффективному применению паттерна «издатель-подписчик»:

1.  **Выбор модели маршрутизации**. Две основные модели:
    *   **[[Topic-Based Routing|Топик-ориентированная]]** — подписка на именованные каналы (топики). Проста, масштабируема, поддерживается большинством брокеров (Kafka, RabbitMQ, NATS).
    *   **[[Content-Based Routing|Контент-ориентированная]]** — подписка на основе содержимого сообщения (SQL-подобные фильтры). Гибче, но сложнее и ресурсоёмкее. Часто реализуется поверх топиков с использованием дополнительных механизмов фильтрации.

2.  **Использование брокера сообщений**. В подавляющем большинстве промышленных систем внедряется выделенный брокер ([[Message Broker|message broker]]), обеспечивающий устойчивое хранение, маршрутизацию, гарантии доставки и масштабирование. Выбор конкретного брокера определяется требованиями к пропускной способности, сохранности сообщений и задержкам.

3.  **Схемы событий и реестры**. Для обеспечения совместимости форматы событий описываются декларативно (JSON Schema, Avro, Protobuf) и версионируются. Внедряется [[Schema Registry|реестр схем]], проверяющий совместимость при публикации и подписке.

4.  **Идемпотентность подписчиков**. В условиях at-least-once доставки подписчики проектируются [[Idempotency|идемпотентными]]: повторная обработка одного события не изменяет состояние системы. Это достигается дедупликацией по идентификатору события или использованием идемпотентных операций записи.

5.  **Мёртвые письма ([[Dead Letter Queue|DLQ]])**. Сообщения, которые не могут быть обработаны подписчиком после исчерпания попыток, направляются в специальную очередь для последующего анализа и ручного вмешательства. Это предотвращает бесконечные повторы и потерю данных.

6.  **Фильтрация на стороне подписчика или брокера**. Компромисс между нагрузкой на брокер и объёмом бесполезного трафика. Для высокопроизводительных сценариев предпочтительна фильтрация на стороне подписчика; при ограниченной пропускной способности канала — на стороне брокера.

7.  **Партиционирование и ключи упорядочения**. В системах, где важен порядок обработки событий одного логического ключа (заказ, пользователь), используется партиционирование топика (Kafka) с отправкой всех сообщений с одинаковым ключом в один раздел. Это гарантирует сохранение порядка в пределах раздела.

8.  **Наблюдаемость потока событий**. Каждое событие обогащается метаданными: идентификатор корреляции, временные метки, трассировочные заголовки. Системы [[Distributed Tracing|распределённой трассировки]] (OpenTelemetry) позволяют восстановить путь события через всех подписчиков и связать его с исходным запросом.

9.  **Ограничение срока жизни сообщений (TTL)**. Для предотвращения бесконечного накопления устаревших событий в очередях устанавливается время жизни сообщения. По истечении TTL сообщение автоматически удаляется или перемещается в DLQ.

10. **Тестирование взаимодействия**. Для изолированного тестирования подписчиков используются эмуляторы брокера (Testcontainers) или заглушки, эмитирующие публикацию событий. Контрактное тестирование (Pact) проверяет совместимость форматов событий между издателем и подписчиком.

11. **Асинхронное подтверждение обработки**. Подписчики сигнализируют брокеру об успешной обработке события (acknowledgement) только после сохранения результата в постоянном хранилище. Это гарантирует, что при сбое подписчика событие не будет потеряно и будет доставлено повторно.

Таким образом, паттерн «издатель-подписчик» является фундаментальным строительным блоком событийно-ориентированных архитектур. Его систематическое применение обеспечивает масштабируемость и эволюционную гибкость, требуя при этом осознанного проектирования контрактов, стратегий обработки сбоев и наблюдаемости. Дисциплинированная реализация перечисленных практик превращает децентрализованный обмен событиями в надёжную и диагностируемую основу распределённых систем.