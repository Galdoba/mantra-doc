---
updated_at: 2026-02-12T13:11:25.911+10:00
---
**Зашивание** ({{Hard-coding|hard-coding}}) — это практика непосредственного включения данных, параметров или поведенческих правил в [[Source Code|исходный код]] программы в виде литералов, вместо получения их из внешних источников во время выполнения. Такие данные становятся неотъемлемой частью исполняемого артефакта и могут быть изменены только путём правки кода и повторной [[Compilation|компиляции]].

### Назначение
Несмотря на повсеместную критику, зашивание возникает в ряде контекстов не случайно:
*   **Прототипирование и эксперименты**. На ранних этапах разработки фиксированные значения позволяют быстро проверить работоспособность логики без создания инфраструктуры для работы с конфигурацией.
*   **Образовательные примеры**. В учебных целях код с явными значениями нагляднее демонстрирует алгоритм, не отвлекая читателя на механизмы внешнего управления.
*   **Ограниченный контекст**. В узкоспециализированных встраиваемых системах или одноразовых скриптах, где вариативность параметров отсутствует, зашивание может быть осознанным упрощением.
*   **Необходимость производительности**. В некоторых критичных по времени участках доступ к внешнему хранилищу настроек может быть недопустим, и литералы остаются единственным вариантом.

### Ограничения
Зашивание считается анти-паттерном в системах, рассчитанных на длительную эксплуатацию и развитие, из-за ряда существенных недостатков:
1.  **Отсутствие гибкости**. Любое изменение требует выпуска новой версии программного продукта. Невозможно адаптировать поведение под разные окружения (разработка, стейджинг, продакшн) без модификации кода.
2.  **Риск ошибок и дублирования**. Одна и та же сущность (например, адрес сервера) часто «зашивается» в нескольких местах. При необходимости обновления разработчик должен найти и изменить все вхождения, что провоцирует рассинхронизацию и дефекты.
3.  **Проблемы безопасности**. Размещение [[Secret|секретов]] (паролей, токенов, ключей API) непосредственно в коде приводит к их попаданию в системы контроля версий. Это создаёт угрозу компрометации учётных данных при утечке репозитория.
4.  **Снижение переиспользуемости**. Код, содержащий конкретные значения вместо абстракций, сложно применить в другом проекте или даже в ином контексте внутри того же продукта.
5.  **Нарушение читаемости**. Непояснённые [[Magic Number|магические числа]] и [[Magic String|магические строки]] затрудняют понимание смысла данных для других разработчиков и самого автора спустя время.

### Сложившиеся практики
Современная инженерия выработала ряд методов, позволяющих избежать зашивания или локализовать его допустимые случаи:

1.  **Вынос во внешние источники**. Основной подход — отделение изменяемых параметров от кода. Данные помещаются в [[Configuration File|конфигурационные файлы]] (JSON, YAML, XML), [[Environment Variable|переменные окружения]], базы данных или специализированные сервисы конфигурации. Это реализует принцип [[Separation of Concerns|разделения ответственности]] между программной логикой и данными.

2.  **Использование констант**. Если значение действительно неизменно в рамках всего жизненного цикла приложения, оно оформляется как именованная [[Constant|константа]] (например, `MAX_RETRY_COUNT` вместо `3`). Константа не устраняет зашивание полностью, но локализует его в одном месте и повышает самодокументированность кода.

3.  **Внедрение зависимостей**. Параметры передаются модулям извне через конструктор или методы. Паттерн [[Dependency Injection|внедрение зависимостей]] позволяет подменять конкретные значения при тестировании и менять их в разных окружениях без пересборки компонента.

4.  **Абстракция через фабрики и стратегии**. Вместо привязки к конкретным числовым или строковым значениям используются полиморфные конструкции, где поведение определяется переданным объектом.

5.  **Управление переключениями**. Для постепенного ввода новых функций применяются [[Feature Flag|флаги функциональности]], которые определяют включение определённого участка кода. Значения флагов хранятся централизованно и могут изменяться динамически.

Таким образом, зашивание не является однозначным злом, но в системах, требующих поддержки и адаптации, оно последовательно замещается механизмами, выносящими изменяемые аспекты за пределы исходного кода.