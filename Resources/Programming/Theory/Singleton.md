---
updated_at: 2026-02-12T17:43:57.378+10:00
---
## Синглтон: гарантия единственного экземпляра

**Синглтон** ({{Singleton|singleton}}) — это порождающий паттерн проектирования, гарантирующий, что у класса существует ровно один экземпляр, и предоставляющий глобальную точку доступа к этому экземпляру. Синглтон совмещает два свойства: контроль над количеством экземпляров и глобальную видимость.

### Назначение
Применение синглтона мотивировано необходимостью координации действий в системе через единый, общедоступный объект:

*   **Управление общими ресурсами**. Доступ к пулу соединений, файловой системе, реестру настроек, кэшу или аппаратному устройству должен осуществляться через единственный координатор.
*   **Предотвращение дублирования состояния**. Некоторые компоненты (менеджеры логов, счётчики посещений, лицензионные контроллеры) теряют смысл при наличии более одного экземпляра.
*   **Экономия ресурсов**. Создание тяжёлого объекта (загрузка конфигурации, инициализация библиотек) выполняется однократно.
*   **Замена глобальных переменных**. Синглтон предоставляет более контролируемый механизм глобального доступа, чем непосредственное использование [[Global Variable|глобальных переменных]].

### Ограничения
Несмотря на внешнюю простоту, синглтон является спорным паттерном и имеет ряд существенных недостатков:

1.  **Нарушение [[Single Responsibility Principle|принципа единственной ответственности]]**. Синглтон отвечает одновременно за управление своим жизненным циклом и за реализацию бизнес-логики.
2.  **Скрытые зависимости**. Клиент обращается к синглтону напрямую через статический метод, что скрывает зависимости и затрудняет тестирование (невозможно подменить экземпляр заглушкой).
3.  **Глобальное состояние**. Синглтон поощряет использование глобального изменяемого состояния, что приводит к скрытым связям и усложняет отладку.
4.  **Проблемы параллелизма**. Обеспечение [[Thread Safety|потокобезопасности]] при [[Lazy Initialization|ленивой инициализации]] требует аккуратной синхронизации, которую легко реализовать некорректно (например, [[Double-Checked Locking|блокировка с двойной проверкой]] в некоторых языках проблематична).
5.  **Сложность расширения**. Создание подкласса синглтона или замена его другой реализацией без изменения клиентского кода затруднительна.
6.  **Скрытые проблемы с областью видимости**. В распределённых средах синглтон гарантирует единственность экземпляра только в пределах одного процесса, что не соответствует ожиданию глобальной уникальности.

### Сложившиеся практики
Индустрия выработала несколько подходов к реализации синглтона, а также альтернативы, смягчающие его недостатки:

1.  **Реализация через [[Enum|перечисление]] (enum)**. В языках, где перечисления являются полноценными классами (Java, C#), одноэлементное перечисление считается наиболее надёжным способом: оно гарантирует сериализационную безопасность и защиту от рефлексивного создания новых экземпляров.

2.  **[[Lazy Initialization|Ленивая инициализация]] с Holder-классом**. Идиома «holder-класс» использует вложенный статический класс, инициализируемый при первом обращении; это обеспечивает потокобезопасность без явной синхронизации за счёт гарантий инициализации классов в JVM.

3.  **Явная передача через [[Dependency Injection|внедрение зависимостей]]**. Вместо прямого доступа к синглтону через глобальную точку, экземпляр создаётся однократно в [[Composition Root|корне композиции]] и внедряется во все клиенты. Это сохраняет уникальность, но делает зависимости явными и замещаемыми.

4.  **[[Monostate|Моносостояние (Monostate)]]**. Альтернативный паттерн, обеспечивающий единое состояние через статические поля, но допускающий создание множества экземпляров. Клиенты работают с обычными объектами, но все они разделяют общее состояние.

5.  **Ограничение области видимости**. Вместо глобального синглтона используется объект, уникальный в рамках определённого контекста (например, запроса, сессии или потока). Это достигается регистрацией экземпляра в контейнере внедрения зависимостей с соответствующей областью жизни.

6.  **Использование [[Static Class|статического класса]]**. Для компонентов без состояния (утилитарные функции) статический класс предпочтительнее синглтона, так как не требует управления экземпляром и не создаёт иллюзии состояния.

7.  **Тестирование**. Для тестирования кода, использующего синглтон, применяются:
    *   методы сброса состояния (часто антипаттерн, но иногда необходим);
    *   фреймворки, переопределяющие создание синглтона в тестах;
    *   рефакторинг в сторону внедрения зависимостей.

8.  **Документирование потокобезопасности**. Если синглтон спроектирован с учётом многопоточности, его потокобезопасность должна быть явно зафиксирована в контракте. Инициализация при первом вызове и отсутствие изменяемого состояния после создания делают реализацию безопасной без синхронизации.

Таким образом, синглтон остаётся паттерном, который следует применять осознанно и с пониманием его ограничений. Современная практика отдаёт предпочтение управлению единственностью экземпляра через механизмы внедрения зависимостей и контейнеры, оставляя классическую реализацию только для действительно глобальных, редко изменяемых технических компонентов (логирование, низкоуровневый доступ к оборудованию).