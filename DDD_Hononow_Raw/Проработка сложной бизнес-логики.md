---
updated_at: 2025-12-11T18:34:05.201+10:00
tags:
  - part2
  - chapter6
---
В предыдущей главе были рассмотрены два паттерна (pattern) для относительно простой бизнес-логики: транзакционный сценарий (transaction script) и активная запись (active record). В этой главе тема реализации бизнес-логики будет продолжена представлением паттерна модели предметной области (domain model), ориентированного на более сложную бизнес-логику. 

# Предыстория 
Паттерн модели предметной области, как и паттерны транзакционного сценария и активной записи, первоначально был представлен в книге Мартина Фаулера (Martin Fowler) «Patterns of Enterprise Application Architecture». Завершая обсуждение этого паттерна, Фаулер написал: «Сейчас Эрик Эванс (Eric Evans) пишет книгу о создании моделей предметной области». Упомянутая им книга, «Domain Driven Design: Tackling Complexity in the Heart of Software», стала основной работой Эванса. 
В своей книге Эванс представляет набор паттернов, нацеленных на тесную связь кода с базовой моделью предметной области бизнеса: агрегаты, объекты-значения, репозитории и т. д. Эти паттерны являются продолжением того, на чем Фаулер остановился в своей книге, и похожи на эффективный набор инструментов для реализации паттерна модели предметной области. 
Паттерны, представленные Эвансом, часто называют тактическими средствами предметно-ориентированного проектирования. Чтобы не создавать превратного представления, что реализация замыслов предметно-ориентированного проектирования неизбежно влечет использование этих паттернов при реализации бизнеслогики, я предпочитаю придерживаться исходной терминологии Фаулера. Паттерном является «модель предметной области», а агрегаты и объекты-значения являются его строительными блоками. 

# Модель предметной области (доменная модель) 
Паттерн модели предметной области предназначен для сложной бизнес-логики. Здесь вместо работы с CRUD-операциями решаются вопросы сложных переходов между состояниями, бизнес-правилами и инвариантами, т. е. незыблемыми правилами.
Предположим, что нами внедряется система технической поддержки пользователей (help desk). Рассмотрим следующую выдержку из требований, описывающую логику управления жизненными циклами заявок в службу поддержки: 
- Клиенты открывают заявки в службу поддержки, описывая проблемы, с которыми они сталкиваются. 
- И клиент, и сотрудник службы поддержки добавляют сообщения, данная переписка может быть просмотрена в соответствующей заявке. 
- У каждой заявки есть приоритет: низкий, средний, высокий или срочный. 
- Сотрудник службы поддержки должен предложить решение в течение установленного срока (set time limit, SLA), основанного на приоритете заявки. 
- Если сотрудник не отвечает в SLA-срок, клиент может передать заявку руководителю сотрудника. 
- Передача заявки на рассмотрение в более высокую инстанцию. 
- Эскалация сокращает лимит времени ответа (SLA) сотрудника на 33%. 
- Если сотрудник не открыл эскалированную заявку за половину времени, выделенного на ответ, она автоматически переназначается другому сотруднику. 
- Заявки автоматически закрываются, если клиент не отвечает на вопросы сотрудника в течение семи дней. 
- Эскалированные заявки не могут быть закрыты автоматически или самим сотрудником, это может сделать только клиент или руководитель сотрудника. 
- Клиент может повторно открыть закрытую заявку только в том случае, если она была закрыта не более семи дней назад. Эти требования образуют запутанную сеть зависимостей между различными правилами и влияют на логику управления жизненным циклом заявки в службу поддержки. 

Это уже не просто CRUD-экран ввода данных, рассмотренный в предыдущей главе. Попытка реализовать эту логику с использованием объектов активной записи, скорее всего, приведет к многократным повторам и несогласованному состоянию системы из-за неправильной реализации некоторых бизнес-правил. 

## Реализация 
Модель предметной области — это объектная модель, включающая в себя как поведение, так и данные . Строительными блоками такой объектной модели являются тактические паттерны DDD — агрегаты (aggregates), объекты-значения (valueobjects), события предметной области (domain events) и доменные сервисы (domain services) .
Все эти паттерны имеют общую тему: они ставят бизнес-логику на первое место. Давайте посмотрим, как с помощью модели предметной области решаются различные задачи проектирования. 

Сложность 
Бизнес-логика предметной области сложна уже по своей сути, поэтому объекты, используемые для ее моделирования, не должны вносить никакой дополнительной непреднамеренной сложности. Модель должна быть лишена каких-либо инфраструктурных или технологических проблем, таких как реализация обращений к базам данных или другим внешним компонентам системы. Это ограничение требует, чтобы объекты модели были простыми обычными объектами, реализующими бизнес-логику, не опирающимися на какие-либо инфраструктурные компоненты или платформы и не включающими их напрямую3 . 

Единый язык 
Акцент на бизнес-логике, а не на технических аспектах упрощает следование объектами модели предметной области понятий единого языка (ubiquitous language) ограниченного контекста (bounded context). Иными словами, этот паттерн позволяет коду «говорить» на едином языке и следовать ментальным моделям экспертов предметной области. 

Строительные блоки 
Давайте посмотрим на основные строительные блоки модели предметной области или тактические паттерны, предлагаемые DDD: объекты-значения, агрегаты и доменные сервисы. 

Объект-значение 
Объект-значение (value object) — это объект, который можно идентифицировать по составляющим его значениям. Рассмотрим, к примеру, объект цвета: 

```java
class Color 
{ 
int _red; 
int _green; 
int _blue; 
}

```

 Цвет определяется композицией из значений трех полей: красного, зеленого и синего. Изменение значения одного из полей приведет к появлению нового цвета. Два разных цвета не могут иметь одинаковых значений. Кроме того, два экземпляра одного и того же цвета должны иметь одинаковые значения. Следовательно, для идентификации цветов явного идентификационного поля не требуется.
Поле ColorId, показанное на рис. 6.1, не только носит избыточный характер, но и является почвой для ошибок. Можно создать две строки с одинаковыми значениями red, green и blue, но сравнение значений ColorId не покажет, что ими обозначен один и тот же цвет.

![[Рис. 6.1. Избыточное поле ColorId, позволяющее иметь две строки с одинаковыми значениями.png]]

**Единый язык.** Если для представления понятий предметной области полагаться исключительно на элементарные типы данных стандартной библиотеки языка, такие как строки, целые числа или словари, то это будет считаться одержимостью примитивами4 . Рассмотрим, к примеру, следующий класс:
```
class Person 
{ 
private int _id; 
private string _firstName; 
private string _lastName; 
private string _landlinePhone; 
private string _mobilePhone; 
private string _email; 
private int _heightMetric; 
private string _countryCode; 
public Person(...) {...} 
} 

static void Main(string[] args) 
{ 
var dave = new Person( 
	id: 30217, 
	firstName: "Dave", 
	lastName: "Ancelovici", 
	landlinePhone: "023745001",
	mobilePhone: "0873712503", 
	email: "dave@learning-ddd.com", 
	heightMetric: 180, 
	countryCode: "BG"); 
}
```

В показанной выше реализации класса Person большинство значений имеют тип String и присваиваются на основе соглашений. Например, передаваемый стационарный телефон, landlinePhone, должен быть действительным номером стационарного телефона, а код страны, countryCode, должен быть действительным двухбуквенным кодом страны в верхнем регистре. Конечно, система не может доверять пользователю, полагая, что он всегда вводит правильные значения, в результате класс должен проверять все поля ввода. 
Такой подход сопряжен с многочисленными рисками проектирования. Во-первых, логика проверки часто дублируется. Во-вторых, возникают трудности с принудительным вызовом логики проверки перед использованием значений. А в будущем, когда кодовая база будет развиваться силами других программистов, все только усложнится. 
Сравните следующий альтернативный дизайн того же объекта, но на этот раз с использованием объектов-значений:

```java

class Person { 
private PersonId _id; 
private Name _name; 
private PhoneNumber _landline; 
private PhoneNumber _mobile; 
private EmailAddress _email; 
private Height _height; 
private CountryCode _country; 

public Person(...) { ... } 
} 

static void Main(string[] args) 
{ 
var dave = new Person( 
	id: new PersonId(30217), 
	name: new Name("Dave", "Ancelovici"), 
	landline: PhoneNumber.Parse("023745001"), 
	mobile: PhoneNumber.Parse("0873712503"), 
	email: Email.Parse("dave@learning-ddd.com"), 
	height: Height.FromMetric(180), 
	country: CountryCode.Parse("BG")); 
}
```

Во-первых, обратите внимание на лучшую читаемость. Возьмем, к примеру, переменную страны country. Чтобы сообщить, что в ней содержится код страны, а не, скажем, ее полное название, уже не нужно включать подробности в имя переменной в виде «countryCode». Объект-значение проясняет задуманное даже при использовании более коротких имен переменных. 
Во-вторых, нет необходимости проверять входные значения перед присвоением, поскольку логика проверки находится в самих объектах-значениях. Но поведение объекта-значения не ограничивается простой проверкой входных значений. Особая ценность объектов-значений проявляется при централизации бизнес-логики, работающей со значениями. Связная логика реализована в одном месте и легко тестируется. И что наиболее важно, объекты-значения выражают концепции предметной области: код начинает отражать в себе концепции единого языка. 
Давайте посмотрим, как представление понятий высоты, телефонных номеров и цветов в виде объектов-значений делает полученную в результате этого систему типов богатой и интуитивно понятной в использовании. 
По сравнению с целочисленным значением, объект-значение Height более понятен и отвязывает показатель величины от конкретной единицы измерения. Например, объект-значение Height может быть инициализирован с использованием как метрических, так и британских единиц, что упрощает преобразование из одной единицы в другую, создание строкового представления и сравнение значений в разных единицах измерений:

```java

var heightMetric = Height.Metric(180); 
var heightImperial = Height.Imperial(5, 3); 

var string1 = heightMetric.ToString( ); // "180cm" 
var string2 = heightImperial.ToString( ); // "5 feet 3 inches" 
var string3 = heightMetric.ToImperial( ).ToString( ); // "5 feet 11 inches" 
var firstIsHigher = heightMetric > heightImperial; // true
```

Объект-значение PhoneNumber может инкапсулировать логику анализа строкового значения, его проверки и извлечения различных атрибутов номера телефона: например, страны, которой он принадлежит, и типа номера телефона — стационарный или мобильный:

```java
var phone = PhoneNumber.Parse("+359877123503"); 
var country = phone.Country; // "BG" 
var phoneType = phone.PhoneType; // "MOBILE" 
var isValid = PhoneNumber.IsValid("+972120266680"); // false 
```

Следующий пример демонстрирует эффективность применения объекта-значения, когда в нем инкапсулируется вся бизнес-логика, которая манипулирует данными и создает новые экземпляры объекта-значения: 

```java

var red = Color.FromRGB(255, 0, 0); 
var green = Color.Green; 
var yellow = red.MixWith(green); 
var yellowString = yellow.ToString( ); // "#FFFF00" 
```

Из представленных выше примеров можно понять, что объекты-значения устраняют необходимость в соглашениях, например необходимость помнить, что эта строка является адресом электронной почты, а вот эта строка — номером телефона, и вместе с тем делают использование объектной модели менее подверженным различным ошибкам и более интуитивно понятным. 
**Реализация.** Поскольку изменение любого из полей объекта-значения приводит к появлению другого значения, объекты-значения реализуются как неизменяемые (immutable) объекты. Изменение одного из полей объекта значения концептуально создает другое значение — другой экземпляр объекта-значения. Следовательно, когда выполненное действие приводит к новому значению, как в следующем случае, в котором используется метод MixWith, оно не изменяет исходный экземпляр, а создает и возвращает новый экземпляр:

```java
public class Color 
{ 
public readonly byte Red; 
public readonly byte Green; 
public readonly byte Blue; 

public Color(byte r, byte g, byte b) { 
	this.Red = r; 
	this.Green = g; 
	this.Blue = b; 
} 

public Color MixWith(Color other) 
	{ 
	return new Color( 
		r: (byte) Math.Min(this.Red + other.Red, 255), 
		g: (byte) Math.Min(this.Green + other.Green, 255), 
		b: (byte) Math.Min(this.Blue + other.Blue, 255) 
	); 
	} 
... 
}
```

Поскольку равенство объектов-значений основано на составляющих их значениях, а не на поле идентификатора или ссылке, важно переопределить и правильно реализовать проверки на равенство. Например, на языке С# :

```c#
public class Color 
{ 
... 
	public override bool Equals(object obj) 
	{ 
	var other = obj as Color;
	return other != null && 
		this.Red == other.Red && 
		this.Green == other.Green && 
		this.Blue == other.Blue; 
	} 

	public static bool operator == (Color lhs, Color rhs) 
	{ 
	if (Object.ReferenceEquals(lhs, null)) { 
		return Object.ReferenceEquals(rhs, null); 
	} 
	return lhs.Equals(rhs); 
	} 

	public static bool operator != (Color lhs, Color rhs) { 
		return !(lhs == rhs); 
	} 

	public override int GetHashCode( ) { 
		return ToString( ).GetHashCode( ); 
	} 
	... 
}
```

Хотя использование для представления специфичных для предметной области значений типа String из базовой библиотеки противоречит понятию объектовзначений, в .NET, Java и других языках строковый тип реализован именно как объект-значение. Строки неизменяемы, т. к. все операции с ними приводят к созданию нового экземпляра. Кроме того, в строковом типе инкапсулируется весьма разнообразное поведение, приводящее к созданию новых экземпляров путем манипуляции со значениями одной или нескольких строк. Это обрезка, объединение нескольких строк, замена символов, выделение подстроки и другие методы. 
**Когда следует использовать объекты-значения.** Ответ прост: при любой возможности. Объекты-значения не только делают код более выразительным и инкапсулируют бизнес-логику, имеющую свойство дублироваться в разных местах, но и само применение данного паттерна проектирования делает код более безопасным. Поскольку объекты-значения неизменяемы, их поведение не имеет побочных эффектов и является потокобезопасным. 
С позиции бизнес-области полезным практическим правилом является использование объектов-значений для элементов предметной области, описывающих свойства других объектов. В частности, это касается свойств сущностей, рассматриваемых в следующем разделе. В ранее представленных примерах для описания человека использовались объекты-значения: его идентификатор, имя, номера телефонов, адрес электронной почты и т. д. Другие примеры использования объектов-значений могут включать в себя различные состояния, пароли и другие понятия, относящиеся к предметной области бизнеса, допускающие идентификацию по их значениям и, таким образом, не требующие явного присутствия поля идентификации. Возможность введения объекта-значения приобретает особую важность при моделировании денег и других денежных ценностей. Использование элементарных типов для представления денег не только ограничивает возможность инкапсуляции всей связанной с деньгами бизнес-логики в одном месте, но также часто приводит к опасным ошибкам при округлениях и к другим проблемам, связанным с точностью. 

# Сущности 
Сущность является противоположностью объекта-значения. Для нее требуется явно указанное поле идентификации, чтобы различать разные экземпляры объекта. Элементарным примером сущности является человек. Рассмотрим следующий класс:

```c#
class Person 
{ 
	public Name Name { get; set; } 

	public Person(Name name) 
	{ 
		this.Name = name; 
	} 
}
```

Этот класс содержит только одно поле: name (объект-значение). Но такой дизайн неоптимален, поскольку разные люди могут быть однофамильцами и иметь абсолютно одинаковые имена. Это, конечно, не делает их одним и тем же человеком. Следовательно, для правильной идентификации людей необходимо поле идентификации:

```c#
class Person 
{ 
	public readonly PersonId Id; 
	public Name Name { get; set; } 
	
	public Person(PersonId id, Name name) 
	{ 
		this.Id = id; 
		this.Name = name; 
	} 
}
```

В предыдущем коде было введено поле идентификации Id типа PersonId. А PersonId — объект-значение, и в нем можно использовать любые базовые типы данных, соответствующие потребностям предметной области. Например, идентификатор Id может быть GUID-идентификатором, числом, строкой или значением, зависящим от предметной области, например номером социального страхования.
Основное требование к полю идентификации — его уникальность для каждого экземпляра сущности: в нашем случае для каждого человека (рис. 6.2). Кроме того, за очень редкими исключениями значение поля идентификации объекта должно оставаться неизменным на протяжении всего жизненного цикла объекта. Это подводит нас ко второму концептуальному различию между объектами-значениями и сущностями.

![[Рис. 6.2. Введение явного поля идентификации.png]]

В отличие от объектов-значений, сущности не являются неизменяемыми и корректируются вполне ожидаемым образом. Еще одно различие между сущностями и объектами-значениями заключается в том, что объекты-значения описывают свойства сущности. Ранее в этой главе уже встречалась сущность Person с двумя объектами-значениями, описывающими каждый экземпляр: PersonId и Name. 
Сущности являются важным строительным блоком любой предметной области. Тем не менее не трудно было заметить, что ранее в этой главе в список строительных блоков модели предметной области «сущность» не включалась. Это не ошибка. Причина, по которой «сущность» не упоминалась, заключается в том, что сущности реализуются не сами по себе, а только в контексте паттерна агрегата. 

# Агрегаты 
Агрегат — это тоже сущность: для него требуется явное поле идентификации, и ожидается, что его состояние в течение жизненного цикла экземпляра будет изменяться. Но это куда более широкое понятие, чем просто сущность. Целью этого паттерна является защита согласованности его данных. Поскольку данные агрегата могут изменяться, существуют последствия и проблемы, которые паттерн должен решать для сохранения согласованности своего состояния. 
**Соблюдение согласованности.** Поскольку состояние агрегата может быть изменено, это открывает массу возможностей повреждения его данных. Чтобы обеспечить согласованность данных, паттерн агрегата проводит четкую границу между агрегатом и «внешним миром»: агрегат является границей обеспечения согласованности. Логика агрегата должна проверять все входящие модификации и гарантировать непротиворечивость изменений его бизнес-правилам. 
С точки зрения реализации согласованность обеспечивается тем, что изменять состояние агрегата может исключительно его собственная бизнес-логика. Всем внешним по отношению к агрегату процессам или объектам разрешено только лишь чтение состояния агрегата. Его состояние можно изменить, только лишь выполнив соответствующие методы открытого интерфейса агрегата. 
Методы изменения состояния, представленные в открытом интерфейсе агрегата, часто называют командами (command), например «командой сделать что-то». Команда может быть реализована двумя способами. Во-первых, ее можно реализовать как простой открытый метод агрегатного объекта:
```c#
public class Ticket 
{ 
	... 
	public void AddMessage(UserId from, string body) 
	{ 
		var message = new Message(from, body); 
		_messages.Append(message); 
	} 
	... 
}
```

В качестве альтернативы команда может быть представлена как объект-параметр, инкапсулирующий все входные данные, необходимые для выполнения команды:
```c#
public class Ticket 
{ 
	... 
	public void Execute(AddMessage cmd) 
	{ 
		var message = new Message(cmd.from, cmd.body); 
		_messages.Append(message); 
	} 
	... 
}
```

То, как команды выражаются в коде агрегата, зависит от предпочтений разработчика. Лично я предпочитаю более явный способ определения структур команд и их полиморфную передачу соответствующему методу Execute. 
Открытый интерфейс агрегата отвечает за проверку входных значений и соблюдение всех соответствующих бизнес-правил и инвариантов. Эта строгая граница также гарантирует, что вся бизнес-логика, связанная с агрегатом, реализована в одном месте: в самом агрегате. 
Это делает слой приложения (application layer) , который управляет операциями над агрегатами, довольно простым : ему нужно всего лишь загрузить текущее состояние агрегата, выполнить требуемое действие, сохранить измененное состояние и вернуть результат операции вызывающему коду:
```c#
01 public ExecutionResult Escalate(TicketId id, EscalationReason reason) 
02 { 
03   try 
04   { 
05     var ticket = _ticketRepository.Load(id); 
06     var cmd = new Escalate(reason); 
07     ticket.Execute(cmd); 
08     _ticketRepository.Save(ticket); 
09     return ExecutionResult.Success( ); 
10   } 
11     catch (ConcurrencyException ex) 
12   { 
13     return ExecutionResult.Error(ex); 
14   }
15 }
```

Обратите внимание на проверку конкурентного доступа (concurrency check) в предыдущем коде (строка 11). Крайне важно защитить согласованность состояния агрегата8 . Если один и тот же агрегат обновляет сразу несколько процессов, нужно предотвратить слепую перезапись последней транзакцией тех изменений, что зафиксированы первой транзакцией. В этом случае второй процесс должен быть уведомлен о том, что состояние, на котором он основывал свои решения, устарело, и он должен повторить свою операцию. 
Следовательно, база данных, используемая для хранения агрегатов, должна поддерживать управление конкурентным доступом. В своей простейшей форме агрегат должен содержать поле версии, значение которого будет расти после каждого обновления:
```c#
class Ticket 
{ 
TicketId _id; 
int _version; 

... 
}
```

При фиксации изменения в базе данных нужно убедиться, что перезаписываемая версия соответствует той, которая была первоначально прочитана. Например, в коде на SQL:
```sql
01 UPDATE tickets 
02 SET ticket_status = @new_status, 
03 agg_version = agg_version + 1 
04 WHERE ticket_id=@id and agg_version=@expected_version;
```

Этот SQL-оператор применяет изменения, внесенные в состояние экземпляра агрегата (строка 2), и увеличивает показание его счетчика версий (строка 3), но делает это только в том случае, когда текущая версия равна той, которая была прочитана до применения изменений к состоянию агрегата (строка 4). 
Конечно, управление конкурентным доступом, помимо реляционной базы данных, может быть реализовано где угодно. Кроме того, для работы с агрегатами больше подходят документоориентированные базы данных. При этом крайне важно убедиться, что база данных, используемая для хранения данных агрегата, поддерживает управление конкурентным доступом. 
**Граница транзакции.** Поскольку состояние агрегата может быть изменено только его собственной бизнес-логикой, агрегат также действует как границы транзакции. Все изменения состояния агрегата должны быть зафиксированы транзакцией, т. е. одной атомарной операцией. Если состояние агрегата изменено, то фиксируются либо все изменения, либо ни одно из них. 
Кроме того, ни одна системная операция не может предполагать проведение мультиагрегатной транзакции. Изменение состояния агрегата может быть зафиксировано только индивидуально, за одну транзакцию базы данных должен изменяться только один агрегат. 
Один экземпляр агрегата на каждую транзакцию заставляет тщательно проектировать границы агрегата, гарантируя, что дизайн учитывает инварианты и правила бизнес-области. Необходимость фиксации изменений сразу в нескольких агрегатах сигнализирует о неправильно выбранных границах транзакции и, следовательно, о неправильных границах агрегата. 
Похоже, тем самым накладываются ограничения на моделирование. А что если нужно в одной транзакции изменить сразу несколько объектов? Давайте посмотрим, как такие ситуации решаются в паттерне. 
**Иерархия сущностей.** Как уже упоминалось в этой главе, сущности используются исключительно как часть агрегата, а не в качестве независимого паттерна. Давайте посмотрим на фундаментальное различие между сущностями и агрегатами, а также на то, почему сущности являются строительными блоками агрегата, а не общей модели предметной области. 
Существуют бизнес-сценарии, в которых общую транзакционную границу должны иметь сразу несколько объектов, например когда одновременно могут быть изменены оба объекта или же бизнес-правила одного объекта зависят от состояния другого объекта. 
В DDD предписывается, что дизайн системы должен определяться ее предметной областью. Агрегаты не исключение. Для поддержки изменений сразу нескольких объектов, которые должны быть применены в рамках одной атомарной транзакции, паттерн агрегата уподобляется иерархии сущностей, где, как показано на рис. 6.3, все они без исключений имеют общую транзакционную согласованность. 
Иерархия содержит как сущности, так и объекты-значения, и если они связаны бизнес-логикой предметной области, то все они принадлежат одному и тому же агрегату.

![[Рис. 6.3. Агрегат как иерархия сущностей.png]]

Вот почему паттерн называется «агрегат»: он объединяет бизнес-сущности и объекты-значения, находящиеся в рамках одной и той же границы транзакции. 
В следующем примере кода демонстрируется бизнес-правило, охватывающее сразу несколько сущностей, входящих в границы агрегата: «Если агент не открыл эскалированную заявку в течение 50% времени ответа, она автоматически переназначается другому агенту»:

```c#
01 public class Ticket 
02 { 
03   ... 
04   List _messages; 
05   ... 
06 
07   public void Execute(EvaluateAutomaticActions cmd) 
08   { 
09     if (this.IsEscalated && this.RemainingTimePercentage < 0.5 && 
10     GetUnreadMessagesCount(for: AssignedAgent) > 0) 
11   { 
12     _agent = AssignNewAgent( ); 
13   } 
14 } 
15 
16 public int GetUnreadMessagesCount(UserId id) 
17   { 
18     return _messages.Where(x => x.To == id && !x.WasRead).Count( ); 
19   } 
20 
21 ... 
22 }
```

В методе проверяется значение заявки, чтобы определить, эскалирована она или нет и не осталось ли меньше времени на обработку, чем заданный порог в 50% (строка 9). Кроме того, в нем проверяются сообщения, которые еще не были прочитаны текущим агентом (строка 10). Если все условия соблюдены, запрашивается переназначение заявки другому агенту. 
Агрегат гарантирует, что все проверки выполняются на строго согласованных данных и что эти данные не изменятся после завершения проверки, т. к. все изменения в данных агрегата будут выполнены в виде одной атомарной транзакции. 
**Ссылки на другие агрегаты.** Поскольку все объекты, содержащиеся в агрегате, имеют одну и ту же транзакционную границу, то если агрегат станет слишком большим, могут возникнуть проблемы производительности и масштабируемости. 
Непротиворечивость данных может быть удобным руководящим принципом для проектирования границ агрегата. В состав агрегата должна входить только та информация, которая требуется по бизнес-логике агрегата для строгой согласованности данных. Вся информация, которая может быть согласована по прошествии некоторого времени (согласованность в конечном счете, eventual consistency), должна находиться за пределами агрегата, например, как показано на рис. 6.4, в качестве части другого агрегата.

![[Рис. 6.4. Агрегат как граница согласованности.png]]

Следует придерживаться того правила, чтобы агрегаты были как можно меньше и включали только те объекты, которые в соответствии с бизнес-логикой агрегата должны находиться в строго согласованном состоянии:
```c#
public class Ticket 
{ 
	private UserId _customer; 
	private List _products; 
	private UserId _assignedAgent; 
	private List _messages; 
	... 
}
```

В предыдущем примере агрегат Ticket ссылается на список сообщений, входящих в границы агрегата. А вот клиент, набор продуктов, относящихся к заявке, и назначенный агент не принадлежат агрегату, и следовательно, ссылки на них идут по их идентификаторам. 
Замысел использования ссылки на внешние агрегаты по идентификатору состоит в том, чтобы подтвердить, что эти объекты не находятся в границах агрегата, и гарантировать наличие у каждого агрегата своей собственной транзакционной границы. 
Чтобы решить, принадлежит сущность агрегату или нет, следует проверить, содержит ли агрегат бизнес-логику, которая может привести к недопустимому состоянию системы при работе с данными по принципу согласованности в конечном счете. Вернемся к предыдущему примеру переназначения заявки, если текущий агент не прочитал новые сообщения в течение 50% отведенного на ответ лимита времени. Что получилось бы при достижении согласованности всей информации о прочитанных-непрочитанных сообщениях по прошествии некоторого времени? Иными словами, было бы разумным получать подтверждения о прочтении после некоторой задержки. В данном же случае можно с уверенностью утверждать, что значительное количество заявок было бы переназначено без необходимости. Это, конечно, испортило бы состояние системы. Следовательно, данные о сообщениях находятся в границах агрегата. 
**Корень агрегата.** Нам уже известно, что состояние агрегата можно изменить только путем выполнения одной из его команд. Поскольку агрегат представляет собой иерархию сущностей, то, как показано на рис. 6.5, в качестве общедоступного интерфейса агрегата — его корня, должна быть назначена только одна из них.

![[Рис. 6.5. Корень агрегата.png]]

Рассмотрим следующий фрагмент агрегата Ticket:
```c#
{ 
... 
List _messages; 
... 
public void Execute(AcknowledgeMessage cmd)
	{ 
		var message = _messages.Where(x => x.Id == cmd.id).First( ); 
		message.WasRead = true; 
	} 
... 
}
```

В этом примере агрегат предоставляет команду, позволяющую пометить конкретное сообщение как прочитанное. Хотя операция изменяет экземпляр объекта Message, он доступен только через его корень агрегата: Ticket. 
В дополнение к открытому интерфейсу корня агрегата существует еще один механизм, с помощью которого внешний мир может взаимодействовать с агрегатами: события предметной области. 
**События предметной области.** Событие предметной области — это сообщение с описанием важного события, произошедшего в бизнес-области. Например: 
- Заявка назначена. 
- Заявка эскалирована. 
- Сообщение получено. 
 Поскольку события предметной области описывают то, что уже произошло, их названия следует формулировать в прошедшем времени. 
 Цель события предметной области (domain event) — дать описание тому, что произошло в предметной области, и предоставить все необходимые данные, связанные с событием. Например, следующее событие предметной области сообщает, что конкретная заявка была эскалирована с указанием времени и причины, по которой это произошло:
```json
{ 
	"ticket-id": "c9d286ff-3bca-4f57-94d4-4d4e490867d1", 
	"event-id": 146, 
	"event-type": "ticket-escalated", 
	"escalation-reason": "missed-sla", 
	"escalation-time": 1628970815 
}
```

Как и почти во всем в сфере программирования, присваивание имен играет немаловажную роль. Следует убедиться, что имена событий предметной области точно отражают то, что происходит в предметной области. 
События предметной области являются частью публичного интерфейса агрегата, который публикует события своей предметной области. Как показано на рис. 6.6, другие процессы, агрегаты или даже внешние системы могут подписываться на события предметной области и выполнять в ответ на них свою собственную логику. 
В следующем фрагменте кода агрегата Ticket создается экземпляр нового события предметной области (строка 12), который добавляется к набору событий предметной области заявки (строка 13):

![[Рис. 6.6. Процесс публикации событий предметной области.png]]

```c#
01 public class Ticket 
02 { 
03 ... 
04 private List _domainEvents; 
05 ... 
06 
07 public void Execute(RequestEscalation cmd) 
08 { 
09 if (!this.IsEscalated && this.RemainingTimePercentage <= 0) 
10 { 
11 this.IsEscalated = true; 
12 var escalatedEvent = new TicketEscalated(_id, cmd.Reason); 
13 _domainEvents.Append(escalatedEvent); 
14 } 
15 } 
16 
17 ... 
18 }
```

Возможности надежной публикации событий предметной области для заинтересованных подписчиков будут рассмотрены в *главе 9*. 
**Единый язык (ubiquitous language).** И последнее, но от этого не менее важное: агрегаты должны отражать единый язык. Термины, используемые для имени агрегата, его элементов данных, его действий и его событий предметной области, должны быть сформулированы на едином языке ограниченного контекста. Как выразился Эрик Эванс, код должен быть основан на том же языке, на котором разработчики разговаривают друг с другом и с экспертами предметной области. Это играет особую роль при реализации сложной бизнес-логики. 
А теперь давайте взглянем на третий и последний строительный блок паттерна «модель предметной области». 

# Доменные сервисы (domain service) 
Со временем можно столкнуться с бизнес-логикой, которая либо не принадлежит ни одному агрегату или объекту-значению, либо представляется имеющей отношение сразу к нескольким агрегатам. В таких случаях предметно-ориентированное проектирование предлагает реализовать логику в виде доменного сервиса.
Доменный сервис — это объект без состояния, в котором реализуется бизнеслогика. В подавляющем большинстве случаев такая логика является организатором обращений к различным компонентам системы для выполнения каких-либо вычислений или проведения анализа. 
Вернемся к нашему примеру с агрегатом заявок. Вспомним, что у назначенного агента есть ограниченный срок предложения решения клиенту. Этот срок зависит не только от данных заявки (ее приоритета и статуса эскалации), но и от политики отдела агента в отношении установленного срока (SLA) для каждого приоритета и графика работы агента (смены) — не следует ждать, что агент ответит в нерабочее время. 
Логика расчета сроков ответа требует получения информации сразу из нескольких источников: от заявки, от отдела назначенного агента и от графика работы. Получается просто идеальный кандидат для реализации в качестве службы предметной области:

```c#
public class ResponseTimeFrameCalculationService 
{ 
... 
public ResponseTimeframe CalculateAgentResponseDeadline(UserId agentId, Priority priority, bool escalated, DateTime startTime) 
	{ 
		var policy = _departmentRepository.GetDepartmentPolicy(agentId); 
		var maxProcTime = policy.GetMaxResponseTimeFor(priority); 

		if (escalated) { 
			maxProcTime = maxProcTime * policy.EscalationFactor; 
		} 

		var shifts = _departmentRepository.GetUpcomingShifts(agentId, startTime, startTime.Add(policy.MaxAgentResponseTime)); 
		return CalculateTargetTime(maxProcTime, shifts); 
} 
... 
}
```

Доменные сервисы упрощают координацию работы сразу нескольких агрегатов. Но при этом важно не забывать об ограничениях агрегата, касающихся изменений только одного экземпляра агрегата за одну транзакцию базы данных. Доменные сервисы не создают лазейку для обхода этого ограничения. Правило одного экземпляра за транзакцию остается в силе. Вместо этого доменные сервисы позволяют реализовать логику вычислений, требующую чтения данных сразу нескольких агрегатов. 
Также важно отметить, что службы предметной области не имеют ничего общего с микросервисами, сервисно-ориентированной архитектурой или с почти что любым другим использованием слов «служба» или «сервис» в сфере разработки программных систем. Это просто объект без состояния, используемый для размещения бизнес-логики.

Управление сложностью 
В начале этой главы уже говорилось, что паттерны агрегатов и объектов-значений были введены как средства преодоления сложности при реализации бизнес-логики. Давайте посмотрим, так ли это на самом деле. 
В своей книге «The Choice» гуру управления бизнесом Элияху М. Голдратт (Eliyahu M. Goldratt) дает емкое, но весьма эффектное определение сложности системы. Согласно Голдратту, при рассмотрении вопроса сложности системы основное внимание уделяется оценке сложности контроля поведения системы и предсказанию этого поведения. Эти два аспекта отражаются в степенях свободы системы. 
Степени свободы системы — это опорные точки описания ее состояния. Рассмотрим следующие два класса:

```c#
public class ClassA 
{ 
	public int A { get; set; } 
	public int B { get; set; } 
	public int C { get; set; } 
	public int D { get; set; } 
	public int E { get; set; } 
} 

public class ClassB 
{ 
	private int _a, _d; 

	public int A 
	{ 
		get => _a; 
		set { 
			_a = value; 
			B = value / 2; 
			C = value / 3; 
		} 
	} 

	public int B { get; private set; } 

	public int C { get; private set; } 

	public int D { 
		get => _d;
		set { 
			_d = value; 
			E = value * 2 
		} 
	} 

	public int E { get; private set; } 
}
```

На первый взгляд ClassB представляется несколько сложнее, чем ClassA. У него такое же число переменных, но вдобавок к ним в нем выполняются дополнительные вычисления. Так всё же он сложнее, чем ClassA, или нет? 
Давайте проанализируем оба класса с точки зрения степеней свободы. Сколько элементов данных нужно для описания состояния ClassA? Ответ — пять: это пять его переменных. Следовательно, у ClassA пять степеней свободы. 
Сколько элементов данных нужно для описания состояния ClassB? Если посмотреть на логику присвоения значений свойствам A и D, то можно заметить, что значения B, C и E являются функциями значений A и D. Если знать, что такое A и D, можно вывести значения остальных переменных. Следовательно, у ClassB только две степени свободы. И для описания его состояния нужно всего два значения. 
Возвращаясь к первоначальному вопросу: поведение какого из классов сложнее поддается контролю и предсказанию? Ответ — того, у которого больше степеней свободы, или ClassA. Инварианты, введенные в ClassB, уменьшают его сложность. Именно это и делают паттерны агрегатов и объектов-значений: инкапсулируют инварианты, уменьшая таким образом сложность. 
Вся бизнес-логика, связанная с состоянием объекта-значения, находится в его границах. То же самое справедливо и для агрегатов. Агрегат может быть изменен только его собственными методами. Его бизнес-логика инкапсулирует и защищает бизнес-инварианты, уменьшая тем самым степень свободы. 
Поскольку паттерн модели предметной области применяется только для поддоменов со сложной бизнес-логикой, можно с уверенностью предположить, что местом его применения являются основной поддомен (core subdomain) — сердце программной системы.

# Вывод 
Паттерн модели предметной области предназначен для случаев сложной бизнеслогики. Он состоит из трех основных строительных блоков: 
*Объектов-значений* 
	Это понятия бизнес-области, которые могут быть идентифицированы исключительно по своим значениям, в силу чего им не требуется явное использование поля идентификатора. Поскольку изменение одного из полей семантически создает новое значение, объекты-значения не подлежат изменениям.
	Объекты-значения моделируют не только данные, но и поведение: методы, управляющие значениями и тем самым инициализирующие новые объекты-значения. 
*Агрегатов* 
	Это иерархии сущностей, имеющих общую транзакционную границу. Для реализации бизнес-логики агрегата все данные, включенные в его границы, должны быть строго согласованы. 
	Состояние агрегата и его внутренних объектов можно изменять только через публичный интерфейс путем выполнения команд агрегата. Для внешних компонентов, чтобы гарантировать, что вся бизнес-логика, связанная с агрегатом, находится в его границах, поля данных доступны только для чтения. 
	Агрегат выступает в качестве транзакционной границы. Все его данные, включая все имеющиеся в нем внутренние объекты, должны быть сохранены в базе данных в одной атомарной транзакции. 
	Агрегат может взаимодействовать с внешними объектами, публикуя события предметной области — сообщения, описывающие важные бизнес-события в жизненном цикле агрегата. Другие компоненты могут подписываться на события и использовать их для запуска действий бизнес-логики. 
*Доменных сервисов* 
	Это объект без состояния, содержащий бизнес-логику, которая по естественным причинам не принадлежит ни к одному из агрегатов или объектов-значений модели предметной области. 
Строительные блоки модели предметной области справляются со сложной бизнеслогикой, инкапсулируя ее в границах объектов-значений и агрегатов. Отсутствие возможности изменять состояние объектов извне гарантирует, что вся соответствующая бизнес-логика реализована в границах агрегатов и объектов-значений и не будет дублироваться на уровне приложения. 
В следующей главе будут рассмотрены расширенные способы реализации паттерна модели предметной области, где теперь уже неотъемлемой частью модели станет время.
