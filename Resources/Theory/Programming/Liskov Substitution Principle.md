---
updated_at: 2026-02-12T16:09:43.879+10:00
---
## Принцип подстановки Лисков: наследование без сюрпризов

**Принцип подстановки Лисков** ({{Liskov Substitution Principle|Liskov Substitution Principle}}, LSP) — это принцип объектно-ориентированного проектирования, сформулированный Барбарой Лисков в 1987 году. Он определяет требования к иерархии [[Class|классов]]: если [[Type|тип]] S является подтипом типа T, то объекты типа T могут быть заменены объектами типа S без изменения желательных свойств программы (корректности, выполняемых задач и т.д.).

Принцип подстановки Лисков является третьим принципом [[SOLID|SOLID]].

### Назначение
Следование принципу подстановки Лисков обеспечивает корректное использование [[Inheritance|наследования]] и [[Polymorphism|полиморфизма]]:

*   **Предсказуемость поведения**. Клиентский код, полагающийся на контракт базового типа, может безопасно работать с любым его подтипом, не требуя специальных проверок или знаний о конкретной реализации.
*   **Корректное наследование**. Принцип явно запрещает ослаблять гарантии, предоставляемые базовым классом, что предотвращает создание «нечестных» наследников.
*   **Надёжность расширений**. Новые подтипы могут добавляться без изменения существующего кода, что соответствует принципу [[Open-Closed Principle|открытости/закрытости]].
*   **Сопровождаемость**. Иерархии, следующие LSP, легче понимать и модифицировать, поскольку поведение наследников согласовано с контрактом предков.
*   **Пригодность к формальной верификации**. Чётко определённые пред- и постусловия позволяют математически доказывать корректность подстановки.

### Ограничения
Применение принципа подстановки Лисков сопряжено с рядом практических сложностей:

1.  **Неявные контракты**. Во многих языках программирования пред- и постусловия, инварианты класса не являются частью синтаксиса; они существуют лишь в документации или в сознании разработчиков. Нарушения LSP часто остаются незамеченными до времени выполнения.
2.  **Субъективность поведения**. Определение «желательных свойств программы» зависит от контекста; один и тот же подтип может быть корректной заменой в одном сценарии и нарушать LSP в другом.
3.  **Наследование против композиции**. Частое нарушение LSP сигнализирует о том, что наследование выбрано ошибочно; предпочтительнее использовать композицию, что требует рефакторинга.
4.  **Языковые ограничения**. Некоторые языки допускают ковариантность возвращаемых типов и контравариантность параметров, другие — нет; поддержка LSP зависит от возможностей конкретной системы типов.
5.  **Проблемы с изменяемостью**. Историческое ограничение (history constraint) требует, чтобы подтип не позволял изменять состояние способами, недоступными в супертипе, что трудно обеспечить при наличии публичных сеттеров.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и проверке иерархий, соблюдающих принцип подстановки Лисков:

1.  **Предусловия не могут быть усилены**. Подтип не должен требовать больше, чем супертип. Если метод супертипа принимает целое число от 1 до 10, подтип не может сузить диапазон до 5–8.
2.  **Постусловия не могут быть ослаблены**. Подтип должен гарантировать как минимум то же, что и супертип. Если метод супертипа обещает вернуть неотрицательное число, подтип не может вернуть отрицательное.
3.  **Инварианты типа должны сохраняться**. Все свойства, всегда истинные для объектов супертипа, должны оставаться истинными и для объектов подтипа. Например, если супертип гарантирует уникальность идентификатора, подтип не может допускать дубликаты.
4.  **Ограничения на исключения**. Подтип не должен выбрасывать новые, не объявленные в супертипе, исключения. Исключения, выбрасываемые подтипом, должны быть подтипами исключений, объявленных в супертипе (принцип подстановки для исключений).
5.  **Ковариантность возвращаемого типа**. Подтип может возвращать более конкретный тип, чем супертип (например, метод, объявленный как `Animal getPet()`, в подтипе может возвращать `Dog`). Это безопасно и часто желательно.
6.  **Контравариантность параметров**. Подтип может принимать более общие типы параметров, чем супертип (например, метод, принимающий `Dog`, в подтипе может принимать `Animal`). Многие языки не поддерживают контравариантность напрямую, но LSP это разрешает.
7.  **Историческое ограничение ([[History Constraint|history constraint]])**. Подтип не должен позволять изменять состояние способами, недоступными в супертипе. Если супертип неизменяем, подтип также должен быть неизменяемым.
8.  **Предпочтение композиции наследованию ([[Composition Over Inheritance|composition over inheritance]])**. Когда иерархия начинает нарушать LSP, наследование заменяется делегированием: вместо подтипа создаётся класс, содержащий экземпляр базового типа и реализующий тот же интерфейс через делегирование.
9.  **[[Design by Contract|Контрактное проектирование]]**. Явное определение предусловий, постусловий и инвариантов в коде с помощью аннотаций, ассертов или специализированных библиотек. Это позволяет автоматически проверять соблюдение LSP в рантайме.
10. **Тестирование базовым набором тестов**. Создание абстрактного тестового класса, проверяющего контракт интерфейса или базового класса; все реализации должны проходить этот набор тестов. Это эффективно выявляет нарушения LSP.
11. **Избегание флагов и ветвлений по типу**. Код, содержащий `if (obj instanceof Subtype)`, почти всегда сигнализирует о нарушении LSP. Решением является перенос вариативного поведения в полиморфные методы.
12. **Классический пример: квадрат и прямоугольник**. Наследование квадрата от прямоугольника нарушает LSP, поскольку код, ожидающий прямоугольник, может независимо изменять ширину и высоту, что невозможно для квадрата. Решение — либо общий абстрактный предок, либо композиция.

Таким образом, принцип подстановки Лисков превращает наследование из механического повторного использования кода в строгое отношение подтипирования, сохраняющее поведенческие контракты. Его соблюдение требует дисциплины в проектировании, явного определения контрактов и постоянной проверки соответствия наследников ожиданиям клиентов. В сомнительных ситуациях композиция оказывается более безопасной и гибкой альтернативой.