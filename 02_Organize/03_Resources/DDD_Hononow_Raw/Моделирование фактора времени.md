---
updated_at: 2025-12-15T16:10:50.527+10:00
tags:
---
В предыдущей главе был рассмотрен паттерн модели предметной области: его строительные блоки, назначение и прикладной контекст. Паттерн модели предметной области, основанной на событиях (event-sourced domain model), придерживается тех же предпосылок, что и паттерн простой модели предметной области. В нем такая же сложная бизнес-логика, принадлежащая основному поддомену (core subdomain). Более того, в нем используются те же тактические паттерны, что и в модели предметной области: объекты-значения (value object), агрегаты (aggregate) и события предметной области (domain events). 
Разница между этими паттернами реализации заключается в способе сохранения состояния агрегатов. В модели предметной области, основанной на событиях, для управления состояниями агрегатов используется паттерн «События как источник данных» (Event Sourcing): вместо сохранения состояния агрегата модель генерирует события предметной области, описывающие каждое изменение, и использует их в качестве доверенного источника данных для агрегата. 
Эта глава начинается с введения понятия «События как источник данных» (Event Sourcing). Затем мы рассмотрим, как эта модель объединяется с паттерном модели предметной области, что превращает ее в модель предметной области, основанную на событиях (event-sourced domain model).

# События как источник данных (Event Sourcing) 
	Покажите мне вашу блок-схему и спрячьте свои таблицы, и я так ничего и не пойму. А покажите мне ваши таблицы, и мне вряд ли уже понадобится ваша блок-схема, все будет как на ладони. 
		– Фред Брукс (Fred Brooks)

Чтобы дать определение паттерну «События как источник данных» (Event Sourcing) и понять, чем он отличается от традиционного моделирования и сохранения данных, давайте воспользуемся рассуждениями Фреда Брукса. Изучите табл. 7.1 и постарайтесь понять, к каким выводам о системе, к которой она принадлежит, можно прийти на ее основе. 

![[Таблица 7.1. Модель, основанная на состоянии.png]]

Понятно, что таблица используется для управления потенциальными клиентами или лидами в системе телемаркетинга. Для каждого лида можно увидеть его идентификатор, имя и фамилию, дату создания и обновления записи, номер телефона и текущий статус. 
Изучив различные статусы, мы также можем предположить, через какой цикл обработки проходит каждый потенциальный клиент: 
- Продажи начинаются с потенциального клиента в статусе NEW_LEAD. 
- Обращение по телефону может закончиться тем, что человек не заинтересован в предложении (лид CLOSED), собирается позвонить еще раз (FOLLOWUP_SET) или примет предложение о продаже (PENDING_PAYMENT). 
- Если платеж прошел успешно, лид преобразуется в клиента — CONVERTED. В противном случае платеж может не пройти — PAYMENT_FAILED. 

Вполне солидный объем информации, который можно извлечь путем простого анализа схемы таблицы и хранящихся в ней данных. Можно даже предположить, какой единый язык (ubiquitous language) использовался при моделировании данных. Но какой информации все же не хватает в этой таблице? 
Данные таблицы документируют текущее состояние лидов, но в ней отсутствует информация о том, как каждый лид достиг своего текущего состояния. Мы не можем проанализировать, что происходило в течение жизненного цикла лидов. Мы не знаем, сколько звонков было сделано до того, как лид стал CONVERTED. Была ли покупка совершена сразу или был долгий путь продаж? И стоит ли, опираясь на исторические данные, пытаться связаться с человеком после нескольких последующих обращений или все же разумнее закрыть лид и перейти к более перспективному потенциальному клиенту? Такой информации там нет. Все, что мы знаем, — это текущее состояние потенциальных клиентов. 
Поставленные вопросы отражают интересы бизнеса, необходимые для оптимизации процесса продаж. С точки зрения бизнеса крайне важно вести анализ данных и оптимизировать процесс на основе полученного опыта. Один из способов заполнения недостающей информации заключается в использовании событий в качестве источника для текущего состояния (Event Sourcing). 
Паттерн «События как источник данных» (Event Sourcing) вводит в модель данных фактор времени. Вместо схемы, отражающей текущее состояние агрегатов, система, в которой источником текущего состояния являются события, сохраняет события, фиксирующие каждое изменение в жизненном цикле агрегата. 
Рассмотрим CONVERTED-клиента в строке 12 таблицы 7.1. В следующем листинге показано, как данные человека будут представлены в системе, основанной на событиях:
```json
{
 "lead-id": 12,
 "event-id": 0,
 "event-type": "lead-initialized",
 "first-name": "Casey",
 "last-name": "David",
 "phone-number": "555-2951",
 "timestamp": "2020-05-20T09:52:55.95Z"
},
{
 "lead-id": 12,
 "event-id": 1,
 "event-type": "contacted",
 "timestamp": "2020-05-20T12:32:08.24Z"
},
{
 "lead-id": 12,
 "event-id": 2,
 "event-type": "followup-set",
 "followup-on": "2020-05-27T12:00:00.00Z",
 "timestamp": "2020-05-20T12:32:08.24Z"
},
{
 "lead-id": 12,
 "event-id": 3,
 "event-type": "contact-details-updated",
 "first-name": "Casey",
 "last-name": "Davis",
 "phone-number": "555-8101",
 "timestamp": "2020-05-20T12:32:08.24Z"
},
{
 "lead-id": 12,
 "event-id": 4,
 "event-type": "contacted",
 "timestamp": "2020-05-27T12:02:12.51Z"
},
{
 "lead-id": 12,
 "event-id": 5,
 "event-type": "order-submitted",
 "payment-deadline": "2020-05-30T12:02:12.51Z",
 "timestamp": "2020-05-27T12:02:12.51Z"
},
{
 "lead-id": 12,
 "event-id": 6,
 "event-type": "payment-confirmed",
 "status": "converted",
 "timestamp": "2020-05-27T12:38:44.12Z"
} 
```

События, отображенные в листинге, рассказывают об истории клиента. Лид был создан в системе (событие 0), и примерно через два часа с ним связался торговый агент (событие 1). В ходе звонка было оговорено, что продавец перезвонит через неделю (событие 2), но на другой номер телефона (событие 3). Также продавец исправил опечатку в фамилии (событие 3). В согласованные дату и время с лидом связались (событие 4) и отправили заказ (событие 5). Заказ должен был быть оплачен через три дня (событие 5), но оплата поступила примерно через полчаса (событие 6), а лид конвертировался в нового покупателя. 
Как уже ранее стало понятно, состояние клиента можно легко спроецировать по этим событиям предметной области. Нужно всего лишь последовательно применить простую логику преобразования к каждому событию:

```c#
public class LeadSearchModelProjection
{
    public long LeadId { get; private set; }
    public HashSet<string> FirstNames { get; private set; }
    public HashSet<string> LastNames { get; private set; }
    public HashSet<PhoneNumber> PhoneNumbers { get; private set; }
    public int Version { get; private set; }
    
    public void Apply(LeadInitialized @event)
    {
        LeadId = @event.LeadId;
        FirstNames = new HashSet<string>();
        LastNames = new HashSet<string>();
        PhoneNumbers = new HashSet<PhoneNumber>();
        
        FirstNames.Add(@event.FirstName);
        LastNames.Add(@event.LastName);
        PhoneNumbers.Add(@event.PhoneNumber);
        
        Version = 0;
    }
    
    public void Apply(ContactDetailsChanged @event)
    {
        FirstNames.Add(@event.FirstName);
        LastNames.Add(@event.LastName);
        PhoneNumbers.Add(@event.PhoneNumber);
        
        Version += 1;
    }
    
    public void Apply(Contacted @event)
    {
        Version += 1;
    }
    
    public void Apply(FollowupSet @event)
    {
        Version += 1;
    }
    
    public void Apply(OrderSubmitted @event)
    {
        Version += 1;
    }
    
    public void Apply(PaymentConfirmed @event)
    {
        Version += 1;
    }
}
```

Итерация по событиям агрегата и их последовательная передача в соответствующий переопределенный метод Apply создаст точно такое же представление состояния, которое смоделировано в таблице 7.1. 
Обратите внимание на поле версии Version, значение которого увеличивается после применения каждого события. Его значение представляет собой общее количество модификаций, внесенных в бизнес-сущность. Более того, предположим, что мы применили к агрегату только некоторое подмножество событий. В таком случае появляется возможность «путешествия во времени»: обращаясь только лишь к соответствующим событиям, можно спроецировать состояние сущности в любой момент его жизненного цикла. Например, если нужно получить состояние объекта в версии 5, можно обратиться только к первым пяти событиям. 
И наконец, мы не ограничены только одной проекцией состояния! Рассмотрим следующие сценарии.

## Поиск

Представим, что возникла необходимость в реализации поиска. Но, поскольку контактная информация потенциального клиента (лида) — имя, фамилия и номер телефона — может быть обновлена, агенты по продажам могут не знать об изменениях, внесенных другими агентами, и могут захотеть найти потенциальных клиентов, пользуясь своей контактной информацией, включая ранее зафиксированные значения. Хронологическая информация легко может быть спроецирована:

```csharp
public class LeadSearchModelProjection
{
    public long LeadId { get; private set; }
    public HashSet<string> FirstNames { get; private set; }
    public HashSet<string> LastNames { get; private set; }
    public HashSet<PhoneNumber> PhoneNumbers { get; private set; }
    public int Version { get; private set; }
    
    public void Apply(LeadInitialized @event)
    {
        LeadId = @event.LeadId;
        FirstNames = new HashSet<string>();
        LastNames = new HashSet<string>();
        PhoneNumbers = new HashSet<PhoneNumber>();
        
        FirstNames.Add(@event.FirstName);
        LastNames.Add(@event.LastName);
        PhoneNumbers.Add(@event.PhoneNumber);
        
        Version = 0;
    }
    
    public void Apply(ContactDetailsChanged @event)
    {
        FirstNames.Add(@event.FirstName);
        LastNames.Add(@event.LastName);
        PhoneNumbers.Add(@event.PhoneNumber);
        
        Version += 1;
    }
    
    public void Apply(Contacted @event)
    {
        Version += 1;
    }
    
    public void Apply(FollowupSet @event)
    {
        Version += 1;
    }
    
    public void Apply(OrderSubmitted @event)
    {
        Version += 1;
    }
    
    public void Apply(PaymentConfirmed @event)
    {
        Version += 1;
    }
}
```

Для заполнения соответствующих наборов личных данных лида в логике проекции используются события `LeadInitialized` и `ContactDetailsChanged`. Другие события игнорируются, т. к. они не влияют на состояние конкретной модели.

Применение этой логики проецирования к событиям Кейси Дэвиса (Casey Davis) из предыдущего примера приведет к следующему состоянию:

```
LeadId: 12
FirstNames: ['Casey']
LastNames: ['David', 'Davis']
PhoneNumbers: ['555-2951', '555-8101']
Version: 6
```

## Анализ

Отдел бизнес-аналитики вашей компании просит предоставить более удобное для анализа представление данных о потенциальных клиентах. Для своего текущего исследования они хотят получить количество последующих звонков, запланированных для разных лидов. Позже они будут фильтровать данные о конверсиях и закрытых лидах и использовать модель для оптимизации процесса продаж. Давайте спроецируем запрашиваемые ими данные:

```csharp
public class AnalysisModelProjection
{
    public long LeadId { get; private set; }
    public int Followups { get; private set; }
    public LeadStatus Status { get; private set; }
    public int Version { get; private set; }
    
    public void Apply(LeadInitialized @event)
    {
        LeadId = @event.LeadId;
        Followups = 0;
        Status = LeadStatus.NEW_LEAD;
        Version = 0;
    }
    
    public void Apply(Contacted @event)
    {
        Version += 1;
    }
    
    public void Apply(FollowupSet @event)
    {
        Status = LeadStatus.FOLLOWUP_SET;
        Followups += 1;
        Version += 1;
    }
    
    public void Apply(ContactDetailsChanged @event)
    {
        Version += 1;
    }
    
    public void Apply(OrderSubmitted @event)
    {
        Status = LeadStatus.PENDING_PAYMENT;
        Version += 1;
    }
    
    public void Apply(PaymentConfirmed @event)
    {
        Status = LeadStatus.CONVERTED;
        Version += 1;
    }
}
```

Показанная выше логика поддерживает счетчик количества появлений последующих звонков в событиях лида. Если применить эту проекцию, к примеру, с событиями агрегата, она сгенерирует следующее состояние:

```
LeadId: 12
Followups: 1
Status: Converted
Version: 6
```

Логика, реализованная в предыдущих примерах, проецирует модели, оптимизированные для поиска и анализа, в память. Но для фактической реализации требуемой функциональности спроецированные модели необходимо сохранить в базе данных. Паттерн, позволяющий это сделать: разделение ответственности команд и запросов (CQRS), будет рассмотрен в главе 8.

## Источник истины

Чтобы паттерн «События как источник данных» работал, все изменения состояния объекта должны быть представлены и сохранены как события. Эти события становятся для системы источником истины (отсюда и название паттерна). Этот процесс показан на рис. 7.1.

![[Рис. 7.1. Агрегат, основанный на событиях.png]]

База данных, в которой хранятся системные события, — это единственное строго согласованное хранилище: системный источник истины. Базу данных, используемую для сохранения событий, принято называть хранилищем событий (event store).

## Хранилище событий

Хранилище событий (event store) не должно разрешать изменять или удалять события, поскольку оно предназначено только для их хранения. Для поддержки реализации паттерна «События как источник данных» хранилище событий должно поддерживать как минимум следующие операции: извлечение всех событий, принадлежащих определенной бизнес-сущности, и добавление событий. Например:

```csharp
interface IEventStore
{
    IEnumerable<Event> Fetch(Guid instanceId);
    void Append(Guid instanceId, Event[] newEvents, int expectedVersion);
}
```

Аргумент `expectedVersion` метода `Append` необходим для реализации оптимистичного управления конкурентным доступом: при добавлении новых событий указывается также версия сущности, на которой основаны ваши решения. Если сущность устарела, т. е. после ожидаемой версии были добавлены новые события, хранилище событий должно порождать исключение (ошибку) конкурентного доступа.
В большинстве систем для реализации паттерна CQRS требуются дополнительные эндпоинты, речь о которых пойдет в следующей главе.

*По своей сути, паттерн «События как источник данных» не является чем-то новым. Финансовая индустрия использует события для представления изменений в бухгалтерском реестре. Реестр — это журнал, предназначенный только для добавления записей, в котором документируются транзакции. Текущее состояние (например, баланс счета) всегда можно вывести путем «проецирования» записей реестра.*

## Модель предметной области, основанная на событиях

Исходная модель предметной области работает через отображение состояния своих агрегатов и порождает события предметной области. Модель предметной области, основанная на событиях, использует события предметной области исключительно для моделирования жизненных циклов агрегатов. Все изменения состояния агрегата должны быть выражены в виде событий предметной области.
Сценарий, по которому проводится каждая операция с агрегатом, основанным на событиях, имеет следующий вид:
- Загрузка событий предметной области агрегата.
- Воссоздание состояния — проецирование событий в представление состояния, которое может быть использовано для принятия бизнес-решений.
- Выполнение команды бизнес-логики агрегата и, следовательно, порождение новых событий предметной области.
- Фиксация новых событий предметной области в хранилище событий (event store).

Возвращаясь к коду примера с агрегатом Ticket из главы 6, давайте посмотрим на его реализацию в качестве агрегата на основе событий.
Прикладной слой следует сценарию, описанному выше: загружает соответствующие события заявки, восстанавливает экземпляр агрегата, вызывает соответствующую команду (command) и сохраняет изменения в базе данных:

```csharp
01 public class TicketAPI
02 {
03     private ITicketsRepository _ticketsRepository;
04     ...
05
06     public void RequestEscalation(TicketId id, EscalationReason reason)
07     {
08         var events = _ticketsRepository.LoadEvents(id);
09         var ticket = new Ticket(events);
10         var originalVersion = ticket.Version;
11         var cmd = new RequestEscalation(reason);
12         ticket.Execute(cmd);
13         _ticketsRepository.CommitChanges(ticket, originalVersion);
14     }
15
16     ...
17 }
```

Согласно логике восстановления агрегата Ticket в конструкторе (строки с 27-й по 31-ю), создается экземпляр класса проекции состояния, TicketState, и для каждого из событий заявки последовательно вызывается его метод AppendEvent:

```csharp
18 public class Ticket
19 {
20     ...
21     private List<DomainEvent> _domainEvents = new List<DomainEvent>();
22     private TicketState _state;
23     ...
24
25     public Ticket(IEnumerable<IDomainEvents> events)
26     {
27         _state = new TicketState();
28         foreach (var e in events)
29         {
30             AppendEvent(e);
31         }
32     }
```

AppendEvent передает входящие события в логику проекции TicketState, создавая тем самым в памяти представление текущего состояния заявки:

```csharp
33     private void AppendEvent(IDomainEvent @event)
34     {
35         _domainEvents.Append(@event);
36         // Вызов в динамическом режиме нужного переопределения метода "Apply".
37         ((dynamic)state).Apply((dynamic)@event);
38     }
```

В отличие от реализации, показанной в предыдущей главе, метод RequestEscalation, принадлежащий агрегату, чье состояние восстанавливается на основе событий, явным образом флаг IsEscalated в значение true не устанавливает. Вместо этого он выдает соответствующее событие и передает его методу AppendEvent (строки 43 и 44):

```csharp
39     public void Execute(RequestEscalation cmd)
40     {
41         if (!_state.IsEscalated && _state.RemainingTimePercentage <= 0)
42         {
43             var escalatedEvent = new TicketEscalated(_id, cmd.Reason);
44             AppendEvent(escalatedEvent);
45         }
46     }
47
48     ...
49 }
```

Все события, добавленные в коллекцию событий агрегата, передаются в логику проекции состояния в классе TicketState, где значения соответствующих полей изменяются согласно данным событий:

```csharp
50 public class TicketState
51 {
52     public TicketId Id { get; private set; }
53     public int Version { get; private set; }
54     public bool IsEscalated { get; private set; }
55     ...
56     public void Apply(TicketInitialized @event)
57     {
58         Id = @event.Id;
59         Version = 0;
60         IsEscalated = false;
61         ....
62     }
63
64     public void Apply(TicketEscalated @event)
65     {
66         IsEscalated = true;
67         Version += 1;
68     }
69
70     ...
71 }
```

А теперь давайте рассмотрим преимущества использования паттерна «События как источник данных» (Event Sourcing) при реализации сложной бизнес-логики.

---
**Почему выбрано название «Модель предметной области, основанная на событиях»?**
*Видимо, стоит объяснить, почему здесь используется понятие «модель предметной области, основанная на событиях» (Event-sourced domain model), а не просто «События как источник данных» (Event Sourcing). Использование событий для представления переходов между состояниями, т. е. паттерна «События как источник данных» (Event Sourcing), возможно как со строительными блоками модели предметной области, так и без них. Поэтому я предпочитаю в более долгосрочной перспективе явно указывать, что мы используем события для представления изменений в жизненных циклах агрегатов модели предметной области (eventsourced domain model).*

---

## Преимущества

По сравнению с более традиционной моделью, в которой текущие состояния агрегатов сохраняются в базе данных, модель предметной области, основанная на событиях (event-sourced domain model), требует для моделирования агрегатов большего объема работы. Но этот подход дает существенные преимущества, которые делают его достойным рассмотрения во многих сценариях:

*Путешествие во времени*
	События предметной области можно использовать не только для восстановления текущего состояния агрегата, но и для восстановления всех прошлых состояний агрегата. Иными словами, все прошлые состояния агрегата всегда можно восстановить. 
	Такое часто делается при анализе поведения системы, проверке решений системы и оптимизации бизнес-логики.
	Другим распространенным вариантом использования для восстановления прошлых состояний является ретроспективная отладка: агрегат можно вернуть в то самое состояние, в котором он находился, когда была обнаружена ошибка.
*Глубокое понимание сути происходящего*
	В первой части этой книги была показана стратегическая важность для бизнеса оптимизации основных поддоменов. Использование событий в качестве источника данных (Event Sourcing) обеспечивает глубокое понимание состояния и поведения системы. Как уже говорилось в этой главе, паттерн «События как источник данных» (Event Sourcing) предоставляет гибкую модель, позволяющую выполнять преобразования событий в различные представления состояния: в любой момент для получения дополнительной информации на основе прошедших событий можно будет добавить аналитические оценки.
*Журнал аудита*
	Сохраняемые события предметной области представляют собой строго согласованный журнал аудита всего произошедшего с состояниями агрегатов. Законы обязывают некоторые бизнес-сферы внедрять такие журналы аудита, а использование паттерна «События как источник данных» (Event Sourcing) обеспечивает их ведение по умолчанию.
	Эта модель особенно удобна для систем, управляющих деньгами или денежными транзакциями. Она позволяет легко отслеживать решения системы и движение средств между счетами.
*Расширенное оптимистичное управление параллельными вычислениями*
	Когда во время записи уже считанные данные устаревают, т. е. перезаписываются другим процессом, классической моделью оптимистичного параллелизма выдается исключение.
	Используя «События как источник данных» (Event Sourcing), можно получить более глубокое представление о том, что именно произошло между чтением существующих событий и записью новых. Можно запросить именно те события, которые были одновременно добавлены в хранилище событий, и принять решение, основанное на сути предметной области, о том, конфликтуют ли новые события с предпринимаемой операцией или дополнительные события не имеют значения и операцию можно продолжить.

## Недостатки

На основе всего вышеизложенного может показаться, что модель предметной области, основанная на событиях (event-sourced domain model), является чуть ли не самым лучшим паттерном реализации бизнес-логики, в силу чего должна использоваться как можно чаще. Конечно, это противоречило бы принципу, согласно которому проектные решения определяются потребностями предметной области. Поэтому давайте рассмотрим ряд сложностей, связанных с паттерном:
*Кривая обучения*
	Очевидным недостатком паттерна является его резкое отличие от традиционных приемов управления данными. Успешная реализация требует его освоения командой и времени привыкания к новому мышлении. Если у команды еще нет опыта внедрения подобных систем, необходимо учитывать кривую обучения.

*Развитие модели*
	Развитие модели, основанной на событиях, может быть довольно сложным испытанием. В строгом определении паттерна «События как источник данных» (Event Sourcing) говорится, что события неизменяемы (immutable). А как тогда изменять схему событий? Этот процесс куда сложнее изменения схемы таблицы. Фактически исключительно этой теме была посвящена целая книга Грега Янга (Greg Young) «Versioning in an Event Sourced System».
*Архитектурная сложность*
	Реализация паттерна «События как источник данных» (Event Sourcing) не обходится без множества архитектурных «подвижных деталей», что усложняет общую конструкцию. Более подробно эта тема будет рассмотрена в следующей главе при обсуждении CQRS-архитектуры.
Все эти проблемы обостряются еще сильнее, если использование паттерна не оправдывается поставленной задачей, которая может быть решена с помощью более простого дизайна. В главе 10 буду рассмотрены простые эмпирические правила, призванные помочь в выборе паттерна реализации бизнес-логики.

## Часто задаваемые вопросы

Когда программисты знакомятся с паттерном «События как источник данных» (Event Sourcing), у них зачастую возникают одни и те же общие вопросы, ответы на которые все же, наверное, нужно дать в этой главе.

### Производительность

Восстановление состояния агрегата из событий окажет негативное влияние на производительность системы. И по мере добавления событий ситуация будет только ухудшаться. Как это вообще может работать?
Проецирование событий в представление состояния действительно требует расходов вычислительной мощности, и по мере добавления новых событий в список агрегатов эта потребность будет расти.
Важно оценить влияние проецирования на производительность: последствия от работы с сотнями или тысячами событий. Результаты нужно сравнивать, сообразуясь с ожидаемым сроком жизни агрегата — с количеством ожидаемых регистрируемых за этот средний срок событий.
В большинстве систем падение производительности будет заметно только после 10 000+ событий на агрегат. При этом в подавляющем большинстве систем средний срок жизни агрегата не превышает 100 событий.
В редких случаях, когда проецирование состояний выливается в проблему производительности, можно реализовать другой паттерн: срез состояния (snapshot). В этом паттерне, показанном на рис. 7.2, реализуются следующие шаги:

 - Процесс выполняет непрерывный перебор новых событий в хранилище, генерирует соответствующие проекции и сохраняет их в кеше.
 - Проекция в памяти (in-memory) необходима для выполнения действия над агрегатом. При этом:
	- Процесс извлекает проекцию текущего состояния из кеша.
	- Процесс извлекает события, имевшие место после последней версии среза состояния из хранилища событий.
	- К срезу состояния (snapshot) в памяти применяются дополнительные события.

Стоит напомнить, что паттерн срезов состояния (snapshot) — это оптимизация, требующая обоснования. Если для агрегатов в вашей системе не будет сохраняться более 10 000 событий, реализация этого паттерна станет просто ненужным усложнением. Прежде чем приступить к реализации, лучше вернуться немного назад и еще раз проверить границы агрегата.

*Этой моделью создается огромный объем данных. Можно ли ее масштабировать?*
	Модель, основанная на событиях, легко поддается масштабированию. Поскольку все операции, связанные с агрегатом, выполняются в контексте одного-единственного агрегата, хранилище событий можно сегментировать по идентификаторам агрегата: все события, принадлежащие экземпляру агрегата, должны находиться в одном сегменте (см. рис. 7.3).

![[Рис. 7.2. Получение среза состояния событий агрегата.png]]

![[Рис. 7.3. Сегментирование хранилища событий.png]]

Удаление данных

Хранилище событий — это база данных, предназначенная только для добавления, но что если возникнет потребность в физическом удалении данных, например, для соблюдения общего положения по защите данных — GDPR3?

Эта потребность может быть удовлетворена с помощью паттерна «забываемой» полезной нагрузки (forgettable payload): вся конфиденциальная информация включается в события в зашифрованном виде. Ключ шифрования хранится во внешнем хранилище типа ключ-значение, т. е. в хранилище ключей, где ключ — это идентификатор определенного агрегата, а значение — ключ шифрования. Когда конфиденциальные данные должны быть удалены, ключ шифрования удаляется из хранилища ключей. В результате конфиденциальная информация, содержащаяся в событиях, становится недоступной.

## А почему просто нельзя...

**А почему просто нельзя записывать логи в текстовый файл и использовать его как журнал аудита?**
	Запись данных и в рабочую базу данных, и в файл журнала является операцией, которая может завершаться ошибкой. По сути, это транзакция, охватывающая два механизма хранения: базу данных и файл. Если первый не сработал, со вторым нужно провести операцию отката. Например, если при транзакции в базе данных произошел сбой, удалять сообщение из журнала будет просто некому. Следовательно, подобные журналы не будут согласованы и, скорее всего, в конечном итоге станут противоречить друг другу.
**А нельзя ли продолжать работать с моделью на основе состояний, но в той же транзакции базы данных добавлять регистрационные записи в журнальную таблицу?**
	С позиции инфраструктуры такой подход обеспечивает непротиворечивую синхронизацию состояния и записей журнала. И все же вероятность возникновения ошибок остается. Что если программист, занимающийся сопровождением кодовой базы в будущем, просто забудет добавить соответствующую запись в журнал? 
	Более того, когда в качестве источника истины используется представление на основе состояния, схема с дополнительной журнальной таблицей обычно быстро превращается в хаос. Обеспечить запись всей необходимой информации в корректном формате просто невозможно.

**А нельзя ли просто продолжать работать с моделью на основе состояний, но добавить триггер базы данных, который сделает срез состояния записи и скопирует его в специальную таблицу «истории»?**
	Такой подход устранит недостаток предыдущего подхода: явные ручные вызовы для добавления записей в таблицу журнала уже не потребуются. Но при этом получаемая история будет включать только сухие факты: какие именно поля были изменены. А бизнес-контекст: почему поля были изменены, будет упущен из виду. Отсутствие этого «почему» резко ограничивает возможность проецирования дополнительных моделей.

# Вывод

В этой главе был рассмотрен паттерн «События как источник данных» (Event Sourcing) и вопросы его применения для моделирования фактора времени в агрегатах модели предметной области.
В модели предметной области, основанной на событиях (event-sourced domain model), все изменения состояния агрегата выражаются в виде серии событий предметной области. Этим она отличается от более традиционных подходов, в которых при изменении состояния происходит простое обновление записи в базе данных.
Произошедшие события предметной области можно использовать для проецирования текущего состояния агрегата. Более того, модель, основанная на событиях, позволяет проецировать события на несколько моделей представления, каждая из которых оптимизирована для решения своей конкретной задачи.
Этот паттерн подходит для тех случаев, когда крайне важно иметь глубокое представление о данных системы, например для анализа и оптимизации, или же в силу требований закона о ведении журнала аудита.
Этой главой завершается наше исследование различных способов моделирования и реализации бизнес-логики. В следующей главе наше внимание будет переключено на паттерны более высокого уровня, имеющие непосредственное отношение к архитектуре системы.
