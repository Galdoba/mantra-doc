---
updated_at: 2026-02-12T16:05:53.277+10:00
---
## SOLID: принципы объектно-ориентированного проектирования

**SOLID** — это акроним, обозначающий пять фундаментальных принципов объектно-ориентированного проектирования, сформулированных Робертом Мартином. Эти принципы описывают свойства архитектуры, устойчивой к изменениям, удобной для сопровождения и расширения. Аббревиатура составлена из первых букв английских названий каждого принципа:

- **[[Single Responsibility Principle|S — принцип единственной ответственности]]**
- **[[Open-Closed Principle|O — принцип открытости/закрытости]]**
- **[[Liskov Substitution Principle|L — принцип подстановки Лисков]]**
- **[[Interface Segregation Principle|I — принцип разделения интерфейса]]**
- **[[Dependency Inversion Principle|D — принцип инверсии зависимостей]]**

### Назначение
Применение SOLID-принципов направлено на снижение связанности, повышение связности и улучшение сопровождаемости объектно-ориентированных систем:

*   **Устойчивость к изменениям**. Каждый принцип локализует влияние изменений, минимизируя каскадные правки в кодовой базе.
*   **Читаемость и понятность**. Модули, следующие принципам, имеют чёткие границы ответственности и хорошо документированные контракты.
*   **Переиспользование**. Слабая связанность и ориентация на абстракции позволяют повторно использовать компоненты в различных контекстах.
*   **Тестируемость**. Изоляция зависимостей и инверсия управления упрощают модульное тестирование и применение заместителей.
*   **Параллельная разработка**. Чётко разделённые модули могут разрабатываться разными командами с минимальной координацией.

### Ограничения
Принципы SOLID не являются универсальными законами и имеют область применимости:

1.  **Объектно-ориентированная парадигма**. Принципы сформулированы для классов и интерфейсов в статически типизированных ОО-языках; в других парадигмах (функциональное, прототипное программирование) они требуют переосмысления или неприменимы.
2.  **Избыточность для простых систем**. В небольших проектах с ограниченным жизненным циклом строгое следование всем пяти принципам приводит к чрезмерному усложнению и увеличению объёма кода без ощутимой выгоды.
3.  **Субъективность трактовки**. Границы единственной ответственности, корректность подстановки и степень дробления интерфейсов зависят от контекста и опыта разработчика; возможны различные интерпретации.
4.  **Конфликт с производительностью**. Некоторые принципы (особенно инверсия зависимостей и разделение интерфейсов) могут увеличивать количество косвенных вызовов и потребление памяти, что в критичных по производительности системах требует компромиссов.
5.  **Недостаточность для архитектуры**. SOLID описывает качества на уровне классов и модулей, но не охватывает стратегические аспекты (декомпозицию на сервисы, управление данными, распределённые транзакции).

### Сложившиеся практики
Индустрия выработала устойчивый набор рекомендаций по применению SOLID-принципов в комбинации с другими подходами:

1.  **Единственная ответственность (SRP)**. Класс должен иметь только одну причину для изменения. Практика: выделение сквозных функциональностей (логирование, сериализация) в отдельные классы; использование [[Facade|фасадов]] для делегирования; разделение классов, содержащих и бизнес-логику, и инфраструктурный код.

2.  **Открытость/закрытость (OCP)**. Классы должны быть открыты для расширения, но закрыты для модификации. Практика: применение [[Strategy|стратегии]], [[Template Method|шаблонного метода]], [[Decorator|декоратора]]; проектирование на основе интерфейсов; внедрение зависимостей вместо условных операторов.

3.  **Подстановка Лисков (LSP)**. Функции, использующие базовый тип, должны иметь возможность работать с его подтипами, не зная об этом. Практика: строгое соблюдение контрактов пред- и постусловий; избегание усиления предусловий и ослабления постусловий в наследниках; предпочтение композиции наследованию в спорных случаях.

4.  **Разделение интерфейса (ISP)**. Клиенты не должны зависеть от интерфейсов, которые они не используют. Практика: декомпозиция «толстых» интерфейсов на специализированные; применение [[Role Interface|ролевых интерфейсов]]; использование множественного наследования интерфейсов.

5.  **Инверсия зависимостей (DIP)**. Модули верхних уровней не должны зависеть от модулей нижних уровней; оба типа должны зависеть от абстракций. Практика: внедрение зависимостей через конструктор; определение интерфейсов в том же слое, где они используются; применение контейнеров внедрения зависимостей.

6.  **Комбинирование с [[Domain-Driven Design|предметно-ориентированным проектированием]]**. SOLID-принципы естественным образом применяются при построении [[Domain Model|модели предметной области]]: сущности и объекты-значения следуют SRP и OCP, репозитории — DIP.

7.  **Использование статических анализаторов и метрик**. Инструменты проверки кода (SonarQube, NDepend) автоматически выявляют нарушения: классы с высокой цикломатической сложностью, большие интерфейсы, циклические зависимости.

8.  **Рефакторинг к SOLID**. Проекты не обязаны изначально соответствовать принципам; допустимо итеративное улучшение архитектуры по мере накопления технического долга (выделение интерфейсов, замена условной логики полиморфизмом).

Таким образом, SOLID представляет собой не жёсткий стандарт, а набор эвристик, позволяющих оценивать и улучшать качество объектно-ориентированного кода. Их систематическое применение в сочетании с прагматичной оценкой целесообразности способствует созданию систем, устойчивых к изменениям требований и легко поддерживаемых на протяжении длительного жизненного цикла.