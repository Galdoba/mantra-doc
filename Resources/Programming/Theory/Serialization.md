---
updated_at: 2026-02-14T14:28:29.688+10:00
aliases:
  - сериализация
  - десериализация
  - json
  - toml
  - yaml
---
**Сериализация** — это процесс преобразования объектов или структур данных, находящихся в оперативной памяти, в формат, пригодный для сохранения во внешней среде (файл, база данных) или передачи по сети. Обратный процесс восстановления объекта из сериализованного представления называется **[[Deserialization|десериализация]]**.

Сериализация обеспечивает отделение представления данных от их внутренней организации в адресном пространстве конкретного процесса, позволяя перемещать данные между различными системами, языками программирования и архитектурами.

### Назначение
Сериализация решает несколько фундаментальных задач в разработке программных систем:

*   **Долговременное хранение**. Сохранение состояния объектов между перезапусками приложения (сессии, кэши, документы).
*   **Сетевой обмен**. Передача данных между клиентом и сервером, между [[Microservices|микросервисами]] через [[Inter-Process Communication|межпроцессное взаимодействие]].
*   **Межъязыковое взаимодействие**. Обеспечение совместимости компонентов, написанных на разных языках программирования.
*   **Глубокая копия**. Создание независимых копий сложных графов объектов через сериализацию с последующей десериализацией.
*   **Кэширование**. Сохранение результатов дорогостоящих вычислений в виде сериализованных данных в Redis, Memcached или на диске.

### Ограничения
Использование сериализации сопряжено с рядом ограничений и рисков, которые необходимо учитывать при проектировании:

1.  **Производительность и размер**. Процесс сериализации требует вычислительных ресурсов, а результирующее представление занимает больше места, чем исходные данные в памяти. Бинарные форматы компактнее и быстрее текстовых, но менее читаемы.
2.  **Эволюция схем**. При изменении структуры классов возникает проблема несовместимости старого и нового форматов. Объекты, сериализованные прежней версией, могут не десериализоваться новой, если не предусмотрена [[Schema Evolution|эволюция схемы]].
3.  **Безопасность**. Поток байтов, поступающий из ненадёжного источника, может содержать вредоносные данные, приводящие при десериализации к выполнению произвольного кода, отказу в обслуживании или несанкционированному доступу.
4.  **Потеря типов и поведения**. Сериализуются только данные; код (методы, функции) не передаётся. Восстановленный объект требует наличия соответствующего класса в среде выполнения.
5.  **Сложные графы и циклические ссылки**. Объекты со ссылками друг на друга требуют специальной обработки для избежания зацикливания и избыточного копирования.
6.  **Платформенная зависимость**. Некоторые встроенные механизмы сериализации (например, в конкретных языках) привязывают данные к среде выполнения, что делает невозможным их использование в гетерогенных системах.

### Сложившиеся практики
За десятилетия развития индустрии сформировались устойчивые подходы к выбору и применению сериализации:

1.  **Выбор формата сериализации**. Для задач, где критична читаемость и отладка, используются текстовые форматы — [[JSON]], XML, YAML. Для высокопроизводительных систем и ограниченной пропускной способности предпочтительны бинарные форматы: [[Protocol Buffers|Protocol Buffers (protobuf)]], Apache Avro, MessagePack, CBOR, Apache Thrift.

2.  **Использование языков описания интерфейсов (IDL)**. Форматы, поддерживающие IDL (protobuf, Avro, Thrift), позволяют декларативно описывать структуры данных независимо от языка реализации. По описанию генерируется код для сериализации/десериализации на целевых языках, что гарантирует согласованность и эффективность.

3.  **Поддержка эволюции схемы**. Проектирование протоколов сериализации с учётом обратной и прямой совместимости. Практики:
    *   добавление новых полей с опциональными значениями и дефолтами;
    *   использование тегов (номеров полей) вместо имён (protobuf);
    *   явное управление версиями схемы в заголовке сообщения;
    *   резервирование полей для будущего использования.

4.  **Избегание встроенной сериализации языка**. Встроенные механизмы (Java Serialization, .NET BinaryFormatter, Python pickle) считаются устаревшими для межсистемного обмена из-за проблем безопасности, производительности и привязки к конкретной реализации. Предпочтение отдаётся независимым библиотекам и форматам.

5.  **Валидация на этапе десериализации**. Входные данные проверяются на соответствие ожидаемой схеме, границам значений и отсутствие вредоносных конструкций. Реализуется либо средствами схемы, либо явными проверками после десериализации.

6.  **Явное управление сериализуемыми полями**. Вместо автоматической сериализации всех полей разработчик явно указывает, какие данные должны сохраняться. Поля, содержащие временные данные, кэши, открытые дескрипторы или секреты, помечаются как [[Transient Field|транзиентные]] (исключённые из сериализации).

7.  **[[Serialization Proxy|Прокси-объекты для сериализации]]**. Паттерн, при котором вместо самого объекта сериализуется его компактное представление (прокси), а при десериализации из прокси восстанавливается основной объект. Улучшает инкапсуляцию, упрощает эволюцию и позволяет избегать сериализации внутреннего состояния.

8.  **Сжатие и шифрование**. Для уменьшения объёма передаваемых данных перед отправкой сериализованный буфер сжимается (gzip, Snappy, LZ4). Чувствительные данные дополнительно шифруются на уровне приложения или транспорта.

9.  **Документирование схем**. Схемы данных хранятся в системе контроля версий, проходят ревью и сопровождаются описанием семантики полей. В крупных проектах используется центральный реестр схем (Schema Registry), обеспечивающий согласованность версий между производителями и потребителями.

10. **Асинхронная сериализация**. В высоконагруженных системах процесс преобразования данных выносится в отдельные потоки или очереди, чтобы не блокировать основной поток обработки запросов.

11. **Тестирование совместимости**. Регулярное выполнение тестов, проверяющих возможность десериализовать данные, созданные предыдущими версиями, и корректную обработку отсутствующих или новых полей.

Таким образом, сериализация является критически важным инфраструктурным механизмом в современных распределённых системах. Выбор конкретного подхода диктуется требованиями к производительности, безопасности, необходимости эволюции и экосистемой используемых технологий. Индустрия последовательно движется от тесно связанных, платформозависимых механизмов к открытым, контрактно-ориентированным форматам, обеспечивающим долговременную совместимость и независимость от языков реализации.


# Форматы сериализации
## json
Самый распространенный тип. Поддерживается почти всеми языками. Дефакто минимальный стандарт. В сжатом виде хорош для машинной коммуникации. Основа http.
### pro
- универсален
- стандартная библиотека
- допускает 2 вида сжатия:
	- condensed - строковое представление записывается в относительно компактную строку, но трудно читаем человеком.
	- indented - каждый параметр начинается с новой строки (читать намного удобнее, но занимает больше места).

### con
- не поддерживает коментарии
- проблема запятой в последнем поле (при редактировании руками, нужно следить чтобы её не было)

## toml
Удобный для чтения. но весьма громоздкий формат. Идеально подходит для файлов конфигурации
### pro
- удобен для чтения (особенно вложенных структур)
- поддерживает комментарии
### con
- очень громоздкий
- требует сторонних библиотек

## yaml
Удобный для чтения.Подходит для файлов конфигурации, но есть недостатки.
### pro
- удобен для чтения (особенно вложенных структур)
- поддерживает комментарии
### con
- требует сторонних библиотек
- Очень большая требовательность к синтаксису (проблема пробелов)

## gob
Очень компактный (файл занимает меньше места чем json)
### pro
- нативный для golang (быстро работает)
- занимает неприлично мало места
### con
- не читаем человеком, без десериализации

