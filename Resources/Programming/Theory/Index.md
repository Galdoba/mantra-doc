---
updated_at: 2026-02-16T13:43:40.937+10:00
---
**Индекс** ({{Index|index}}) — это структура данных, создаваемая поверх хранимых записей таблицы, коллекции или документа с целью ускорения операций поиска, фильтрации, сортировки и группировки. Индекс хранит копию выбранных [[Field|полей]] и упорядоченные ссылки на соответствующие записи, обеспечивая логарифмическую или суб-линейную сложность доступа взамен полного сканирования всего набора данных. **Индексирование** (indexing) — процесс создания и поддержки индексов.

### Назначение
Применение индексов является основным методом достижения приемлемой производительности в системах работы с данными:

*   **Ускорение операций чтения (запросов)**. Индекс позволяет немедленно определить местоположение записей, удовлетворяющих условию, без последовательного просмотра всей таблицы.
*   **Обеспечение уникальности (ограничения уникальности)**. Индекс, объявленный как уникальный, гарантирует отсутствие дублирующихся значений в индексируемых полях.
*   **Эффективная сортировка (ORDER BY)**. Поскольку индекс уже упорядочен, данные могут быть извлечены в отсортированном порядке без отдельной операции сортировки.
*   **Быстрое объединение таблиц (JOIN)**. Индексы на ключах связи многократно ускоряют операции соединения.
*   **Агрегация и группировка**. Индексы могут использоваться для быстрого выполнения операций `GROUP BY` и агрегатных функций.

### Ограничения
Использование индексов сопряжено с неизбежными компромиссами:

1.  **Дополнительное дисковое пространство**. Индекс является самостоятельной структурой данных, требующей значительного объёма памяти или диска, иногда превышающего объём самих данных.
2.  **Замедление операций записи (INSERT, [[Update|UPDATE]], [[Delete|DELETE]])**. При каждой модификации данных все связанные индексы должны быть обновлены, что увеличивает время выполнения транзакций.
3.  **Сложность выбора**. Создание индекса, не используемого запросами, приносит только накладные расходы без какой-либо выгоды. Определение оптимального набора индексов требует анализа реальной нагрузки.
4.  **Деградация при фрагментации (фрагментация)**. При частых изменениях структура индекса может фрагментироваться, снижая эффективность поиска; требуется периодическое обслуживание (реиндексация, дефрагментация).
5.  **Неэффективность для некоторых типов запросов**. Индекс бесполезен для условий с отрицанием (`!=`, `NOT IN`), вычисляемыми выражениями или функциями над индексированным полем.
6.  **Ограниченная поддержка в NoSQL**. Некоторые распределённые хранилища имеют ограниченные возможности индексирования из-за модели распределения данных.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и эксплуатации индексов:

1.  **Выбор структуры индекса под нагрузку**:
    *   **B-дерево (B-Tree)** — универсальный сбалансированный индекс для точного поиска, диапазонных запросов и сортировки. Стандарт в реляционных СУБД.
    *   **Хеш-индекс** — оптимален для поиска по точному равенству; не поддерживает диапазоны и сортировку.
    *   **Битмап-индекс** — эффективен для полей с небольшим количеством различных значений (низкая кардинальность) в аналитических системах.
    *   **GIN (Generalized Inverted Index)**, **GiST** — для полнотекстового поиска и индексации составных типов (JSON, массивы).
    *   **Пространственный индекс (R-дерево)** — для геоданных.

2.  **Составные индексы (composite index)**. Индекс на нескольких полях эффективен, когда запрос использует условия на все или префикс этих полей. Порядок полей в индексе критичен: наиболее селективные (с наибольшей избирательностью) помещаются первыми.

3.  **Покрывающие индексы (covering index)**. Индекс включает все поля, необходимые для выполнения запроса, позволяя получить данные непосредственно из структуры индекса без обращения к основной таблице. Максимально ускоряет чтение, но увеличивает объём индекса.

4.  **Кластеризованные (clustered) и некластеризованные (non-clustered) индексы**. В кластеризованном индексе сами данные физически упорядочены согласно ключу индекса; такой индекс может быть только один. Некластеризованные индексы содержат только ключи и указатели на строки.

5.  **Индексы с включёнными столбцами (included columns)**. Позволяют добавить в индекс дополнительные поля, не участвующие в поиске, но доступные для извлечения, увеличивая число покрываемых запросов без расширения ключа.

6.  **Фильтрованные индексы (filtered index)**. Индекс создаётся только на подмножестве строк таблицы (например, только для активных заказов). Уменьшает размер и накладные расходы при сохранении пользы для целевых запросов.

7.  **Анализ планов запросов (query plan)**. Инструменты визуализации и анализа планов выполнения (EXPLAIN, EXPLAIN ANALYZE) позволяют определить, используется ли индекс, и выявить узкие места. Решения о создании или удалении индексов принимаются на основе фактических планов, а не предположений.

8.  **Мониторинг использования индексов**. Системные представления и журналы фиксируют частоту обращений к каждому индексу. Неиспользуемые индексы удаляются для устранения издержек при записи.

9.  **Индексы на выражения (expression index)**. Индекс строится на результате вычисления выражения или функции от полей таблицы, позволяя ускорить запросы с такими вычислениями в условии.

10. **Регулярное обслуживание**. В условиях интенсивных модификаций данных выполняется дефрагментация индексов (REINDEX, REORGANIZE) и обновление статистики для оптимизатора запросов.

11. **Индексирование в NoSQL и поисковых движках**. В документо-ориентированных базах (MongoDB) и поисковых системах (Elasticsearch) применяются инвертированные индексы (inverted index) и специальные структуры для полнотекстового поиска и геозапросов.

12. **Инструменты рекомендаций (Index Tuning Advisor)**. Системы управления базами данных и внешние утилиты анализируют рабочую нагрузку и предлагают оптимальный набор индексов для конкретного сценария.

Таким образом, индекс является критически важным, но затратным механизмом оптимизации доступа к данным. Эффективное индексирование требует глубокого понимания модели данных, профиля запросов и компромиссов между скоростью чтения и записи. Дисциплинированное применение описанных практик позволяет поддерживать высокую производительность систем при росте объёмов данных и сложности запросов.