---
updated_at: 2026-02-12T16:18:28.968+10:00
---
## Объект передачи данных: контейнер для перемещения между слоями

**Объект передачи данных** ({{Data Transfer Object|DTO}}) — это объект, предназначенный исключительно для переноса агрегированных данных между подсистемами, процессами или сетевыми границами. DTO не содержит бизнес-логики, методов валидации или поведения; его единственная ответственность — хранение и передача [[Field|полей]] в структурированном виде. DTO сериализуется ([[Serialization|serialization]]) для отправки по сети или сохранения и десериализуется на стороне получателя.

### Назначение
Применение DTO решает комплекс задач, возникающих при проектировании распределённых и многослойных систем:

*   **Снижение сетевого трафика**. DTO агрегирует данные из нескольких вызовов или источников в одну передаваемую структуру, уменьшая количество сетевых запросов.
*   **Инкапсуляция и защита [[Domain Model|модели предметной области]]**. DTO скрывает внутреннюю структуру и поведение доменных объектов, предотвращая нежелательное связывание клиента с деталями реализации и случайную утечку чувствительных полей.
*   **Разделение ответственности**. Слой представления или клиент работает с плоскими, оптимизированными структурами, не зависящими от сложной объектной модели ядра.
*   **Версионирование API**. DTO служат стабильным контрактом между сервером и клиентом; изменения во внутренней модели не влияют на клиента, если DTO остаётся совместимым.
*   **Трансформация данных**. DTO позволяют переформатировать, комбинировать или исключать поля в соответствии с потребностями конкретного клиента или сценария использования.

### Ограничения
Несмотря на широкую распространённость, DTO вносят ряд объективных сложностей:

1.  **Дублирование структур**. DTO часто являются почти точными копиями доменных сущностей, что приводит к дублированию кода и потенциальной рассинхронизации при изменениях.
2.  **Накладные расходы на маппинг ([[Mapping|mapping]])**. Преобразование между доменными объектами и DTO требует либо ручного написания кода, либо использования библиотек маппинга, что добавляет вычислительные и когнитивные издержки.
3.  **Анемичность ([[Anemic Domain Model|anemic]])**. DTO по определению лишены поведения; смешение DTO с доменной логикой нарушает архитектурные границы и ведёт к анемичной модели.
4.  **Разрастание количества классов**. Каждый вариант представления данных требует отдельного DTO, что в больших проектах приводит к множеству однотипных, слабо различающихся классов.
5.  **Проблемы версионирования**. Эволюция DTO требует поддержки обратной совместимости; удаление или переименование полей может сломать клиентов.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и использованию DTO:

1.  **DTO на архитектурных границах ([[Boundary|boundary]])**. DTO применяются исключительно в точках взаимодействия с внешним миром: контроллеры REST, слушатели сообщений, клиенты внешних API. Внутри ядра приложения используются только доменные объекты.

2.  **Плоская структура ([[Flattening|flattening]])**. DTO обычно проектируются плоскими, без глубокой вложенности, чтобы упростить сериализацию и потребление клиентами. Сложные графы объектов сворачиваются в набор скалярных полей.

3.  **Использование библиотек маппинга**. Для автоматизации преобразования между доменными объектами и DTO применяются специализированные инструменты: **[[MapStruct|MapStruct]]** (Java), **[[AutoMapper|AutoMapper]]** (.NET), **[[ObjectMapper|Jackson ObjectMapper]]** (Java), **[[Serde|serde]]** (Rust). Это сокращает объём шаблонного кода и снижает риск ошибок.

4.  **Явное определение DTO для каждого сценария**. Вместо универсальных «объектов-вездеходов» создаются узкоспециализированные DTO, содержащие только те поля, которые требуются конкретному клиенту или use case'у. Это улучшает производительность и документацию.

5.  **[[Immutability|Неизменяемость (immutability)]]**. DTO рекомендуется проектировать как неизменяемые объекты: все поля устанавливаются в конструкторе и не имеют сеттеров. Это гарантирует целостность данных при передаче и упрощает отладку.

6.  **[[Record|Records]] / [[Data Class|data classes]]**. Современные языки предоставляют лаконичный синтаксис для объявления неизменяемых DTO: `record` в Java, `data class` в Kotlin, `record struct` в C#, `dataclass` в Python. Их применение предпочтительнее ручного написания классов.

7.  **Валидация на уровне DTO ([[Validation|validation]])**. Правила проверки корректности входных данных (формат email, диапазон числа) размещаются на DTO с помощью декларативных аннотаций (Bean Validation, DataAnnotations). Это централизует проверку на границе и не загрязняет доменную модель.

8.  **DTO как контракт API**. DTO документируются в [[OpenAPI|OpenAPI]] / [[Swagger|Swagger]], их схемы версионируются. Изменения DTO проходят ревью как изменения публичного контракта.

9.  **Разделение запросов и ответов**. Для операций ввода и вывода часто используются разные DTO, даже если их поля почти идентичны. Это позволяет независимо эволюционировать запросам и ответам.

10. **Избегание бизнес-логики в DTO**. DTO не должны содержать методов, реализующих вычисления, проверки или преобразования. Все поведение остаётся в доменном слое или сервисах приложения.

11. **Тестирование маппинга**. Автоматические тесты проверяют, что маппинг между доменными объектами и DTO работает корректно и не теряет данные. Это особенно важно при использовании reflection-библиотек.

12. **Агрегирующие DTO**. Для сложных экранов или отчётов создаются DTO, объединяющие данные из нескольких агрегатов или источников. Такие DTO формируются на уровне приложения (application layer) и не предполагают обратного маппинга.

Таким образом, DTO является необходимым техническим компромиссом в распределённых и многослойных системах. Их систематическое применение дисциплинирует архитектурные границы, защищает доменную модель от внешней связанности и обеспечивает стабильные, документированные контракты взаимодействия. Цена дублирования и маппинга окупается гибкостью эволюции и возможностью независимо оптимизировать внутреннее представление и внешние интерфейсы.