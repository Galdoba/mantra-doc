---
updated_at: 2026-02-16T13:04:16.516+10:00
---
## Согласованность в конечном счёте: компромисс ради доступности

**Согласованность в конечном счёте** ({{Eventual Consistency|eventual consistency}}) — это модель согласованности, используемая в распределённых системах, которая гарантирует, что при отсутствии новых изменений все обращения к данным в конечном итоге вернут одинаковое (самое последнее) значение. В отличие от строгой согласованности ({{Strong Consistency|strong consistency}}), где все копии данных обновляются синхронно и всегда отражают одно и то же состояние, согласованность в конечном счёте допускает временное расхождение между репликами, но гарантирует, что через некоторое время они придут к единому состоянию.

Эта модель является следствием теоремы [[CAP Theorem|CAP]], согласно которой в распределённой системе можно одновременно обеспечить только два из трёх свойств: согласованность (Consistency), доступность (Availability) и устойчивость к разделению (Partition tolerance). Системы, выбирающие доступность и устойчивость к разделению, жертвуют строгой согласованностью в пользу согласованности в конечном счёте.

### Назначение
Применение моделей с согласованностью в конечном счёте позволяет достичь свойств, критически важных для современных распределённых систем:

*   **Высокая доступность (high availability)**. Система продолжает принимать запросы на запись и чтение даже при отказе части узлов или сетевых разделениях.
*   **Горизонтальное масштабирование ([[Horizontal Scaling|horizontal scaling]])**. Данные могут свободно реплицироваться и партиционироваться, а узлы могут добавляться без необходимости синхронной координации.
*   **Низкая задержка**. Операции записи могут выполняться локально на ближайшем узле без ожидания подтверждения от всех реплик, что существенно снижает время отклика.
*   **Устойчивость к сетевым разделениям**. При временной потере связи между центрами обработки данных каждый сегмент продолжает функционировать независимо, а конфликты разрешаются после восстановления соединения.
*   **Поддержка географически распределённых развёртываний**. Пользователи в разных регионах могут работать с ближайшими копиями данных без синхронного ожидания удалённых подтверждений.

### Ограничения
Применение согласованности в конечном счёте вносит существенные сложности в разработку и эксплуатацию систем:

1.  **Временные аномалии чтения**. Клиент может прочитать устаревшие данные сразу после записи, если запрос попал на ещё не обновлённую реплику. Это требует от приложения способности работать с неактуальной информацией или реализовывать механизмы чтения собственных записей.
2.  **Конфликты при параллельных обновлениях**. Если два узла одновременно получают запросы на изменение одного и того же элемента данных, возникают конфликты, требующие разрешения — часто с потерей одного из изменений или применением сложных стратегий слияния ({{Conflict Resolution|resolution}}).
3.  **Сложность бизнес-логики**. Многие бизнес-правила (например, уникальность значения, соблюдение баланса) предполагают строгую согласованность и с трудом реализуются в модели конечной согласованности.
4.  **Необходимость механизмов компенсации**. В случае конфликтов или временных расхождений система должна уметь обнаруживать и исправлять ошибки, что часто требует реализации компенсирующих транзакций или фоновых процессов сверки.
5.  **Психологическая нагрузка на разработчиков**. Модель конечной согласованности противоречит интуитивному представлению о корректной работе базы данных и требует постоянного учёта возможных временных аномалий на всех уровнях приложения.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию систем, использующих согласованность в конечном счёте:

1.  **[[BASE|BASE]] вместо ACID**. Транзакционная модель ACID заменяется подходом BASE: **B**asically **A**vailable (базовая доступность), **S**oft state (мягкое состояние, которое может меняться), **E**ventual consistency (согласованность в конечном счёте). Это философский фундамент для проектирования.

2.  **Восстановление при чтении (read repair)**. При обнаружении расхождений во время операции чтения система автоматически обновляет устаревшие реплики актуальными данными, постепенно улучшая согласованность.

3.  **Передача с подсказкой (hinted handoff)**. Если один узел временно недоступен, другой узел принимает запись на себя и сохраняет "подсказку" о том, какому узлу она предназначалась. При восстановлении недоступного узла данные передаются ему.

4.  **Векторные часы (vector clocks)**. Механизм отслеживания причинно-следственных связей между событиями в распределённой системе. Позволяет определять, какое из конфликтующих изменений произошло позже, и автоматически разрешать конфликты или передавать их на уровень приложения.

5.  **Кворум**. Настройка количества узлов, которые должны подтвердить операцию чтения или записи. Например, запись считается успешной, если её подтвердили N узлов из общего числа. Кворумы позволяют настраивать баланс между согласованностью и доступностью.

6.  **Идемпотентность ([[Idempotency|idempotency]])**. Критически важное свойство операций в условиях возможных повторных доставок и временных расхождений. Повторное применение одной и той же операции не должно изменять состояние системы.

7.  **Сага ([[Saga|saga]])**. Паттерн для управления распределёнными транзакциями, разбивающий длительную операцию на последовательность локальных транзакций с компенсирующими действиями. Саги естественным образом работают в модели конечной согласованности.

8.  **CRDT (конфликтно-свободные типы данных)**. Структуры данных, специально спроектированные для работы в условиях конечной согласованности. Они математически гарантируют, что параллельные обновления на разных узлах всегда могут быть корректно объединены без потери информации.

9.  **[[CQRS|Разделение команд и запросов (CQRS)]]**. Архитектурный стиль, разделяющий модели записи и чтения. Модель записи может быть строго согласованной, а модель чтения обновляется асинхронно, достигая конечной согласованности. Это сочетает преимущества обоих подходов.

10. **[[Versioning|Версионирование]] и [[Optimistic Locking|оптимистическая блокировка]]**. Каждая запись снабжается версией, которая проверяется при обновлении. Это позволяет обнаруживать конфликты даже в отсутствие строгой синхронизации.

11. **Соглашение об уровне обслуживания**. В контрактах с клиентами явно оговаривается окно конечной согласованности — максимальное время, в течение которого данные могут оставаться несогласованными (например, "все реплики будут согласованы в течение 5 секунд").

12. **Тестирование в условиях сетевых разделений**. Использование техник [[Chaos Engineering|хаос-инжиниринга]] для намеренного внесения задержек и отказов с целью проверки корректности работы системы в условиях конечной согласованности.

Таким образом, согласованность в конечном счёте является не недостатком, а осознанным архитектурным выбором, позволяющим строить глобально распределённые, высокодоступные и масштабируемые системы. Её успешное применение требует глубокого понимания компромиссов, дисциплины в проектировании операций и использования специализированных механизмов обнаружения и разрешения конфликтов. Для многих классов приложений (социальные сети, корзины покупок, ленты новостей) эта модель не только приемлема, но и предпочтительна, так как обеспечивает пользовательский опыт, недостижимый при строгой синхронизации.