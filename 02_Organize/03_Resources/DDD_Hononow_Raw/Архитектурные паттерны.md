---
updated_at: 2025-12-12T14:10:25.404+10:00
tags:
  - part2
  - chapter8
---
## Сопоставление бизнес-логики и архитектурных паттернов

В ранее рассмотренных в этой книге тактических паттернах определялись различные способы моделирования и реализации бизнес-логики. В этой главе тактический дизайн будет рассмотрен в более широком контексте, включающем различные способы координации взаимодействий и зависимостей между компонентами системы.

Бизнес-логика — наиболее важная, но далеко не единственная часть программной системы. Чтобы реализовать функциональные и нефункциональные требования, на кодовую базу возлагается более широкий круг обязанностей. Это и взаимодействие с пользователями с целью получения входных данных, и предоставление выходных данных, а также использование различных механизмов хранения для фиксации состояния и интеграции с внешними системами и поставщиками информации.

Разнообразие задач, решение которых возлагается на кодовую базу, облегчает распределение ее бизнес-логики между различными компонентами: часть логики должна реализовываться в пользовательском интерфейсе или базе данных или же быть продублированной в разных компонентах. Отсутствие строгой организации в вопросах реализации решаемых задач затрудняет внесение изменений в код. При неизбежных изменениях бизнес-логики порой трудно бывает сходу определить, какие именно части кодовой базы должны быть затронуты этими изменениями. То или иное изменение может иметь неожиданные последствия для, казалось бы, совершенно несвязанных с ним частей системы. И наоборот, совсем нетрудно пропустить тот код, который необходимо изменить. Все эти проблемы резко увеличивают издержки сопровождения кодовой базы.

Благодаря применению архитектурных паттернов вводятся организационные принципы для различных аспектов кодовой базы и устанавливаются четкие границы между ними, при этом формируются ответы на вопросы, как именно бизнес-логика связана с вводом, выводом и другими инфраструктурными компонентами системы. Их применение влияет на взаимодействие компонентов друг с другом, на то, какими знаниями они делятся и как компоненты ссылаются друг на друга.

Выбор подходящего способа организации кодовой базы или правильного архитектурного паттерна имеет решающее значение для поддержки реализации бизнес-логики в краткосрочной перспективе и облегчения сопровождения приложения в последующем. А теперь давайте рассмотрим три основных архитектурных паттерна приложений: слоистую архитектуру, порты и адаптеры и CQRS, а также изучим варианты их использования.

## Слоистая архитектура (Layered Architecture)

Одним из наиболее распространенных архитектурных паттернов является слоистая архитектура (layered architecture). При его использовании кодовая база выстраивается в горизонтальные слои, каждый из которых решает одну из следующих технических задач: взаимодействие с пользователями, реализация бизнес-логики и хранение данных. Эти слои показаны на рис. 8.1.

![[Рис. 8.1. Слоистая архитектура (Layered architecture).png]]

В своей классической форме слоистая архитектура состоит из трех слоев: слоя представления (presentation layer — PL), слоя бизнес-логики (business logic layer — BLL) и слоя доступа к данным (data access layer — DAL).

### Слой представления (Presentation layer)

На слое представления, показанном на рис. 8.2, реализуется пользовательский интерфейс программы для взаимодействия с ее пользователями. В исходной форме паттерна этим слоем обозначается графический интерфейс, например веб-интерфейс или интерфейс приложения для настольного компьютера.

Но в современных системах слой представления имеет более широкий охват: т. е. в него входят все средства для запуска взаимодействия программы, как синхронного, так и асинхронного. Например:
* Графический интерфейс пользователя (GUI).
* Интерфейс командной строки (CLI).
* Интерфейс для интеграции с другими системами (API).
* Подписка на события в брокере сообщений.
* Топики сообщений для публикации исходящих событий.

Все это относится к средствам для получения системой запросов из внешней среды и передачи результатов. Строго говоря, слой представления — это публичный интерфейс программы.

![[Рис. 8.2. Слой представления.png]]

### Слой бизнес-логики (Business logic layer)

Как следует из названия, этот слой отвечает за реализацию и инкапсуляцию бизнес-логики программы. Здесь реализуются бизнес-решения. Как говорит Эрик Эванс (Eric Evans), этот слой является сердцем программного средства.

На этом слое реализуются паттерны бизнес-логики, рассмотренные в главах 5–7, например активные записи или модель предметной области (см. рис. 8.3).

![[Рис. 8.3. Слой бизнес-логики.png]]
### Слой доступа к данным (Data access layer)

Слой доступа к данным обеспечивает доступ к механизмам хранения информации. В исходной форме паттерна имелась в виду база данных системы. Но по аналогии со слоем представления ответственность, возлагаемая на этот слой, в современных системах гораздо шире.

Во-первых, с тех пор, как грянула революция NoSQL, система обычно работает с несколькими базами данных. Например, документоориентированное хранилище может выступать в качестве рабочей базы данных, поисковый индекс использоваться для динамических запросов, а база данных, находящаяся в оперативной памяти, может быть использована для высокопроизводительных операций.

Во-вторых, традиционные базы данных не являются единственным средством хранения информации. Например, для хранения файлов системы может использоваться облачное объектное хранилище, или же для организации связи между различными функциями программы может использоваться шина сообщений.

И наконец, этот слой также включает интеграцию с различными внешними поставщиками информации, необходимую для решения функциональных задач программы: API-интерфейсы, предоставляемые внешними системами, или сервисы облачных провайдеров, такие как перевод на другие языки, данные фондового рынка и распознавание аудио (рис. 8.4).

![[Рис. 8.4. Слой доступа к данным.png]]

### Связь между слоями

Слои интегрированы в коммуникационную модель типа «сверху вниз»: как показано на рис. 8.5, каждый слой может иметь зависимость только от слоя, находящегося непосредственно под ним. Тем самым обеспечивается разделение задач реализации и уменьшение обмена знаниями между слоями. На рис. 8.5 слой представления ссылается только на слой бизнес-логики. Он абсолютно не в курсе дизайна слоя доступа к данным.

![[Рис. 8.5. Слоистая архитектура.png]]

## Вариация

Обычно паттерн слоистой архитектуры расширяется дополнительным, сервисным слоем (Service layer).

> Определяет границу приложения посредством слоя сервисов, который устанавливает набор доступных действий, и координирует реакцию приложения на каждое действие.
> *– Паттерны архитектуры корпоративных приложений*

Сервисный слой действует как посредник между имеющимися у программы слоями представления и бизнес-логики. Рассмотрим следующий код:

```csharp
namespace MvcApplication.Controllers
{
    public class UserController: Controller
    {
        ...
        [AcceptVerbs(HttpVerbs.Post)]
        public ActionResult Create(ContactDetails contactDetails)
        {
            OperationResult result = null;
            try
            {
                _db.StartTransaction();
                var user = new User();
                user.SetContactDetails(contactDetails)
                user.Save();
                _db.Commit();
                result = OperationResult.Success;
            } catch (Exception ex) {
                _db.Rollback();
                result = OperationResult.Exception(ex);
            }
            return View(result);
        }
    }
}
```

Показанный в этом примере MVC-контроллер относится к слою представления. Он предоставляет интерфейс, который создает нового пользователя. Для создания нового экземпляра и его сохранения в этом эндпоинте используется объект активной записи User. Более того, им управляется транзакция базы данных, чтобы в случае возникновения ошибки был сгенерирован правильный ответ. 

Как показано на рис. 8.6, для дальнейшего разделения слоя представления и базовой бизнес-логики логику управления транзакциями можно переместить на сервисный слой.

![[Рис. 8.6. Сервисный слой.png]]


Важно отметить, что в контексте архитектурного паттерна сервисный слой является логической границей. Его не нужно рассматривать в качестве физического сервиса.

Сервисный слой выступает в качестве фасада слоя бизнес-логики: он предоставляет интерфейс, который соответствует методам публичного интерфейса, инкапсулируя вызовы нижележащих слоев. Например:

```csharp
interface CampaignManagementService
{
    OperationResult CreateCampaign(CampaignDetails details);
    OperationResult Publish(CampaignId id, PublishingSchedule schedule);
    OperationResult Deactivate(CampaignId id);
    OperationResult AddDisplayLocation(CampaignId id, DisplayLocation newLocation);
    ...
}
```

Все показанные выше методы соответствуют публичному интерфейсу системы. Но им не хватает деталей реализации, связанных с представлением. Ответственность слоя представления ограничивается предоставлением необходимых входных данных сервисному слою и возвращением его ответов вызывающей стороне.

Давайте отрефакторим предыдущий пример и вынесем логику оркестрации на сервисный слой:

```csharp
namespace ServiceLayer
{
    public class UserService
    {
        ...
        public OperationResult Create(ContactDetails contactDetails)
        {
            OperationResult result = null;
            try
            {
                _db.StartTransaction();
                var user = new User();
                user.SetContactDetails(contactDetails)
                user.Save();
                _db.Commit();
                result = OperationResult.Success;
            } catch (Exception ex) {
                _db.Rollback();
                result = OperationResult.Exception(ex);
            }
            return result;
        }
        ...
    }
}

namespace MvcApplication.Controllers
{
    public class UserController: Controller
    {
        ...
        [AcceptVerbs(HttpVerbs.Post)]
        public ActionResult Create(ContactDetails contactDetails)
        {
            var result = _userService.Create(contactDetails);
            return View(result);
        }
    }
}
```

### Преимущества сервисного слоя

Наличие явного сервисного слоя дает целый ряд преимуществ:
* Один и тот же сервисный слой может повторно использоваться сразу несколькими публичными интерфейсами, например графическим пользовательским интерфейсом и API. Дублирование логики оркестрации не требуется.
* Повышается модульность кода, все связанные методы собираются в одном месте.
* Происходит дополнительное разделение слоев представления и бизнес-логики.
* Упрощается тестирование функциональности бизнес-логики.

### Когда нужен сервисный слой?

Но стоит все же отметить, что необходимость в сервисном слое возникает не всегда. Например, когда бизнес-логика реализована в виде транзакционного сценария, то она, по сути, и представляет собой сервисный слой, поскольку уже предоставляет набор методов, формирующих публичный интерфейс системы. В таком случае API сервисного слоя будет просто повторять публичные интерфейсы транзакционных сценариев без абстрагирования и инкапсуляции какой-либо сложности. Следовательно, будет вполне достаточно либо сервисного слоя, либо слоя бизнес-логики.

С другой стороны, потребности в сервисном слое будут возникать, если паттерну бизнес-логики станет необходим внешний оркестратор, как в случае с паттерном активной записи. Тогда на сервисном слое будет реализован паттерн транзакционного сценария, а активные записи, с которыми он работает, будут находиться на слое бизнес-логики.

## Терминология

В иных источниках информации могут встречаться и другие термины, используемые для описания слоистой архитектуры:
* Слой представления = слой пользовательского интерфейса.
* Сервисный слой = прикладной слой.
* Слой бизнес-логики = слой предметной области = слой модели.
* Слой доступа к данным = слой инфраструктуры.

Чтобы избежать путаницы, паттерн здесь представляется с использованием исходной терминологии. И все же я склоняюсь к таким понятиям, как «слой пользовательского интерфейса» и «уровень инфраструктуры», поскольку эти термины лучше отражают обязанности современных систем и слоя приложений, не допуская путаницы с физическими границами сервисов.

## Когда предпочтительнее использовать слоистую архитектуру

Благодаря имеющейся в этом архитектурном паттерне зависимости между слоями бизнес-логики и доступа к данным он хорошо подходит для систем, бизнес-логика которых реализована с использованием транзакционного сценария или паттерна активной записи.

Но паттерн затрудняет реализацию модели предметной области, где бизнес-сущности (агрегаты и объекты-значения) не должны иметь никакой зависимости от базовой инфраструктуры и никаких знаний о ней. В слоистой архитектуре с ее зависимостью сверху вниз для выполнения этого требования нужно будет перепрыгивать через слои. Реализовать модель предметной области в слоистой архитектуре все же можно, но паттерн, рассматриваемый далее, подходит для этого гораздо лучше.

## Дополнительно: сравнение слоев и уровней

Слоистую архитектуру часто путают с архитектурой N-Tier (многоуровневой) и наоборот. Несмотря на сходство между двумя паттернами, слои и уровни (tiers) концептуально различаются: слой — это логическая граница, а уровень — физическая граница. Все слои в слоистой архитектуре связаны одним и тем же жизненным циклом: они реализуются, развиваются и развертываются как единое целое. А уровень — это независимо развертываемый сервис, сервер или система. Рассмотрим, к примеру, систему с архитектурой N-Tier, показанную на рис. 8.7.

![[Рис. 8.7. Система с архитектурой N-Tier.png]]

Система отображает интеграцию физических сервисов, задействованных в системе. Потребитель использует браузер, который может работать на настольном компьютере или мобильном устройстве. Браузер взаимодействует с обратным прокси-сервером, который перенаправляет запросы в веб-приложение. Веб-приложение работает на веб-сервере и взаимодействует с сервером базы данных. Все эти компоненты могут работать на одном физическом сервере, представляющем собой составное устройство, или быть распределены между несколькими серверами. Но, поскольку каждый компонент может развертываться и управляться независимо от остальных, это уровни, а не слои.

А вот слои внутри веб-приложения являются логическими границами.

## Порты и адаптеры (Ports and adapters)

Архитектура портов и адаптеров устраняет недостатки слоистой архитектуры и больше подходит для реализации более сложной бизнес-логики. Интересно то, что оба паттерна очень похожи. Давайте отрефакторим слоистую архитектуру в порты и адаптеры.

### Терминология

По сути, и слой представления, и слой доступа к данным представляют собой интеграцию с внешними компонентами: базами данных, внешними сервисами и фреймворками пользовательского интерфейса. Эти технические подробности не отражают бизнес-логику системы, поэтому давайте, как показано на рис. 8.8, объединим все подобные инфраструктурные задачи в один «слой инфраструктуры».

![[Рис. 8.8. Слои представления и доступа к данным объединены в слой инфраструктуры.png]]

# Принцип инверсии зависимостей (Dependency inversion principle)

Принцип инверсии зависимостей (dependency inversion principle — DIP) гласит, что высокоуровневые модули, реализующие бизнес-логику, не должны зависеть от низкоуровневых модулей. Но в традиционной слоистой архитектуре именно это и происходит. Слой бизнес-логики зависит от слоя инфраструктуры. Чтобы соответствовать DIP-принципу, давайте, как показано на рис. 8.9, развернем отношения в обратную сторону.

![[Рис. 8.9. Зависимости, развернутые в обратную сторону.png]]

Теперь слой бизнес-логики расположен не между технологическими слоями, а занимает центральную позицию. Он не зависит ни от одного из инфраструктурных компонентов системы.

И наконец, в качестве фасада для публичного интерфейса системы давайте добавим прикладной слой. Являясь в слоистой архитектуре сервисным слоем, он описывает все операции, предоставляемые системой, и управляет бизнес-логикой системы для их выполнения. Получающаяся в результате этого архитектура изображена на рис. 8.10.

Архитектура, изображенная на рис. 8.10, представляет собой архитектурный паттерн портов и адаптеров (ports and adapters). Бизнес-логика не зависит ни от одного из нижестоящих слоев, это нужно для реализации паттернов модели предметной области и модели предметной области, основанной на событиях (event sourced domain model).

![[Рис. 8.10. Традиционные слои архитектуры портов и адаптеров.png]]

Почему этот паттерн называется порты и адаптеры? Чтобы ответить на этот вопрос, давайте посмотрим, как инфраструктурные компоненты интегрированы с бизнес-логикой.

### Интеграция инфраструктурных компонентов

Основная цель архитектуры портов и адаптеров — отделить бизнес-логику системы от ее инфраструктурных компонентов.

Вместо того, чтобы ссылаться на инфраструктурные компоненты или вызывать их напрямую, слой бизнес-логики определяет «порты», которые должны быть реализованы на слое инфраструктуры. А на слое инфраструктуры реализуются «адаптеры»: конкретные реализации интерфейсов портов для работы с различными технологиями (см. рис. 8.11).

![[Рис. 8.11. Архитектура портов и адаптеров.png]]

Абстрактные порты становятся конкретными адаптерами на слое инфраструктуры либо путем внедрения зависимостей, либо путем настройки при начальной загрузке.

Например, вот так выглядит возможное определение порта и конкретный адаптер для шины сообщений:

```csharp
namespace App.BusinessLogicLayer 
{ 
    public interface IMessaging 
    { 
        void Publish(Message payload); 
        void Subscribe(Message type, Action callback); 
    } 
}
```

```csharp
namespace App.Infrastructure.Adapters 
{ 
    public class SQSBus: IMessaging { ... } 
}
```

### Варианты

Архитектура портов и адаптеров также известна как гексагональная архитектура, луковичная архитектура и чистая архитектура. Все эти паттерны основаны на одних и тех же принципах проектирования, имеют одни и те же компоненты и характеризуются одинаковыми отношениями между ними, но, как и в случае со слоистой архитектурой, терминология может различаться:
- Прикладной слой = сервисный слой = слой пользовательского сценария.
- Слой бизнес-логики = слой предметной области = слой ядра.

И все же эти паттерны можно ошибочно считать концептуально разными. Это еще один пример важности единого языка.

## Когда предпочтительнее использовать порты и адаптеры

Отделение бизнес-логики от всех технологических вопросов делает архитектуру портов и адаптеров идеально подходящей для бизнес-логики, реализованной с помощью паттерна модели предметной области.

## Разделение ответственности команд и запросов (Command-Query Responsibility Segregation)

Паттерн разделения ответственности команд и запросов (command-query responsibility segregation — CQRS) основан на тех же принципах организации бизнес-логики и инфраструктуры, что и паттерн портов и адаптеров. Но он отличается способом управления данными системы. Этот паттерн позволяет представлять данные системы в нескольких персистентных моделях.

Давайте посмотрим, зачем может понадобиться такое решение и как его реализовать.

Мультипарадигменное моделирование (Polyglot modelling) 
Использование единственной модели для всех нужд системы может быть затруднительно, а то и вовсе не возможно. Например, как уже упоминалось в главе 7, обработка транзакций (online transaction processing — OLTP) и аналитическая обработка (online analytical processing — OLAP) могут потребовать разные представления данных. 

Еще одна причина для работы с несколькими моделями может быть связана с понятием мультипарадигменного хранения данных (polyglot persistence). Идеальной базы данных не существует. Или, как говорит Грег Янг (Greg Young)6 , у всех баз данных имеются недостатки, и у каждой свои: зачастую приходится балансировать между потребностями в масштабировании, согласованностью данных или поддерживаемых видов запросов. Альтернативой поиску идеальной базы данных является мультипарадигменная модель хранения данных: использование нескольких баз данных для реализации различных требований, связанных с данными. Например, одна система может использовать в качестве рабочей базы данных документноориентированную, для аналитики или отчетности — колоночную, а для реализации надежного поиска — поисковый движок. 

И последнее, о чем нужно упомянуть, — паттерн CQRS тесно связан с источником событий (event sourcing). Первоначально CQRS был определен для преодоления ограничений в выполнении запросов при использовании модели, основанной на событиях (event sourced domain model): за один раз можно было запрашивать события только одного экземпляра агрегата. Паттерн CQRS предоставляет возможность материализации моделей, спроецированных в физические базы данных, подходящих для гибких (flexible) запросов. 

С учетом вышесказанного в этой главе CQRS «отделяется» от источника событий (event sourcing). Я хочу показать, что CQRS применим даже в том случае, если бизнес-логика реализована с использованием любого другого паттерна. 

Давайте посмотрим, как CQRS позволяет использовать сразу несколько механизмов хранения для представления различных моделей данных разрабатываемой системы. 

Реализация 
Как следует из названия, паттерн разделяет обязанности моделей системы. Существуют два типа моделей: модель выполнения команд и модели чтения.


# Модель выполнения команд

CQRS выделяет единую модель для выполнения операций, которые изменяют состояние системы (системные команды). Эта модель используется для реализации бизнес-логики, проверки соблюдения правил и соблюдения инвариантов. Модель выполнения команд также является единственной моделью, представляющей строго непротиворечивые данные — источником истины (source of truth). Должна быть предоставлена возможность считывания строго согласованного состояния бизнес-объекта и поддержка оптимистичного управления конкурентным доступом для обновления этих объектов.

# Модели чтения (проекции)

Система может определить столько моделей, сколько нужно для предоставления данных пользователям или информации другим системам. Модель чтения — это предварительно кешированная проекция. Она может находиться в базе данных, в обычном файле или в кеше в памяти. Правильная реализация CQRS позволяет стереть все данные проекции и восстановить ее с нуля. Она также позволяет расширить систему дополнительными проекциями в будущем — моделями, которые нельзя было предусмотреть изначально. И наконец, модели чтения доступны только для чтения. Ни одна из системных операций не может напрямую изменять данные моделей чтения.

# Проецирование моделей чтения

Чтобы модели чтения заработали, система должна проецировать изменения из модели выполнения команд на все свои модели чтения. Эта концепция проиллюстрирована на рис. 8.12. Проекция моделей чтения аналогична понятию материализованного представления (materialized view) в реляционных базах данных: при каждом обновлении исходной таблицы изменения должны отражаться в предварительно кешированных представлениях. А теперь давайте рассмотрим два способа создания проекций: синхронный и асинхронный.

![[Рис. 8.12. CQRS-архитектура.png]]

## Синхронные проекции

При синхронном обновлении проекций обновление данных происходит по модели догоняющей подписки (catch-up subscription):
* Механизм проецирования запрашивает в OLTP-базе новые или обновленные записи после последнего контрольной точки (checkpoint).
* Механизм проецирования использует обновленные данные для создания или обновления моделей чтения.
* Механизм проецирования сохраняет контрольную точку последней обработанной записи. Это значение будет использоваться во время следующей итерации для добавления или изменения записей после последней обработанной записи.

Этот процесс показан на рис. 8.13 и отображен на рис. 8.14 в виде диаграммы последовательности.

![[Рис. 8.13. Синхронная проекционная модель.png]]

![[Рис. 8.14. Синхронная проекция моделей чтения посредством догоняющей подписки.png]]

Чтобы догоняющая подписка работала, модель выполнения команд должна ставить контрольную точку (checkpoint) на все новые или обновленные записи базы данных. Механизм хранения также должен поддерживать запрос записей на основе контрольных точек. 
Контрольная точка может быть реализована с использованием возможностей баз данных. Например, как показано на рис. 8.15, для генерации уникальных инкрементальных чисел при вставке или обновлении строки в SQL Server может использоваться столбец «rowversion». В базах данных, в которых такая возможность отсутствует, можно реализовать специальное решение, которое увеличивает текущий счетчик и добавляет его к каждой измененной записи. Важно убедиться, что запрос на основе контрольной точки возвращает согласованные результаты. Если последняя возвращенная запись имеет значение контрольной точки 10, при следующем выполнении ни один новый запрос не должен иметь значения меньше 10. В противном случае эти записи будут пропущены механизмом проецирования, что приведет к несогласованности моделей.

![[Рис. 8.15. Автоматически сгенерированный столбец контрольной точки (checkpoint) в реляционной базе данных.png]]

Метод синхронного проецирования упрощает добавление новых проекций и регенерацию существующих с самого начала. В последнем случае нужно всего лишь сбросить контрольную точку на 0; механизм проецирования просканирует записи и выстроит проекции с нуля.

## Асинхронные проекции

В сценарии асинхронной проекции модель выполнения команд публикует все зафиксированные изменения в шину сообщений. Как показано на рис. 8.16, механизмы проецирования системы могут подписываться на опубликованные сообщения и использовать их для обновления моделей чтения.

![[Рис. 8.16. Асинхронное проецирование моделей чтения.png]]

Метод синхронного проецирования упрощает добавление новых проекций и регенерацию существующих с самого начала. В последнем случае нужно всего лишь сбросить контрольную точку на 0; механизм проецирования просканирует записи и выстроит проекции с нуля. 

### Асинхронные проекции 
В сценарии асинхронной проекции модель выполнения команд публикует все зафиксированные изменения в шину сообщений. Как показано на рис. 8.16, механизмы проецирования системы могут подписываться на опубликованные сообщения и использовать их для обновления моделей чтения.

## Сложности

Несмотря на очевидные преимущества метода асинхронного проектирования в вопросах масштабирования и производительности, он сильнее подвержен ошибкам, возникающим при конкурентном доступе. Если сообщения обрабатываются не по порядку или дублируются, в модели чтения будут проецироваться несогласованные данные.

Этот метод также усложняет добавление новых проекций или регенерацию существующих. 

Поэтому всегда рекомендуется реализовывать синхронную проекцию, а в случае необходимости надстраивать над ней дополнительную асинхронную проекцию.

## Разделение моделей

В архитектуре CQRS ответственности моделей разделены в соответствии с их типом. Команда может работать только в строго согласованной модели выполнения команд. Запрос не может напрямую изменить хранимое состояние системы — ни модели чтения, ни модель выполнения команд.

В отношении систем на основе CQRS бытует весьма распространенное заблуждение, заключающееся в том, что команда может только изменять данные, а данные могут быть извлечены для отображения только через модель чтения. Иными словами, команда, приводящая к выполнению методов, никогда не должна возвращать никаких данных. Это не так. Такой подход создает ненужные сложности и портит впечатление пользователей о системе.

Команда всегда должна сообщать вызывающей стороне об успешном или неудачном результате ее выполнения. Если выполнение не удалось, то по какой причине? Входные данные не прошли валидацию или же возникла техническая проблема? Вызывавший команду компонент программы должен знать, как внести в команду исправления. Следовательно, команда может и во многих случаях должна возвращать данные, к примеру, если пользовательский интерфейс системы должен отражать изменения, полученные в результате выполнения команды. При этом не только облегчается работа пользователей с системой, поскольку они немедленно получают отклик на свои действия, но и предоставляется возможность воспользоваться возвращаемыми значениями в дальнейшем в рабочих процессах пользователей, что устраняет необходимость в ненужных обменах данными.

Единственное ограничение заключается в том, что возвращаемые данные должны исходить из строго согласованной модели, а именно из модели выполнения команд, поскольку мы не можем ждать, когда проекция придет в согласованное состояние.

## Когда предпочтительнее использовать CQRS

Применение паттерна CQRS может подойти тем приложениям, которым необходимо работать с одними и теми же данными сразу в нескольких моделях, потенциально хранящихся в базах данных разных типов.

С точки зрения практического применения паттерн поддерживает основную ценность предметно-ориентированного проектирования, заключающуюся в работе с наиболее эффективными моделями для решения поставленной задачи и постоянном совершенствовании модели предметной области.

С точки зрения инфраструктуры CQRS позволяет воспользоваться возможностями различных типов баз данных; например, для хранения модели выполнения команд использовать реляционные базы данных, для полнотекстового поиска использовать поисковый индекс, а для быстрого извлечения данных использовать предварительно обработанные обычные файлы, получая при этом все надежно синхронизированные механизмы хранения информации.

Кроме того, CQRS в силу своих особенностей вполне естественно подходит для моделей предметной области, основанных на событиях (`event sourced domain model`). Модель «События как источник данных» (`Event Sourcing`) делает невозможной выборку записей на основе состояний агрегатов, но CQRS открывает такую возможность, проецируя состояния в базы данных.

## Область применения

Рассматриваемые здесь паттерны — слоистая архитектура, архитектура портов и адаптеров и CQRS — не должны выступать в роли общесистемных организационных принципов. Их не следует считать обязательными высокоуровневыми архитектурными паттернами для всего ограниченного контекста.

Рассмотрим ограниченный контекст, показанный на рис. 8.17, охватывающий сразу несколько поддоменов. Поддомены могут быть разных типов: основные (`core`), вспомогательные (`supporting`) или универсальные (`generic`). Даже для поддоменов одного типа может потребоваться разная бизнес-логика и разные архитектурные паттерны (это тема главы 10). Применение единой, ограниченной контекстнозависимой архитектуры непреднамеренно приведет к неоправданной сложности.

![[Рис. 8.17. Ограниченные контексты, охватывающие сразу несколько поддоменов.png]]

Наша цель заключается в принятии проектных решений в соответствии с реальными потребностями и бизнес-стратегией. В дополнение к уровням, разделяющим систему по горизонтали, можно еще ввести дополнительное вертикальное разбиение. Крайне важно определить логические границы для модулей, инкапсулирующих отдельные поддомены бизнеса, и для каждого из них воспользоваться соответствующими инструментами (рис. 8.18). Соответствующие вертикальные границы делают монолитный ограниченный контекст модульным и не дают ему превратиться в так называемый большой ком грязи. В главе 11 будет показано, что эти логические границы позже могут быть преобразованы в физические границы более мелких ограниченных контекстов.

![[Рис. 8.18. Архитектурные срезы.png]]
## Вывод

`Слоистая архитектура` предусматривает разбивку кодовой базы на основе решаемых технологических задач. Поскольку этот паттерн объединяет бизнес-логику с реализацией доступа к данным, он хорошо подходит для систем на основе использования активных записей.

В `архитектуре портов и адаптеров` отношения инвертируются: бизнес-логика ставится в центр и отделяется от всех инфраструктурных зависимостей. Этот паттерн хорошо подходит для бизнес-логики, реализованной с помощью паттерна `модели предметной области`.

Паттерн `CQRS` представляет одни и те же данные сразу в нескольких моделях. Несмотря на то что этот паттерн является обязательным для систем, построенных на `модели предметной области`, основанной на событиях (`event-source domain model`), им также можно воспользоваться в любых системах, которым требуется способ работы сразу с несколькими моделями хранения информации.

Паттерны, которые будут рассмотрены в следующей главе, предназначены для решения архитектурных задач с упором на реализацию надежного взаимодействия между различными компонентами системы.












