---
updated_at: 2025-12-12T16:41:09.747+10:00
tags:
  - part4
  - chapter14
---
В середине 2010-х годов микросервисы стремительно захватили индустрию разработки программных средств. Замысел заключался в удовлетворении потребностей современных систем в быстром изменении, масштабировании и естественном соответствии распределенной природе облачных вычислений. Многие компании приняли стратегическое решение разложить свои монолитные кодовые базы на более гибкие составляющие, обеспечиваемые архитектурой на основе микросервисов.

К сожалению, многие подобные начинания особо ничем не закончились. Вместо гибких архитектур компании получили распределенные большие комки грязи (`big ball of mud`) — конструкции, гораздо более хрупкие, запутанные и дорогие, чем исходные монолиты.

Так уж повелось, что технология микросервисов зачастую ассоциировались с предметно-ориентированным проектированием, особенно с паттерном «Ограниченный контекст» (`Bounded Context`). Многими термины «ограниченный контекст» и «микросервисы» даже использовались как синонимы. Но можно ли их отождествлять?

В этой главе исследуется связь методологии предметно-ориентированного проектирования и архитектурного паттерна микросервисов. Будет рассмотрено взаимодействие паттернов и, что более важно, раскрыты приемы использования предметно-ориентированного проектирования в разработке эффективных систем на основе микросервисов.

Давайте начнем с основ и определим, что же такое сервисы и микросервисы.

## Что такое сервис?

Согласно `OASIS` сервис — это механизм, обеспечивающий доступ к одной или нескольким бизнес-компетенциям (`capability`), предоставляемый с использованием предписанного интерфейса (`prescribed interface`). А предписанный интерфейс (`prescribed interface`) — это любой способ передачи данных в сервис и получения данных из него. Он может быть синхронным, например моделью запрос-ответ (`request/response`), или асинхронным, например моделью, отправляющей и принимающей события. Это, как показано на рис. 14.1, публичный интерфейс сервиса, предоставляющий средства для обмена данными и интеграции с другими компонентами системы. 

![[Рис. 14.1. Обмен данными между сервисами.png]]

У Рэнди Шоупа (`Randy Shoup`) интерфейс сервиса сравнивается со входной дверью, через которую должны проходить все данные, передаваемые в сервис или запрашиваемые из него. Кроме того, публичный интерфейс сервиса определяет саму его суть, т. е. предоставляемые им функциональные возможности. Четко выраженного интерфейса вполне достаточно для описания функциональности, реализованной сервисом. Например, публичный интерфейс, показанный на рис. 14.2, явно описывает функциональные возможности сервиса. Рис. 14.2. Публичный интерфейс сервиса

Это подводит нас к определению микросервиса.

![[Рис. 14.2. Публичный интерфейс сервиса.png]]
## Что такое микросервис?

Определение микросервиса на удивление простое. Поскольку сервис определяется своим публичным интерфейсом, микросервис — это сервис с публичным микроинтерфейсом (входной микродверью).

Наличие публичного микроинтерфейса упрощает понимание как функции отдельного сервиса, так и его интеграции с другими компонентами системы. Сокращение функциональности сервиса также ограничивает круг причин для его изменений и делает сервис более автономным для разработки, управления и масштабирования.

Кроме того, это объясняет, почему в микросервисах никто, кроме самого микросервиса, не может получить прямой доступ к его базе данных... Открытый доступ к базе данных, превращение ее в парадную дверь сервиса, сделало бы ее публичный интерфейс просто огромным. Например, сколько различных `SQL`-запросов можно выполнить к реляционной базе данных? Поскольку `SQL` — достаточно гибкий язык, вероятная оценка будет близка к бесконечности. Следовательно, микросервисы инкапсулируют свои базы данных. Доступ к данным возможен только через гораздо более компактный публичный интерфейс, ориентированный на интеграцию.

### Метод как Сервис (`Method as a Service`): путь к созданию идеальных микросервисов?

Высказывание о том, что микросервис — это публичный микроинтерфейс, кажется обманчиво простым. Может показаться, что ограничение интерфейсов сервисов всего лишь одним методом приведет к созданию идеальных микросервисов. Посмотрим, что произойдет, если применить эту наивную декомпозицию на практике.

Рассмотрим сервис управления бэклогом, показанный на рис. 14.3. Его публичный интерфейс состоит из восьми публичных методов, и у нас возникло желание применить к нему правило «один метод — один сервис». 

![[Рис. 14.3. Наивная декомпозиция.png]]

Поскольку это микросервисы с правильным поведением, каждый из них инкапсулирует свою базу данных. Ни одному сервису не разрешен прямой доступ к базе данных другого сервиса, он возможен только через его публичный интерфейс. Но пока что для этого нет публичного интерфейса. Сервисы должны работать вместе и синхронизировать изменения, вносимые каждым сервисом. То есть возникает необходимость расширения интерфейсов сервисов, позволяющего учесть возникшие проблемы интеграции. Кроме того, как показано на рис. 14.4, при визуализации интеграция и поток данных между получающимися в результате сервисами напоминают типичный распределенный большой ком грязи. 

Перефразируя метафору Рэнди Шоупа, можно сказать, что, разбив систему на такие мелкие сервисы, мы определенно свели количество входных дверей сервисов к минимуму. Но для реализации общей функциональности системы нам пришлось добавить в каждый сервис широкие входы «только для персонала». Давайте посмотрим, какой урок можно извлечь из этого примера.

![[Рис. 14.4. Сложности интеграции.png]]

## Цель проектирования

Следование упрощенной эвристике декомпозиции, согласно которой каждым сервисом предоставляется только один метод, оказалось неоптимальным по многим причинам. Во-первых, это просто не представляется возможным. Поскольку сервисы должны работать вместе, возникла необходимость расширения их публичных интерфейсов за счет применения публичных интеграционных методов. Во-вторых, получается, выиграв битву, мы проиграли войну. Каждый сервис оказался намного проще исходного, но в совокупности получающаяся система стала на несколько порядков сложнее.

Цель микросервисной архитектуры заключается в создании гибкой системы. Сосредоточение усилий проектирования на одном компоненте при игнорировании порядка его взаимодействия со всей остальной частью системы противоречит самому определению системы:

*   Набор взаимосвязанных элементов или устройств, работающих вместе.
*   Набор компьютерного оборудования и программ, используемых вместе для достижения определенной цели.

Следовательно, система не может быть построена из абсолютно независимых компонентов. В удачно спроектированной микросервисной системе, даже при разобщенности сервисов, они все равно должны быть объединены на основе взаимодействия друг с другом. Давайте посмотрим на взаимодействие сложности, присущей отдельно взятым микросервисам, и сложности, присущей общей системе.

## Сложность системы

Сорок лет назад не было облачных вычислений, не было каких-либо требований глобального порядка и не было необходимости развертывать систему каждые 11,7 секунды. Но разработчикам все же приходилось укрощать сложность систем. Несмотря на то что инструменты в те дни были совершенно иными, задачи и, что более важно, решения актуальны и сегодня и могут быть применены к проектированию систем на основе микросервисов.

В своей книге «`Composite/Structured Design`» Гленфорд Дж. Майерс (`Glenford J. Myers`) рассматривает приемы структурирования процедурного кода, приводящие к снижению его сложности. И на первой странице книги он пишет следующее:

> *Вопрос снижения сложности гораздо шире простой попытки минимизации локальной сложности каждой части программы. Куда более важным типом сложности является глобальная сложность, под которой понимается сложность общей структуры программы или системы (т. е. степень связи или взаимозависимости между основными частями программы).*

В нашем контексте под локальной сложностью понимается сложность каждого отдельно взятого микросервиса, а под глобальной сложностью — сложность всей системы. Локальная сложность зависит от реализации сервиса, а глобальная сложность определяется взаимодействиями и зависимостями между сервисами. Какую из сложностей важнее оптимизировать при разработке системы на основе микросервисов? Проанализируем это.

Свести к минимуму глобальную сложность, как ни странно, легко. Нужно лишь исключить любые взаимодействия между компонентами системы, т. е. реализовать весь функционал в одном монолитном сервисе. И как ранее уже показывалось, эта стратегия может сработать. В иных случаях это может привести к ужасно большому кому грязи (`big ball of mud`): возможно, это и будет наивысший уровень локальной сложности.

С другой стороны, нам известно, что происходит, когда оптимизируется только локальная сложность и пренебрегается глобальной сложностью системы. Тогда получается еще более ужасный распределенный большой ком грязи. Данная взаимосвязь показана на рис. 14.5. 

![[Рис. 14.5. Степень гранулярности сервисов и сложность системы.png]]

Чтобы спроектировать удачную систему на основе микросервисов, нужно оптимизировать как локальную, так и глобальную сложность. Локальный оптимум заключается в цели проектирования, выражающейся в оптимизации любого отдельно взятого сервиса. Глобальный оптимум призван сбалансировать оба вида сложностей. А теперь давайте посмотрим, как сбалансированность глобальной и локальной сложности достигается введением такого понятия, как публичные микроинтерфейсы.

## Микросервисы как «глубокие» сервисы (`deep services`)

Модуль в программной системе или любой системе определяется, собственно говоря, своей функцией и логикой. Функцией определяется предназначение модуля, т. е. его бизнес-функциональность. А логикой является бизнес-логика модуля, т. е. тем, как в модуле реализуется его бизнес-функциональность.

В своей книге «`The Philosophy of Software Design`» Джон Оустерхаут (`John Ousterhout`) рассматривает понятие модульности и предлагает простую, но мощную визуальную эвристику для оценки конструкции модуля: глубину.

Оустерхаут предлагает визуализировать модуль в виде прямоугольника, показанного на рис. 14.6. Верхний край прямоугольника является представлением функции модуля или сложности его публичного интерфейса. Чем шире прямоугольник, тем шире функциональность, а чем он уже, тем ограниченнее его функция и, следовательно, проще публичный интерфейс. Площадь прямоугольника является представлением логики модуля или реализации его функциональности. 

![[Рис. 14.6. Глубокие модули.png]]

Согласно этой модели эффективные модули глубоки: в простом публичном интерфейсе инкапсулируется сложная логика. Неудачные модули слишком мелки: в публичном интерфейсе мелкого модуля инкапсулируется гораздо меньшая сложность, чем в интерфейсе глубокого модуля. Рассмотрим метод, показанный в следующем листинге:

```java
int AddTwoNumbers(int a, int b)
{
 return a + b;
}
```

Это яркий пример мелкого модуля: открытый интерфейс (сигнатура метода) и его логика (методы) абсолютно одинаковы. Такой вот модуль вводит в систему лишние «подвижные детали» (`moving parts`), и, стало быть, вместо инкапсуляции сложности он добавляет совершенно непреднамеренную сложность (`accidental complexity`) ко всей системе.

## Микросервисы как глубокие модули

Помимо иной терминологии, понятие глубоких модулей отличается от микросервисов тем, что модулями могут обозначаться как логические, так и физические границы, тогда как микросервисы имеют строго физические границы. В остальном обе концепции и лежащие в их основе принципы проектирования совершенно одинаковы.

Сервисы, показанные на рис. 14.3, в которых реализуется только один бизнес-метод, представляют собой мелкие модули. Поскольку нам пришлось вводить публичные интеграционные методы, получившиеся интерфейсы стали «шире», чем должны были быть.

С позиции общесистемной сложности глубокий модуль уменьшает глобальную сложность системы, а мелкий модуль ее увеличивает, вводя компонент, не инкапсулирующий его локальную сложность.

Мелкие сервисы также являются причиной неудач множества проектов, ориентированных на применение микросервисов. Ошибочные определения микросервиса как сервиса, содержащего не более `X` строк кода, или как сервиса, чей код будет легче переписать, чем модифицировать, относятся к отдельно взятому сервису, и при этом упускается из виду самый важный аспект архитектуры: система.

Пороговое значение уровня декомпозиции системы на микросервисы определяется сценариями использования системы, частью которой являются микросервисы. По мере декомпозиции монолита на микросервисы стоимость внесения изменений снижается и достигает минимума при достижении уровня порогового значения. Но, если продолжить декомпозицию и выйти за пороговое значение, сервисы будут становиться все мельче и мельче, а их интерфейсы будут разрастаться. И тогда потребности в интеграции поднимут стоимость внесения изменений, а общая архитектура системы превратится в ужасающий распределенный большой ком грязи. Все это показано на рис. 14.7. Рис. 

![[Рис. 14.7. Уровень разбиения и издержки внесения изменений.png]]

Разобравшись с понятием микросервисов, давайте посмотрим, как предметно-ориентированное проектирование способно помочь определению границ «глубоких» сервисов.

## Предметно-ориентированное проектирование и границы микросервисов

Применительно к микросервисам многие из паттернов предметно-ориентированного проектирования, рассмотренные в предыдущих главах, связаны с границами: ограниченный контекст (`bounded context`) является границей модели, поддомен ограничивает бизнес-компетенции (`capabilities`), а агрегаты (`aggregate`) и объекты-значения (`value object`) определяют границы транзакций. Давайте выясним, какие из этих границ соответствуют понятию микросервисов.

### Ограниченные контексты

У микросервисов и паттерна ограниченного контекста столько общего, что они зачастую используются вместо друг друга. Давайте выясним, так ли это на самом деле: соотносятся ли границы ограниченных контекстов с границами микросервисов?

И микросервисы, и ограниченные контексты определяются физическими границами. Микросервисы как ограниченные контексты разрабатываются одной командой. Как и в ограниченных контекстах, конфликтующие модели не могут быть реализованы в микросервисе, что приводит к усложнению интерфейсов. Микросервисы, конечно же, являются ограниченными контекстами. Но работает ли эта связь наоборот? Можно ли сказать, что ограниченные контексты — это микросервисы?

Из главы 3 известно, что ограниченные контексты защищают согласованность единых языков и моделей. В одном и том же ограниченном контексте нельзя реализовать никакие конфликтующие модели. Допустим, что ведется работа над системой управления рекламой. Сущность `Lead` (Потенциальный клиент) в контекстах `Promotions` (Рекламные акции) и `Sales` (Продажи) представлена различными моделями. Следовательно, `Promotions` и `Sales` являются ограниченными контекстами, каждый из которых определяет одну и только одну модель сущности `Lead`, которая, как показано на рис. 14.8, действительна в своих границах. 

![[Рис. 14.8. Ограниченные контексты.png]]

Не станем усложнять ситуацию и предположим, что в системе нет других конфликтующих моделей, кроме `Lead`. Вполне естественно, что при этом получаются весьма обширные ограниченные контексты — каждый из них может содержать сразу несколько поддоменов. Поддомены можно перемещать из одного ограниченного контекста в другой. Пока модели в поддоменах не конфликтуют, все альтернативные варианты декомпозиции (разбиения), показанные на рис. 14.9, являются вполне допустимыми ограниченными контекстами. 

![[Рис. 14.9. Альтернативные декомпозиции ограниченных контекстов.png]]

Разные декомпозиции для ограниченных контекстов мотивируются разными требованиями, например разным количественным составом и структурами команд разработчиков, зависимостями жизненного цикла и т. д. Но можно ли сказать, что все допустимые ограниченные контексты в этом примере обязательно являются микросервисами? Конечно, нет. Особенно если учесть относительно широкие функциональные возможности двух ограниченных контекстов в декомпозиции под номером 1.

Таким образом, отношения между микросервисами и ограниченными контекстами не являются симметричными. И хотя микросервисы являются ограниченными контекстами, не каждый ограниченный контекст является микросервисом. Зато ограниченные контексты обозначают границы самого большого допустимого монолита. В главе 15 будет показано, что в некоторых случаях проекты с такими широкими границами оказываются эффективнее применения микросервисов.

На рис. 14.10 наглядно продемонстрирована взаимосвязь ограниченных контекстов и микросервисов. Безопасной считается область между ограниченными контекстами и микросервисами. В ней находятся допустимые варианты конструкции. Но если система не разбита на надлежащие ограниченные контексты или разбита за порогом микросервисов, то получится соответственно либо большой ком грязи, либо он же, но в распределенном виде. 

![[Рис. 14.10. Уровень разбиения и модульность.png]]

Теперь давайте рассмотрим другую крайность: могут ли агрегаты помочь определить границы микросервисов.

### Агрегаты

В отличие от ограниченных контекстов, устанавливающих наиболее широкие возможные границы, паттерн «Агрегат» делает совершенно обратное. Граница агрегата — самая узкая из всех возможных границ. Разбивать агрегат на несколько физических сервисов или ограниченных контекстов не только нерационально, но, как станет известно из приложения 1, приводит, мягко говоря, к нежелательным последствиям.

Как и ограниченные контексты, границы агрегатов также часто рассматриваются в качестве определяющих границ микросервисов. Агрегат является неделимой единицей бизнес-функции, инкапсулирующей все сложности своих внутренних бизнес-правил, инвариантов и бизнес-логики. При этом, как уже упоминалось в данной главе, микросервисы — это не про отдельно взятые сервисы. Отдельный сервис следует рассматривать в контексте его взаимодействия с другими компонентами системы:

*   Осуществляет ли рассматриваемый агрегат обмен данными с другими агрегатами в своем поддомене?
*   Использует ли он объекты-значения совместно с другими агрегатами?
*   Насколько высока вероятность, что изменения бизнес-логики агрегата повлияют на другие компоненты поддомена и наоборот?

Чем сильнее связь агрегата с другими сущностями его поддомена, тем в меньшей степени он будет считаться отдельным сервисом.

В отдельных случаях использование агрегата в качестве сервиса приводит к модульному дизайну. Но гораздо чаще такие сильно гранулярные сервисы только увеличивают глобальную сложность всей системы.

### Поддомены

Более сбалансированный эвристический подход к разработке микросервисов заключается в подстраивании сервисов под границы поддоменов. В главе 1 уже говорилось, что поддомены увязываются с конкретными бизнес-компетенциями (`capabilities`). То есть они представляют собой структурные элементы бизнеса, необходимые для того, чтобы компания могла конкурировать в своей области (или областях) бизнеса. С позиции предметной области поддомены конкретизируют бизнес-компетенции (`capabilities`) — т. е. то, чем этот бизнес занимается, — без объяснения того, как эти бизнес-компетенции реализуются. С технической точки зрения поддомены представляют собой наборы согласованных сценариев использования: использование одной и той же модели предметной области, работа с одними и теми же или тесно связанными данными и тесная функциональная взаимосвязь. Как показано на рис. 14.11, изменение бизнес-требований одного из сценариев использования, скорее всего, повлияет и на другие сценариев использования. 

![[Рис. 14.11. Поддомены.png]]

Конкретизация поддоменов и акцент на функциональности — т. е. ответ на вопрос «Что?», а не «Как?» — делают поддомены естественными глубокими модулями (`deep module`). Описание поддомена — функция — заключает в себе более сложные детали реализации — логику. Согласованный характер сценариев использования, имеющихся в поддомене, также обеспечивает глубину итогового модуля. Разбиение их на части во многих случаях привело бы к более сложному публичному интерфейсу и, следовательно, к более мелким модулям. Все это делает поддомены безопасной границей для разработки микросервисов.

Увязывание микросервисов с поддоменами — безопасный эвристический подход, позволяющий найти оптимальные решения для большинства микросервисов. При этом порой более эффективными будут другие границы, например пребывание в более широких лингвистических границах ограниченного контекста или же из-за специфических нефункциональных требований. Решение зависит не только от предметной области, но и от структуры организации, бизнес-стратегии и нефункциональных требований. Как уже упоминалось в главе 11, крайне важно постоянно адаптировать архитектуру и дизайн программного продукта к изменениям, происходящим в среде его применения.

## Сокращение публичных интерфейсов микросервисов

В дополнение к установлению границ сервисов предметно-ориентированное проектирование может посодействовать росту «глубины» сервисов. В этом разделе будет показано, как паттерн «Сервис» с открытым протоколом (`open-host service`) и предохранительный слой (`anticorruption layer`) могут упростить публичные интерфейсы микросервисов.

### Сервис с открытым протоколом

Сервис с открытым протоколом (`open-host service`) отделяет модель ограниченного контекста предметной области от модели, используемой для интеграции с другими компонентами системы (рис. 14.12). Рис. 14.12. Интеграция сервисов посредством опубликованного языка

Внедрение модели, ориентированной на интеграцию, т. е. внедрение общедоступного языка (`published language`), снижает глобальную сложность системы. Во-первых, это позволяет осуществлять дальнейшее развитие сервиса, не затрагивая при этом его потребителей: новую модель реализации можно перевести на уже существующий опубликованный язык (`published language`). Во-вторых, опубликованный язык выставляет на всеобщее обозрение куда более ограниченную модель. Он разработан с учетом потребностей интеграции и инкапсулирует все сложности реализации, не имеющие отношения к потребителям сервиса. К примеру, опубликованный язык может предоставлять меньший объем данных и в более удобной для потребителей модели.

Наличие более простого публичного интерфейса (функции) в качестве надстройки над той же самой реализацией (логикой) делает сервис «глубже» и способствует созданию более эффективной конструкции микросервиса.

![[Рис. 14.12. Интеграция сервисов посредством опубликованного языка.png]]

### Предохранительный слой (`anticorruption layer, ACL`)

Предохранительный слой (`anticorruption layer, ACL`) работает с точностью до наоборот, что позволяет снизить сложность интеграции сервиса с другими ограниченными контекстами. Традиционно предохранительный слой относится к защищаемому им ограниченному контексту. Но, как уже говорилось в главе 9, это представление можно сдвинуть еще дальше и реализовать в виде отдельного сервиса.

`ACL`-сервис, показанный на рис. 14.13, снижает как локальную сложность ограниченного контекста-потребителя, так и глобальную сложность системы. Cложность ограниченного контекста-потребителя отделена от сложности интеграции, которая помещается в `ACL`-сервис. Поскольку ограниченный контекст-потребитель сервиса работает с более удобной, ориентированной на интеграцию моделью, его открытый интерфейс сужается — он не отражает той сложности интеграции, которая предоставляется сервисом-поставщиком (`producer`). 

![[Рис. 14.13. Предохранительный слой в виде самостоятельного сервиса.png]]

## Вывод

Исторически сложилось так, что архитектурный стиль, основанный на микросервисах, настолько тесно переплетается с предметно-ориентированным проектированием, что такие понятия, как «микросервис» и «ограниченный контекст» часто используются вместо друг друга. В этой главе была проанализирована связь между ними и показано, что это не одно и то же.

Все микросервисы являются ограниченными контекстами, но не все ограниченные контексты в обязательном порядке являются микросервисами. По сути, микросервис определяет наименьшую допустимую границу сервиса, а ограниченный контекст защищает согласованность охватываемой им модели и представляет самые широкие допустимые границы. Определение границ шире их ограниченных контекстов приведет к появлению большого кома грязи, а если границы будут охватывать пространство меньше микросервисов, то возникнет распределенный большой ком грязи.

И все же между микросервисами и предметно-ориентированным проектированием существует довольно-таки тесная связь. Здесь было показано, как инструменты предметно-ориентированного проектирования можно использовать для разработки эффективных границ микросервисов.

В главе 15 будет продолжено рассмотрение системной архитектуры высокого уровня, но уже с другой позиции: асинхронной интеграции посредством событийно-ориентированной архитектуры. Будет показан порядок использования различных видов событий, позволяющий проводить дальнейшую оптимизацию границ микросервисов.