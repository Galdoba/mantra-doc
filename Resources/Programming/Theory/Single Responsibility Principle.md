---
updated_at: 2026-02-17T16:57:38.306+10:00
---
**Принцип единственной ответственности** ({{Single Responsibility Principle|Single Responsibility Principle}}, SRP) — это принцип проектирования, утверждающий, что у [[Class|класса]], [[Module|модуля]] или [[Function|функции]] должна быть только одна причина для изменения. Иными словами, каждый программный компонент должен отвечать ровно за одну чётко определённую часть функциональности, инкапсулируя её полностью внутри себя.

Принцип сформулирован Робертом Мартином и является первым из пяти принципов [[SOLID|SOLID]].

### Назначение
Следование принципу единственной ответственности направлено на управление сложностью и обеспечение устойчивости к изменениям:

*   **Локализация изменений**. Когда требования меняются, затрагивается только тот компонент, который непосредственно отвечает за изменяемую функциональность. Остальные части системы остаются нетронутыми.
*   **Читаемость и понятность**. Небольшие, сфокусированные классы легче понять, чем крупные, перегруженные разнородными обязанностями.
*   **Тестируемость**. Компонент с одной ответственностью имеет меньше зависимостей и сценариев использования, что упрощает написание [[Unit Test|модульных тестов]] и достижение высокого покрытия.
*   **Повторное использование**. Узкоспециализированный компонент с большей вероятностью может быть переиспользован в другом контексте, чем компонент, смешивающий множество несвязанных функций.
*   **Снижение связанности**. Выделение обязанностей в отдельные компоненты уменьшает количество связей между различными частями системы.

### Ограничения
Применение принципа единственной ответственности сопряжено с рядом объективных трудностей:

1.  **Субъективность понятия «ответственность»**. Что считать одной ответственностью — зависит от контекста, уровня абстракции и точки зрения. В разных проектах и на разных этапах эволюции системы границы могут проводиться по-разному.
2.  **Риск избыточного дробления ([Over-Engineering])**. Чрезмерное следование принципу приводит к созданию множества мельчайших классов, каждый из которых содержит одну-две строки кода. Это увеличивает сложность навигации и понимания общей картины.
3.  **Необходимость компромиссов**. Иногда объединение нескольких ответственностей в одном классе оправдано производительностью, простотой реализации или минимизацией количества артефактов.
4.  **Неочевидность причин изменения**. На начальных этапах разработки бывает сложно предвидеть, какие именно аспекты функциональности будут изменяться независимо. Преждевременная декомпозиция может оказаться ошибочной.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к применению принципа единственной ответственности:

1.  **Формулировка «причина для изменения»**. Для оценки качества декомпозиции задаётся вопрос: «Какие акторы (заинтересованные лица, отделы, бизнес-роли) могут инициировать изменения в этом классе?». Если таких акторов более одного, класс, вероятно, нарушает SRP.

2.  **Выделение сквозных функциональностей ([[Cross-cutting Concern|cross-cutting concerns]])**. Логирование, кэширование, аутентификация, сериализация — это классические примеры ответственностей, которые следует отделять от основной бизнес-логики. Для их вынесения используются паттерны [[Decorator|декоратор]], [[Proxy|прокси]] или [[Aspect-Oriented Programming|аспектно-ориентированное программирование]].

3.  **Инкапсуляция в [[Value Object|объекты-значения]] и [[Domain Primitive|доменные примитивы]]**. Проверка формата, вычисления, форматирование выделяются из сущностей в специализированные классы-значения. Например, вместо хранения номера телефона как строки в классе «Клиент», создаётся класс `PhoneNumber`, отвечающий за валидацию, форматирование и сравнение.

4.  **Разделение [[Model|модели]], [[View|представления]] и [[Controller|контроллера]] (MVC)**. Классическая архитектура, в которой каждый слой имеет единственную, чётко определённую ответственность: управление данными, отображение или обработка ввода пользователя.

5.  **[[Repository|Репозиторий]] как отделение доступа к данным**. Логика сохранения и извлечения объектов выделяется в отдельные классы, не смешиваясь с бизнес-правилами сущностей.

6.  **[[Facade|Фасад]] для упрощения сложных подсистем**. Фасад предоставляет унифицированный интерфейс и скрывает множество внутренних взаимодействий, но сам не смешивает ответственности; его единственная задача — упрощение доступа.

7.  **[[Command|Команда]] и [[Handler|обработчик]]**. В [[CQRS|CQRS]] и событийно-ориентированных архитектурах каждая команда обрабатывается отдельным классом, который отвечает ровно за одну операцию. Это крайняя степень декомпозиции, обеспечивающая максимальную гибкость.

8.  **Итеративное уточнение границ**. Не требуется идеально разделять ответственности с первого раза. Допустимо начинать с более крупных компонентов и постепенно выделять из них новые классы по мере накопления изменений и углубления понимания предметной области ([[Refactoring|рефакторинг]]).

9.  **Критерий «размер имеет значение»**. Как эмпирическое правило: если описание назначения класса требует использования союзов «и», «или», «а также» — это сигнал о возможном нарушении SRP.

10. **Документирование ответственности**. В комментариях к классу или в имени самого класса явно фиксируется, за какую именно функциональность он отвечает. Это помогает поддерживать фокус при последующих изменениях.

Таким образом, принцип единственной ответственности является не жёстким законом, а руководством к поиску правильного уровня абстракции. Его последовательное применение требует умения распознавать независимые направления изменений и готовности к рефакторингу по мере появления новых знаний о системе. При разумном использовании SRP значительно повышает сопровождаемость и устойчивость программного обеспечения к неизбежным изменениям требований.