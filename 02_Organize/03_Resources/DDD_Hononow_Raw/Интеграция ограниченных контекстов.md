---
updated_at: 2025-12-15T13:56:53.564+10:00
tags:
---
Ограниченный контекст (Bounded Context) защищает согласованность единого языка (Ubiquitous Language) внутри своих границ и открывает возможности к построению моделей. Построить модель, не определив цель ее существования, т. е. не зафиксировав ее границы, невозможно. Эта граница — граница ответственностей языков, она означает, что одни и те же бизнес-сущности в разных ограниченных контекстах могут использоваться для решения различных задач. 
Несмотря на то что развитие моделей и их реализация внутри различных ограниченных контекстов могут идти независимо, сами ограниченные контексты независимыми друг от друга не являются. Система не может состоять из независимых компонентов (компоненты должны взаимодействовать друг с другом для достижения основных целей системы), это же справедливо и для ограниченных контекстов: несмотря на возможность независимого развития, они все же должны интегрироваться друг с другом. В результате всегда будут возникать точки соприкосновения ограниченных контекстов друг с другом, именуемые контрактами. 
Необходимость в контрактах возникает из-за различий в моделях и языках ограниченных контекстов. Поскольку каждый контракт затрагивает более чем одного участника, их необходимо определить и скоординировать. Кроме того, по определению в двух разных ограниченных контекстах используются разные единые языки. А какой язык будет использоваться в целях интеграции? Все эти проблемы интеграции должны быть осмыслены и учтены при разработке решения. 
Разговор в этой главе пойдет о паттернах предметно-ориентированного проектирования, предназначенных для определения отношений и интеграции ограниченных контекстов. Суть паттернов обусловливается характером сотрудничества между командами, работающими над ограниченными контекстами. Паттерны будут разделены на три группы, каждая из которых представляет собой тип командного взаимодействия: сотрудничество (cooperation), потребитель-поставщик (customersupplier) и разные пути (separate ways).

# Сотрудничество (Cooperation) 
Паттерны сотрудничества (cooperation) относятся к ограниченным контекстам (bounded context), реализованным командами с хорошо налаженным взаимодействием. 
В наипростейшем случае имеются в виду ограниченные контексты, реализуемые одной и той же командой. Это также может относиться к командам со взаимозависимыми целями, когда успех одной команды зависит от успеха другой и наоборот. Опять же, главный критерий здесь — плотность общения и совместной работы команд. 
Давайте рассмотрим два паттерна DDD, подходящих для совместной работы команд: паттерн партнерства (partnership) и паттерн общего ядра (shared kernel).

## Партнерство (Partnership) 
В партнерской (partnership) модели интеграция ограниченных контекстов координируется по ситуации. Одна команда может уведомить вторую команду об изменении API, а вторая команда адаптируется к нему в духе сотрудничества — без драм и конфликтов (см. рис. 4.1).

![[Рис. 4.1. Модель партнерства.png]]

Здесь прослеживается двусторонняя координация интеграции. Ни одна команда не навязывает язык, используемый для определения контрактов. Команды могут разобраться в различиях и выбрать наиболее подходящее решение. Кроме того, обе стороны сотрудничают в решении любых возникающих вопросов интеграции. Ни одна из команд не заинтересована в блокировке работы другой команды. 
Получается, что для успешной интеграции нужны хорошо отработанные методы совместной работы, высокая степень обязательности и частая синхронизация действий команд. С технической точки зрения необходима непрерывная интеграция изменений, вносимых обеими командами, чтобы до минимума сократить цикл обратной связи интеграции. 
Этот паттерн может не подойти для команд, географически удаленных друг от друга из-за возможных трудностей с синхронизацией работ и общением.

## Общее ядро (shared kernel) 
Несмотря на то что границы модели определяются ограниченными контекстами, бывают случаи, когда одна и та же модель поддомена (subdomain) или часть этой модели будет реализована сразу в нескольких ограниченных контекстах. Здесь крайне важно отметить, что общая модель разрабатывается в соответствии с потребностями всех ограниченных контекстов. Более того, общая модель должна быть согласована во всех использующих ее ограниченных контекстах. 
Рассмотрим в качестве примера корпоративную систему, использующую собственную модель управления доступами, выдаваемыми пользователям на те или иные действия. Разрешения, выдаваемые каждому пользователю, могут предоставляться напрямую или быть унаследованными от одного из организационных подразделений, к которым этот пользователь принадлежит. Более того, каждый ограниченный контекст может изменять модель авторизации, и изменения, применяемые каждым ограниченным контекстом, должны влиять на все остальные ограниченные контексты, использующие эту модель (см. рис. 4.2).

![[Рис. 4.2. Общее ядро.png]]

### Общие рамки (Shared scope) 
Модель с перекрытием, используемая в нескольких ограниченных контекстах, связывает жизненные циклы. Изменение, внесенное в общую модель, тут же повлияет на все ограниченные контексты. Следовательно, чтобы свести к минимуму каскадные эффекты изменений, модель с перекрытием должна выставлять ограничения, чтобы раскрывалась только та ее часть, которая должна быть реализована обоими ограниченными контекстами. В идеале общее ядро (shared kernel) будет состоять только из интеграционных контрактов и структур данных, предназначенных для передачи данных через границы ограниченных контекстов. 

### Реализация 
Общее ядро (shared kernel) реализуется так, что любая модификация его исходного кода тут же отражается во всех использующих его ограниченных контекстах. Если в организации практикуется подход с использованием монорепозитория, общее ядро может быть в виде одних и тех же исходных файлов, на которые ссылаются сразу несколько ограниченных контекстов. Если использование общего монорепозитория невозможно, общее ядро можно выделить в отдельный проект и ссылаться на него в ограниченных контекстах как на связанную библиотеку. В любом случае каждое изменение в общем ядре должно инициировать запуск интеграционных тестов для всех затронутых им ограниченных контекстов. 
Интеграция изменений должна вестись непрерывно, поскольку общее ядро принадлежит множеству ограниченных контекстов. Если не распространять изменения, вносимые в общее ядро, на все связанные ограниченные контексты, в модели возникнут несоответствия: ограниченные контексты могут зависеть от устаревших реализаций общего ядра, что может привести к повреждению данных и (или) возникновению проблем во время выполнения программы.

### Когда следует воспользоваться общим ядром 
Комплексным критерием применимости паттерна общего ядра является сравнительная затратность дублирования и координации. Поскольку паттерн вводит сильную зависимость между задействованными ограниченными контекстами, его следует применять только в том случае, когда затраты на дублирования выше затрат на координацию, иными словами, только в том случае, когда на интеграцию изменений, примененных к общей модели, уйдет в обоих ограниченных контекстах больше усилий, чем на координацию изменений в общей кодовой базе. 
Разница между затратами на интеграцию и дублирование зависит от волатильности модели. Чем чаще в ней происходят изменения, тем выше будут затраты на интеграцию. Поэтому общее ядро естественным образом будет применяться к тем поддоменам, которые подвержены самым частым изменениям: к основным поддоменам (core subdomains). 
В определенном смысле паттерн общего ядра противоречит принципам ограниченных контекстов, представленным в предыдущей главе. Если задействованные ограниченные контексты реализуются не одной и той же командой разработчиков (team), введение общего ядра противоречит принципу, согласно которому ограниченным контекстом должна владеть одна команда. Модель с перекрытием, имеющая общее ядро, фактически разрабатывается несколькими командами. 
Именно поэтому использование общего ядра должно быть строго обосновано. Это прагматичное исключение из правил, которое следует тщательно продумать. Распространенным вариантом использования общего ядра является ситуация, при которой есть проблемы со свободным общением или совместной работой, не позволяющие реализовать паттерн партнерства (partnership), например из-за географических ограничений или организационной политики. Реализация тесно связанной функциональности без надлежащей координации приведет к проблемам интеграции, рассинхронизированным моделям и спорам о том, какая из моделей лучше спроектирована. Минимизация области действия общего ядра контролирует область действия каскадных изменений, а запуск интеграционных тестов для каждого изменения — это способ обеспечить раннее обнаружение проблем интеграции. 
Еще одним распространенным, хотя и временным вариантом использования паттерна общего ядра, является постепенная модернизация устаревшей системы. В этом сценарии общая кодовая база может быть прагматичным промежуточным решением для постепенного разбиения системы на ограниченные контексты. 
И наконец, общее ядро может удачно подойти для интеграции ограниченных контекстов, принадлежащих и реализуемых одной и той же командой. В таком случае непродуманная интеграция ограниченных контекстов по принципу партнерства может со временем «размыть» границы контекстов. Общее ядро можно использовать для явного определения интеграционных контрактов ограниченных контекстов.

## Потребитель-Поставщик (Customer-supplier) 
Вторая, рассматриваемая нами группа паттернов сотрудничества — паттерны типа потребитель-поставщик (customer-supplier). На рис. 4.3 показано, что один ограниченный контекст, поставщик (supplier), предоставляет услуги своим потребителям (customer). Поставщик услуг находится «выше по течению», а клиент или потребитель — «ниже по течению».

![[Рис. 4.3. Отношения потребитель-поставщик.png]]

В отличие от схемы сотрудничества, обе команды (выше и ниже по течению) могут добиться успеха независимо друг от друга. Следовательно, в большинстве случаев получается дисбаланс сил: интеграционный контракт может диктовать либо вышестоящая, либо нижестоящая команда. 
В этом разделе будут рассмотрены паттерны трех типов, предназначенные для устранения подобных различий в силе команд: конформист (conformist), предохранительный слой (anticorruption layer) и сервис с открытым протоколом (open-host service).

### Конформист (Conformist) 
В ряде случаев при сложившемся балансе сил предпочтение отдается вышестоящей (upstream) команде, у которой нет никакой реальной мотивации поддерживать потребности своих клиентов. Вместо этого она просто предоставляет интеграционный контракт, определенный в соответствии со своей собственной моделью по принципу «хочешь принимай, хочешь не принимай». Такой дисбаланс сил может быть вызван интеграцией с внешними по отношению к организации поставщиками услуг, или же просто сложившейся политикой организации. 
Если нижестоящая (downstream) команда может принять модель вышестоящей (upstream) команды, отношения ограниченных контекстов называются конформистскими (conformist). Как показано на рис. 4.4, нижестоящий подстраивается под модель ограниченного контекста вышестоящего. 
Решение нижестоящей команды отказаться от части своей автономности может быть оправдано несколькими обстоятельствами. Например, контракт, представленный вышестоящей командой, может быть стандартной, хорошо зарекомендовавшей себя моделью или может быть вполне подходящим для нужд нижестоящей команды.

![[Рис. 4.4. Конформистские отношения.png]]

Следующий паттерн касается случая, когда клиент (потребитель) не желает принимать модель поставщика.

### Предохранительный слой (Anticorruption layer) 
Как и в случае с паттерном конформист, баланс сил в этих отношениях попрежнему смещен в сторону вышестоящего сервиса. Но в данном случае нижестоящий ограниченный контекст не желает под нее подстраиваться. Взамен, как показано на рис. 4.5, модель вышестоящего ограниченного контекста может быть с помощью предохранительного слоя (anticorruption layer) преобразована в модель, приспособленную к его собственным нуждам.

![[Рис. 4.5. Интеграция посредством применения предохранительного слоя.png]]

Предохранительный слой (Anticorruption Layer) предназначен для тех сценариев, когда прилагать усилия для подстройки под модель поставщика нежелательно или нецелесообразно, например: 
*Когда нисходящий (downstream) ограниченный контекст содержит основной поддомен (core subdomain)* 
	Модель основного поддомена требует особого внимания, а соблюдение модели поставщика может затруднить моделирование (problem domain) предметной области решаемой проблемы. 
*Когда восходящая (upstream) модель неэффективна или не соответствует нуждам потребителя* 
	Если ограниченный контекст подстраивается под какой-либо беспорядок, он сам рискует стать беспорядочным. Такое довольно часто происходит при интеграции с устаревшими системами.
*Когда контракт поставщика меняется слишком часто* 
	Потребитель хочет защитить свою модель от частых изменений. При наличии предохранительного слоя модификации в модели поставщика влияют только на механизм трансляции. 
С точки зрения моделирования трансляция модели поставщика изолирует нижестоящего потребителя от чужих концепций, не имеющих отношения к его ограниченному контексту. Тем самым это позволяет упростить единый язык (ubiquitous language) и модель потребителя. 
Различные способы реализации предохранительного уровня будут рассмотрены в *главе 9*.

### Сервис с открытым протоколом (Open-Host Service) 
Этот паттерн предназначен для случаев, когда главная роль принадлежит потребителям. Поставщик заинтересован в защите своих потребителей и высочайшем качестве их обслуживания. 
Чтобы защитить потребителей от изменений в своей модели реализации, вышестоящий поставщик отделяет модель реализации от общедоступного интерфейса. Такое разобщение, как показано на рис. 4.6, позволяет поставщику развивать свою реализацию и общедоступные модели разными темпами.

![[Рис. 4.6. Интеграция через сервис с открытым протоколом.png]]

Публичный интерфейс поставщика не предназначен для соответствия его единому языку (ubiquitous language). Цель этого интерфейса — предоставить удобный потребителям протокол, выраженный на языке, ориентированном на интеграцию. Поэтому публичный протокол называют опубликованным языком (published language). 
В каком-то смысле паттерн сервиса с открытым протоколом представляет собой перевернутый вариант паттерна предохранительного уровня: здесь трансляцией своей внутренней модели занимается не потребитель, а поставщик. 
Разделение моделей реализации и интеграции ограниченного контекста дает вышестоящему ограниченному контексту свободу развития своей реализации без затрагивания при этом нижестоящих контекстов. Конечно, такая возможность предоставляется только в том случае, если модифицированную модель реализации можно перевести на опубликованный язык (published language), который уже используется потребителями. 
Кроме того, отделение модели интеграции позволяет вышестоящему ограниченному контексту в одно и то же время предоставлять сразу несколько версий опубликованного языка, допуская постепенный переход потребителя на новую версию (см. рис. 4.7).

![[Рис. 4.7. Сервис с открытым протоколом, предоставляющий несколько версий опубликованного языка.png]]

## Разные пути (Separate Ways) 
Последний вариант сотрудничества — полный отказ от какого-либо сотрудничества. Такая линия поведения может возникнуть по разным причинам в тех случаях, когда команды не хотят или не могут сотрудничать. Часть из этих случаев будет рассмотрена ниже.

### Проблемы общения 
Частой причиной отказа от сотрудничества могут стать трудности общения, обусловленные размерами организации или ее внутренней политикой. Когда командам трудно развивать сотрудничество и договариваться, возможно, рентабельнее будет пойти разными путями и продублировать функциональность в нескольких ограниченных контекстах.

# Универсальный поддомен (Generic Subdomain) 
Причиной расхождения путей команд могут быть особенности дублируемого поддомена. В тех случаях, когда рассматриваемый поддомен является универсальным (generic), а универсальное решение легко поддается интеграции, может оказаться, что его локальная интеграция в каждом ограниченном контексте будет более рентабельной. В качестве примера можно привести фреймворк логирования. Вряд ли было бы разумно выставлять его в качестве сервиса в одном из ограниченных контекстов. Дополнительные сложности интеграции такого решения перевесят преимущества отказа от дублирования функций в различных контекстах, которое обошлось бы дешевле сотрудничества.

## Различия в моделях 
Причиной выбора разных путей также могут стать различия в моделях ограниченного контекста. Модели могут быть настолько разными, что конформистские отношения становятся невозможными, а реализация предохранительного уровня (anticorruption layer) обойдется дороже, чем дублирование функциональности. В этом случае для команд опять-таки выгоднее будет пойти разными путями. 

---
	*При интеграции основных поддоменов (core subdomains) от использования разных путей лучше отказаться. Дублирование реализации таких подобластей противоречило бы стратегии компании по их наиболее эффективной и оптимизированной реализации.*

---

# Карта контекстов (Context Map) 
После анализа паттернов интеграции ограниченных контекстов системы их, как показано на рис. 4.8, можно нанести на контекстную карту.

![[Рис. 4.8. Карта контекстов.png]]

Карта контекстов является визуальным представлением ограниченных контекстов системы и их интеграции. Это визуальное обозначение дает ценную стратегическую информацию на нескольких уровнях: 
*Высокоуровневое проектирование* 
	Карта контекстов дает общий вид компонентов системы и реализуемых ими моделей. 
*Модели общения* 
	Карта контекстов отображает модели общения между командами, например какие команды сотрудничают, а какие предпочитают «менее тесные» интеграционные модели, соответствующие паттернам предохранительного слоя (anticorruption layer) и разных путей (separate ways). 
*Организационные вопросы* 
	Например, какой смысл будет в том, что все нижестоящие потребители определенной вышестоящей команды прибегают к реализации предохранительного уровня (anticorruption layer), или в том, что все реализации паттерна разных путей (separate ways) сосредоточены вокруг одной и той же команды?

### Поддержка в актуальном состоянии 
В идеале карта контекстов должна вводиться в проект с самого начала и обновляться с учетом добавлений новых ограниченных контекстов и изменений в уже существующем контексте. 
Поскольку потенциально карта контекстов содержит информацию, полученную в результате работы нескольких команд, лучше всего определить ведение этой карты совместными усилиями: каждая команда отвечает за обновление своих собственных интеграций с другими ограниченными контекстами. 
Карта контекстов может вестись и поддерживаться в виде кода с использованием инструмента, подобного Context Mapper. 

### Ограничения 
Важно отметить, что составление контекстной карты может быть непростой задачей. Когда ограниченный контекст системы охватывает несколько поддоменов, могут быть задействованы несколько интеграционных моделей. Например, на рис. 4.9 можно увидеть два ограниченных контекста с двумя интеграционными моделями: партнерства (partnership) и предохранительного слоя (anticorruption layer).

![[Рис. 4.9. Сложная карта контекстов.png]]

Более того, даже если ограниченные контексты не выходят за границы одного поддомена, все равно может быть задействовано сразу несколько паттернов интеграции — например, если модули поддоменов требуют разных стратегий интеграции.

# Вывод 
Ограниченные контексты не бывают независимыми. Они должны взаимодействовать друг с другом. Способы интеграции ограниченных контекстов определяются следующими паттернами: 

*Партнерство (Partnership)* 
	Ограниченные контексты интегрируются по ситуации. 
*Общее ядро (Shared Kernel)* 
	Два или более ограниченных контекста интегрируются путем совместного использования ограниченной перекрывающейся модели, которая принадлежит всем задействованным ограниченным контекстам. 
*Конформист (Conformist)* 
	Клиент (потребитель) подстраивается под модель поставщика услуг. 
*Предохранительный слой (Anticorruption layer)* 
	Потребитель преобразует модель поставщика услуг в модель, соответствующую своим нуждам. 
*Сервис с открытым протоколом (Open-host service)* 
	Поставщик услуг реализует опубликованный язык — модель, оптимизированную под нужды своих потребителей. 
*Разные пути (Separate Ways)* 
	Дублирование конкретной функциональности обходится дешевле, чем сотрудничество и интеграция. 
	
Интеграции ограниченных контекстов могут быть нанесены на контекстную карту. Этот инструмент дает представление о высокоуровневой конструкции системы, моделях общения и организационных вопросах. 
Теперь, когда получены представления об инструментах и методах предметноориентированного проектирования, предназначенных для анализа и моделирования бизнес-областей, наше внимание будет перенесено со стратегии на тактику. Во второй части книги будут рассмотрены различные способы реализации логики предметной области, организации высокоуровневой архитектуры и координации взаимодействия компонентов системы.