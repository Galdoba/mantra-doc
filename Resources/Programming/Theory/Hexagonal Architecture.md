---
updated_at: 2026-02-12T16:15:21.146+10:00
---
## Гексагональная архитектура: изоляция ядра от внешнего мира

**Гексагональная архитектура** ({{Hexagonal Architecture|hexagonal architecture}}), также известная как **«Порты и адаптеры» ([[Ports and Adapters|Ports and Adapters]])**, — это архитектурный паттерн, в котором [[Domain Model|предметная область]] (ядро приложения) полностью изолирована от внешних систем, интерфейсов пользователя, баз данных и других инфраструктурных компонентов. Взаимодействие с внешним миром осуществляется исключительно через строго определённые [[Port|порты]] (интерфейсы) и их [[Adapter|адаптеры]] (реализации), которые «подключаются» к ядру, подобно штекерам в розетку.

### Назначение
Гексагональная архитектура обеспечивает центральное положение бизнес-логики и её независимость от технических деталей:

*   **Отделение домена от инфраструктуры**. Бизнес-правила не содержат ссылок на базы данных, веб-фреймворки, очереди сообщений или внешние API.
*   **Тестируемость в изоляции**. Ядро приложения может быть протестировано без поднятия инфраструктуры, с использованием заместителей адаптеров.
*   **Заменяемость внешних компонентов**. База данных, пользовательский интерфейс или сервис интеграции могут быть заменены на альтернативные реализации без изменения кода ядра.
*   **Независимость от технологий**. Система не привязана к конкретным фреймворкам или поставщикам; технологии могут меняться в течение жизненного цикла.
*   **Фокус на предметную область**. Разработка начинается с моделирования бизнес-логики, а инфраструктурные решения добавляются позже.

### Ограничения
Применение гексагональной архитектуры требует осознанных компромиссов:

1.  **Повышенная сложность**. Введение дополнительных уровней абстракции (портов, адаптеров, объектов передачи данных) увеличивает количество классов и когнитивную нагрузку.
2.  **Избыточность для простых систем**. Для CRUD-приложений без сложной бизнес-логики такая архитектура может быть неоправданным усложнением.
3.  **Необходимость маппинга ([[Mapping|mapping]])**. Между моделями ядра и моделями внешних систем (например, ORM-сущностями, DTO) требуется явное преобразование, что добавляет объём кода.
4.  **Сложность координации транзакций**. Границы транзакций часто определяются инфраструктурой (например, реляционной базой данных), что затрудняет их полное вынесение за пределы ядра.
5.  **Порог входа**. Разработчики, не знакомые с паттерном, могут испытывать трудности с определением корректных границ портов и размещением логики.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к реализации гексагональной архитектуры:

1.  **Ядро приложения ([[Application Core|application core]])**. Внутренний слой содержит [[Entity|сущности]], [[Value Object|объекты-значения]], [[Aggregate|агрегаты]], [[Domain Service|сервисы предметной области]] и [[Repository|репозитории]] (в виде интерфейсов). Ядро не имеет внешних зависимостей.

2.  **Порты ([[Port|ports]])**. Интерфейсы, определяющие способы взаимодействия с ядром:
    *   **Входящие порты ([[Inbound Port|inbound ports]])** — API, предоставляемое ядром для внешних клиентов (например, сервисы приложения, use case'ы).
    *   **Исходящие порты ([[Outbound Port|outbound ports]])** — интерфейсы, которые ядро требует от внешнего мира (репозитории, шина событий, внешние API).

3.  **Адаптеры ([[Adapter|adapters]])**. Реализации портов, подключаемые к ядру:
    *   **Ведущие адаптеры ([[Driving Adapter|driving adapters]])** — инициируют взаимодействие с ядром через входящие порты (контроллеры REST, консольные команды, слушатели сообщений).
    *   **Ведомые адаптеры ([[Driven Adapter|driven adapters]])** — реализуют исходящие порты и выполняют операции с внешними системами (репозитории на основе JPA, HTTP-клиенты, продюсеры событий).

4.  **Инверсия зависимостей ([[Dependency Inversion Principle|Dependency Inversion]])**. Зависимости направлены внутрь, к ядру. Адаптеры зависят от портов; ядро не знает об адаптерах.

5.  **Композиция корня ([[Composition Root|composition root]])**. На этапе сборки приложения адаптеры связываются с портами через внедрение зависимостей. Ядро остаётся полностью независимым от конкретных реализаций.

6.  **Явное разделение моделей ([[Separate Domain Model|separate domain model]])**. Модель предметной области не используется напрямую на границах; для взаимодействия с внешним миром создаются специализированные объекты передачи данных ([[DTO|DTO]]). Это предотвращает загрязнение ядра требованиями сериализации или ORM.

7.  **Тестирование на разных уровнях**:
    *   Модульные тесты проверяют ядро изолированно, с заместителями портов.
    *   Интеграционные тесты проверяют адаптеры с реальными внешними системами.
    *   Сквозные тесты проверяют работу всей сборки.

8.  **Архитектурные тесты**. Автоматические проверки, гарантирующие, что зависимости не нарушают направленность: код ядра не импортирует ничего из слоя адаптеров.

9.  **[[Use Case|Use Case]] как единица функциональности**. Каждый бизнес-сценарий оформляется в отдельный класс, реализующий входящий порт. Это улучшает читаемость, тестируемость и соответствие [[Single Responsibility Principle|принципу единственной ответственности]].

10. **Гибкость в выборе технологий**. Например, ядро определяет интерфейс репозитория; адаптер может быть реализован на основе SQL, MongoDB или даже файловой системы без изменения ядра.

Таким образом, гексагональная архитектура представляет собой систематический подход к отделению бизнес-логики от технических деталей. Её последовательное применение требует дисциплины в проектировании границ и явном маппинге данных, но взамен обеспечивает высокую тестируемость, адаптивность к изменению технологий и долгосрочную сопровождаемость сложных предметно-ориентированных систем.