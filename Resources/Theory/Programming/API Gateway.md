---
updated_at: 2026-02-12T15:55:24.885+10:00
---
## API-шлюз: единая точка входа для клиентских запросов

**API-шлюз** ({{API Gateway|API-шлюз}}) — это сервер, выступающий единственной точкой входа для клиентских запросов в систему, построенную из множества [[Microservices|микросервисов]]. Шлюз принимает запросы от клиентов, маршрутизирует их к соответствующим внутренним сервисам, агрегирует ответы, трансформирует протоколы и данные, а также реализует сквозные [[Cross-cutting Concern|сквозные функциональности]]: аутентификацию, авторизацию, ограничение скорости, логирование и сбор метрик.

### Назначение
Внедрение API-шлюза решает задачи, возникающие при прямом взаимодействии клиентов с множеством микросервисов:

*   **Снижение связанности**. Клиенты не зависят от внутренней топологии сервисов; изменения в адресации, версионировании или декомпозиции скрыты за единым фасадом.
*   **Упрощение клиентского кода**. Клиенту не требуется знать, какие сервисы участвуют в обработке запроса, и самостоятельно агрегировать данные из разных источников.
*   **Централизация сквозных функций**. Аутентификация, авторизация, [[Rate Limiting|ограничение частоты запросов]], сбор метрик и логирование выносятся в шлюз, освобождая от их реализации в каждом сервисе.
*   **Трансформация протоколов**. Шлюз может принимать запросы по одному протоколу (например, HTTP/1.1) и перенаправлять их во внутренние сервисы по другому (gRPC, WebSocket, HTTP/2).
*   **Безопасность**. Шлюз скрывает внутреннюю структуру системы от внешнего мира, защищает от атак ([[DDoS|DDoS]]) и централизует политики безопасности.

### Ограничения
Применение API-шлюза вносит дополнительные сложности и риски:

1.  **Единая точка отказа ([[Single Point of Failure|SPOF]])**. При отказе шлюза перестаёт функционировать вся система. Требуется кластеризация, резервирование и высокая доступность.
2.  **Увеличение задержки ([[Latency|latency]])**. Каждый запрос проходит дополнительный сетевой прыжок, что добавляет накладные расходы. В высоконагруженных системах это может быть критично.
3.  **Сложность конфигурации и управления**. Шлюз требует тщательной настройки маршрутов, политик безопасности, правил трансформации. По мере роста числа сервисов конфигурация становится трудно поддерживаемой.
4.  **Риск «божественного» шлюза**. При централизации слишком большого количества логики шлюз превращается в монолитное ядро, замедляющее разработку и развёртывание.
5.  **Дополнительные расходы**. Развёртывание, масштабирование и эксплуатация шлюза требуют инфраструктурных и человеческих ресурсов.
6.  **Сложность сквозной трассировки**. Добавление промежуточного звена требует проброса идентификаторов корреляции и аккуратной настройки распределённой трассировки.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и эксплуатации API-шлюзов:

1.  **Разделение на внешний и внутренний шлюзы**. В крупных системах используются два слоя: внешний шлюз (периметр) отвечает за безопасность и приём трафика из интернета, внутренний шлюз — за маршрутизацию между микросервисами внутри доверенной сети.

2.  **[[Backend for Frontend|Серверная часть для конкретного интерфейса (Backend for Frontend, BFF)]]**. Для каждого типа клиентов (мобильное приложение, веб, сторонние API) создаётся отдельный шлюз, оптимизированный под их специфику. Это предотвращает распухание единого шлюза и позволяет независимо эволюционировать клиентским интерфейсам.

3.  **Декларативная конфигурация ([[Declarative Configuration|declarative configuration]])**. Правила маршрутизации, политики и фильтры описываются декларативно в YAML или JSON, хранятся в системе контроля версий и применяются через CI/CD. Это обеспечивает воспроизводимость и аудит изменений.

4.  **Использование [[Sidecar Proxy|sidecar-прокси]] и [[Service Mesh|сервисной сетки]]**. Внутренняя маршрутизация и сквозные функции между сервисами часто реализуются на уровне sidecar-прокси (Envoy, Linkerd, Istio), что освобождает API-шлюз от ответственности за межсервисное взаимодействие.

5.  **Неблокирующий ввод-вывод и асинхронность**. Современные шлюзы (Kong, NGINX, Envoy, Traefik) построены на асинхронных, событийно-ориентированных архитектурах, что позволяет эффективно обрабатывать тысячи одновременных соединений.

6.  **Поддержка [[GraphQL|GraphQL]] и агрегация**. Шлюз может выступать единой точкой для GraphQL-запросов, агрегируя данные из множества нижележащих REST или gRPC-сервисов.

7.  **Безопасность на периметре**. Шлюз реализует:
    *   терминирование TLS ([[TLS Termination|TLS termination]]);
    *   проверку [[JWT|JWT]] или API-ключей;
    *   ограничение частоты запросов по IP, пользователю или ключу;
    *   фильтрацию вредоносных запросов ([[Web Application Firewall|WAF]]).

8.  **Наблюдаемость ([[Observability|observability]])**. Шлюз генерирует структурированные логи, метрики (количество запросов, задержки, коды ответов) и распределённые трассировки для каждого проходящего запроса. Это обеспечивает единую точку мониторинга всего входящего трафика.

9.  **Версионирование и канареечные развёртывания ([[Canary Deployment|canary deployment]])**. Шлюз позволяет направлять часть трафика на новые версии сервисов для постепенного тестирования без влияния на всех пользователей.

10. **Интеграция с обнаружением сервисов ([[Service Discovery|service discovery]])**. Шлюз динамически получает список доступных экземпляров сервисов из реестра (Consul, etcd, Kubernetes API) и автоматически адаптируется к изменениям без перезагрузки.

11. **Документирование API через шлюз**. Шлюз часто предоставляет встроенный интерфейс для публикации спецификаций OpenAPI или Swagger UI, делая документацию доступной по единому адресу.

12. **Избегание бизнес-логики в шлюзе**. Шлюз не должен содержать логику, специфичную для предметной области; его ответственность ограничена технической координацией и сквозными функциями.

Таким образом, API-шлюз является критически важным инфраструктурным компонентом микросервисных архитектур, обеспечивающим унификацию доступа, безопасность и наблюдаемость. Его проектирование требует баланса между централизацией сквозных функций и сохранением автономии сервисов. Современные практики смещают акцент от монолитных шлюзов к специализированным BFF и интеграции с сервисными сетками, что позволяет масштабировать разработку и эксплуатацию независимо растущих команд и сервисов.