---
updated_at: 2026-02-12T16:11:21.472+10:00
---
## Принцип разделения интерфейса: специализация вместо универсальности

**Принцип разделения интерфейса** ({{Interface Segregation Principle|Interface Segregation Principle}}, ISP) — это принцип объектно-ориентированного проектирования, согласно которому клиенты не должны зависеть от [[Interface|интерфейсов]], которые они не используют. Вместо одного «толстого» интерфейса, содержащего множество методов для различных сценариев, следует создавать несколько узкоспециализированных интерфейсов, каждый из которых обслуживает конкретную группу клиентов.

Принцип разделения интерфейса является четвёртым принципом [[SOLID|SOLID]] и был сформулирован Робертом Мартином.

### Назначение
Применение принципа разделения интерфейса направлено на снижение связанности и повышение связности программных компонентов:

*   **Минимизация нежелательных зависимостей**. Клиент не должен быть вынужден зависеть от методов, которые он не вызывает. Такие зависимости приводят к принудительной перекомпиляции, повторному развёртыванию и потенциальным ошибкам при изменениях.
*   **Повышение читаемости и понятности**. Небольшие, сфокусированные интерфейсы легче понять и реализовать, чем громоздкие описания с десятками разнородных методов.
*   **Упрощение реализации**. Класс, реализующий узкий интерфейс, не должен предоставлять заглушки или пустые реализации для методов, не имеющих смысла в его контексте.
-   **Устойчивость к изменениям**. Изменение интерфейса, затрагивающее только одну группу клиентов, не влияет на другие группы, использующие выделенные интерфейсы.
-   **Поддержка принципа единственной ответственности**. Разделение интерфейсов естественным образом ведёт к разделению ответственности между реализующими классами.

### Ограничения
Применение принципа разделения интерфейса сопряжено с рядом практических ограничений:

1.  **Риск чрезмерной декомпозиции**. Стремление к максимальной специализации может привести к созданию множества мельчайших интерфейсов, что усложняет навигацию по коду и понимание общей картины.
2.  **Сложность композиции**. Клиенту, которому требуется функциональность из нескольких специализированных интерфейсов, приходится зависеть от нескольких абстракций и управлять их композицией.
3.  **Необходимость предвидения**. Оптимальное разделение интерфейсов требует понимания различных групп клиентов и их потребностей; ошибочное разделение может потребовать последующего рефакторинга.
4.  **Языковые ограничения**. Некоторые языки не поддерживают множественное наследование интерфейсов или имеют ограничения на реализацию нескольких интерфейсов с конфликтующими сигнатурами методов.
5.  **Соблазн создания интерфейсов с одним методом**. Хотя иногда это оправдано (функциональные интерфейсы, стратегии), повсеместное применение ведёт к избыточному количеству сущностей.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и реализации интерфейсов, соблюдающих ISP:

1.  **Выделение ролевых интерфейсов ([[Role Interface|role interface]])**. Интерфейс определяется не тем, какой класс его реализует, а тем, какую роль он играет для клиента. Клиент взаимодействует с объектом исключительно через роль, которая ему необходима в данном контексте.

2.  **Наследование интерфейсов ([[Interface Inheritance|interface inheritance]])**. Общий функционал выносится в базовый интерфейс, а специализированные — в производные. Клиент выбирает необходимый уровень абстракции.

3.  **Применение множественного наследования интерфейсов**. Класс может реализовать несколько узких интерфейсов, предоставляя различным клиентам только те роли, которые им требуются.

4.  **Обнаружение «толстых» интерфейсов**. Сигналы нарушения ISP:
    *   методы интерфейса в реализации выбрасывают `UnsupportedOperationException` или аналоги;
    *   клиенты передают объект, но используют лишь малую часть его методов;
    *   при изменении одного метода интерфейса приходится перекомпилировать и переразвёртывать несвязанные модули.

5.  **Адapters and Facades**. Если сторонняя библиотека предоставляет «толстый» интерфейс, создаётся адаптер, реализующий узкий интерфейс, требуемый клиентом, и делегирующий вызовы к библиотечному объекту.

6.  **[[Interface Segregation Principle|Комбинация с Dependency Inversion]]**. ISP и DIP работают совместно: клиент определяет интерфейс, который ему необходим, а поставщик реализует этот интерфейс. Это инвертирует традиционное направление зависимости.

7.  **Функциональные интерфейсы ([[Functional Interface|functional interface]])**. В современных языках интерфейсы с одним абстрактным методом (SAM) широко используются для представления функций, стратегий и обратных вызовов. Это крайняя степень применения ISP, оправданная при использовании лямбда-выражений.

8.  **Проектирование интерфейсов от клиентов**. Не следует проектировать интерфейс, исходя из того, какие методы может предоставить класс-реализация. Интерфейс проектируется исходя из потребностей клиентов; реализация подстраивается под интерфейс.

9.  **Документирование ролей**. Каждый интерфейс сопровождается описанием его назначения и ожидаемого контракта, что помогает разработчикам правильно его реализовывать и использовать.

10. **Тестирование изолированно**. Узкие интерфейсы упрощают создание [[Test Double|тестовых заглушек]], поскольку реализовать нужно лишь небольшое количество методов.

11. **Эволюционное разделение**. Допустимо начинать с единого интерфейса и разделять его по мере выявления различных групп клиентов или появления несвязанных методов, реализация которых становится проблематичной.

Таким образом, принцип разделения интерфейса дисциплинирует проектирование абстракций, делая их точными, сфокусированными и удобными как для реализации, так и для использования. Его систематическое применение предотвращает создание «божественных» интерфейсов, снижает связанность и повышает устойчивость системы к изменениям. В сочетании с принципом инверсии зависимостей ISP формирует основу для гибких, слабо связанных архитектур.