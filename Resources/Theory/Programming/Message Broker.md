---
updated_at: 2026-02-12T14:06:23.011+10:00
---
**Брокер сообщений** ({{Message Broker|message broker}}) — это промежуточное программное обеспечение, обеспечивающее асинхронную передачу сообщений между различными компонентами распределённой системы. Брокер принимает сообщения от [[Producer|производителей]] (издателей), сохраняет их и доставляет [[Consumer|потребителям]] (подписчикам) в соответствии с заданными правилами маршрутизации и гарантиями доставки.

Брокеры сообщений являются центральным элементом событийно-ориентированных архитектур и служат альтернативой прямому синхронному взаимодействию через HTTP или RPC.

### Назначение
Внедрение брокера сообщений решает комплекс задач, возникающих в распределённых системах:

*   **Слабая связанность**. Производители и потребители не знают о существовании друг друга; им известен только брокер и формат сообщений. Это позволяет независимо изменять, масштабировать и развёртывать компоненты.
*   **Буферизация и сглаживание пиков**. Брокер выступает буфером, накапливая сообщения, если потребители временно не справляются с нагрузкой. Это предотвращает потерю данных и отказ системы при резких всплесках трафика.
*   **Надёжность и гарантии доставки**. Брокеры поддерживают различные уровни гарантий: at-most-once, at-least-once, exactly-once. Сообщения могут сохраняться на диск, реплицироваться и восстанавливаться после сбоев.
*   **Маршрутизация и трансформация**. Брокер может направлять сообщения в разные очереди или топики на основе заголовков или содержимого, а также преобразовывать форматы сообщений.
*   **Масштабирование потребителей**. Несколько экземпляров потребителей могут параллельно обрабатывать сообщения из одной очереди, обеспечивая горизонтальное масштабирование обработки.
*   **Интеграция гетерогенных систем**. Брокеры часто предоставляют адаптеры для различных протоколов (AMQP, MQTT, STOMP) и технологий, выступая универсальным мостом между устаревшими и современными системами.

### Ограничения
Применение брокеров сообщений сопряжено с рядом неизбежных сложностей и компромиссов:

1.  **Инфраструктурная сложность**. Брокер становится критически важным компонентом, требующим собственного развёртывания, мониторинга, резервирования и обслуживания. Отказ брокера может парализовать всю систему.
2.  **Увеличение задержки**. Каждое сообщение проходит дополнительный сетевой прыжок и, возможно, запись на диск, что увеличивает латентность по сравнению с прямым вызовом.
3.  **Сложность гарантий доставки**. Реализация exactly-once доставки требует координации между брокером, производителем и потребителем, включая дедупликацию и идемпотентную обработку, что существенно усложняет прикладной код.
4.  **Проблемы с порядком сообщений**. При параллельной обработке или масштабировании разделов сохранение глобального порядка сообщений становится нетривиальной задачей, часто требующей компромиссов.
5.  **Операционные издержки**. Необходимо управлять пропускной способностью, размерами очередей, политиками устаревания сообщений, контролировать разрастание логов.
6.  **Семантическая сложность**. Различные брокеры используют разные модели (очереди, топики, группы потребителей, разделы), что требует изучения специфики конкретной реализации.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к эффективному использованию брокеров сообщений:

1.  **Выбор модели взаимодействия**. Определяется сценарий использования:
    *   **[[Point-to-Point|Точка-точка]] (очереди)** — каждое сообщение обрабатывается ровно одним потребителем. Подходит для распределения задач (work queues).
    *   **[[Publish-Subscribe|Издатель-подписчик]] (топики)** — каждое сообщение доставляется всем подписанным потребителям. Используется для широковещательных уведомлений и событий.

2.  **Выбор брокера под нагрузку и требования**. Нет универсального решения:
    *   **RabbitMQ** — классический брокер с богатой маршрутизацией, поддержкой AMQP, подходит для сложных сценариев маршрутизации.
    *   **Apache Kafka** — распределённая платформа потоковых событий, оптимизирована для высоких объёмов, долговременного хранения и воспроизведения сообщений.
    *   **NATS** — лёгкий, высокопроизводительный брокер с гарантиями at-most-once / at-least-once, минимальной задержкой.
    *   **Amazon SQS / SNS** — полностью управляемые облачные сервисы, снимающие операционные издержки.

3.  **Схемы и контракты**. Для обеспечения совместимости форматы сообщений описываются декларативно (JSON Schema, Avro, Protobuf). В крупных системах внедряется [[Schema Registry|реестр схем]], проверяющий совместимость версий при публикации.

4.  **Идемпотентность потребителей**. Поскольку при использовании гарантии at-least-once возможны повторные доставки, обработчики сообщений проектируются [[Idempotency|идемпотентными]]: повторное применение одного сообщения не изменяет состояние системы.

5.  **Мёртвые письма ([[Dead Letter Queue|DLQ]])**. Необрабатываемые сообщения (ошибки валидации, исчерпание попыток) направляются в специальную очередь мёртвых писем для последующего анализа и ручного вмешательства. Это предотвращает бесконечные повторы и потерю данных.

6.  **Мониторинг и наблюдаемость**. Контролируются ключевые метрики: глубина очереди, скорость поступления/обработки, возраст сообщений, количество повторных попыток и ошибок. Выход метрик за пределы нормативов инициирует оповещения.

7.  **Трассировка распределённых запросов**. В сообщения включаются [[Correlation ID|идентификаторы корреляции]] и заголовки трассировки (W3C TraceContext), что позволяет отслеживать путь события через всю систему и связывать с входящими запросами.

8.  **Ограничение размера сообщения**. Крупные сообщения (например, файлы) передаются не через брокер, а через объектное хранилище; в брокер направляется только ссылка на ресурс. Это предотвращает перегрузку брокера и деградацию производительности.

9.  **Партиционирование и ключи упорядочения**. В Kafka и аналогичных системах порядок сообщений гарантируется внутри одного раздела. Для сохранения порядка обработки событий одного агрегата (заказ, пользователь) сообщения направляются в один раздел на основе ключа (например, `order_id`).

10. **Обработка ошибок и повторные попытки**. Реализуется стратегия повторных попыток с экспоненциальной задержкой и ограниченным числом ретраев. Критически важно различать временные ошибки (сетевые сбои, недоступность БД) и постоянные (невалидные данные, нарушение бизнес-правил).

11. **Безопасность**. Внедряется аутентификация клиентов (TLS-сертификаты, SASL) и авторизация доступа к очередям/топикам. Чувствительные данные могут шифроваться на стороне производителя перед отправкой.

12. **Тестирование**. Для изолированного тестирования потребителей используются эмуляторы брокера (Testcontainers, Embedded Kafka) или поднятие тестового экземпляра. Контрактное тестирование (Pact) проверяет совместимость форматов сообщений между производителем и потребителем.

Таким образом, брокер сообщений является фундаментальным строительным блоком современных распределённых и событийно-ориентированных систем. Его применение требует осознанного выбора модели доставки, дисциплины в проектировании контрактов и зрелой эксплуатационной инфраструктуры, но взамен предоставляет масштабируемость, отказоустойчивость и слабую связанность, недостижимые при синхронном взаимодействии.