---
updated_at: 2025-12-12T14:53:46.994+10:00
tags:
  - part2
  - chapter9
---
В главах 5–8 представлены тактические паттерны проектирования, определяющие различные способы реализации компонентов системы и показывающие, как смоделировать бизнес-логику и как архитектурно организовать внутреннюю часть ограниченного контекста. В этой главе нам предстоит выйти за пределы одного компонента и рассмотреть паттерны организации информационных потоков между элементами системы.

Паттерны, рассматриваемые в этой главе, упрощают межконтекстное взаимодействие с данными, устраняют ограничения, налагаемые принципами проектирования агрегатов, и выполняют диспетчеризацию бизнес-процессов, охватывающих несколько системных компонентов.

## Преобразование моделей

Ограниченный контекст является границей модели — единого языка (`ubiquitous language`). Из главы 3 известно, что для проектирования взаимодействия между разными ограниченными контекстами имеются разные паттерны. Предположим, что команды, реализующие два ограниченных контекста, свободно общаются и готовы к сотрудничеству. В этом случае ограниченные контексты могут быть интегрированы в партнерство: протоколы могут координироваться на разовой основе, а любые вопросы интеграции могут быть оперативно решены посредством общения между командами. Другой метод интеграции, основанный на сотрудничестве — создание общего ядра (`shared kernel`): команды извлекают и совместно разрабатывают небольшую часть модели; например, извлечение контрактов из интегрированных ограниченных контекстов в совместно используемый репозиторий.

В отношениях клиент-поставщик (`customer-supplier`) баланс сил склоняется либо к восходящему (поставщику (`supplier`)), либо к нисходящему (потребителю (`consumer`)) ограниченному контексту. Предположим, что нисходящий ограниченный контекст не может соответствовать модели восходящего ограниченного контекста. В таком случае потребуется более сложное техническое решение, способное упростить взаимодействие путем преобразования моделей ограниченных контекстов. 

Такое преобразование может выполняться одной, а иногда и обеими сторонами: ограниченный контекст нижестоящего компонента может приспособить модель ограниченного контекста вышестоящего компонента к своим потребностям с помощью предохранительного слоя (`anticorruption layer, ACL`), а ограниченный контекст вышестоящего компонента может действовать как сервис с открытым протоколом (`open-host service, OHS`) и защитить своих потребителей от изменений в модели реализации с помощью интеграционного опубликованного языка (`integration-specific published language`). Поскольку логика преобразования одинакова как для предохранительного слоя (`anticorruption layer`), так и для сервиса с открытым протоколом (`open-host service`), в этой главе рассматриваются варианты реализации безотносительно различий между паттернами, а различия упоминаются только в исключительных случаях.

Логика преобразования модели может быть либо без сохранения, либо с сохранением состояния. Преобразование без сохранения состояния происходит «на лету» при выполнении входящих (`OHS`) или исходящих (`ACL`) запросов, а преобразование с отслеживанием состояния включает более сложную логику преобразования, для которой требуется база данных. Давайте рассмотрим паттерны проектирования для реализации обоих типов преобразования моделей.

## Преобразование моделей без сохранения состояния

Для преобразования моделей без сохранения состояния в ограниченном контексте, которому принадлежит преобразование (`OHS` для вышестоящего компонента, `ACL` для нижестоящего компонента), реализуется паттерн проектирования прокси (`proxy`) для перехвата входящих и исходящих запросов и сопоставления исходной модели с целевой моделью ограниченного контекста. Все это показано на рис. 9.1. Рис. 9.1. Преобразование моделей через прокси

![[Рис. 9.1. Преобразование моделей через прокси.png]]

Реализация прокси зависит от того, в каком режиме осуществляется взаимодействие между ограниченными контекстами, в синхронном или в асинхронном.

### Синхронный режим

Как показано на рис. 9.2, типичным способом преобразования моделей, используемым при синхронном режиме взаимодействия, является встраивание логики преобразования в кодовую базу ограниченного контекста. В сервисе с открытым протоколом (`open-host service`) преобразование в публичный язык происходит при обработке входящих запросов, а на уровне предохранительного слоя (`anticorruption layer`) — при вызове вышестоящего ограниченного контекста.

![[Рис. 9.2. Синхронный режим обмена данными.png]]

Иногда более экономичным и удобным вариантом может стать перенос логики преобразования на внешний компонент, например на паттерн API-шлюза (`API Gateway`). Этот компонент (`API`-шлюз, `API Gateway`) может быть программным решением с открытым исходным кодом, как, к примеру, `Kong` или `KrakenD` или же управляемой службой облачного провайдера, такой как `AWS API Gateway`, `Google Apigee` или `Azure API Management`.

Для ограниченных контекстов, реализующих паттерн сервиса с открытым протоколом (`open-host service`) `API`-шлюз (`API Gateway`), за преобразование внутренней модели в опубликованный язык отвечает язык (`published language`), оптимизированный для интеграции. Кроме того, как показано на рис. 9.3, наличие явного `API`-шлюза (`API Gateway`) может облегчить процесс управления и сопровождения нескольких версий `API` ограниченного контекста. 

![[Рис. 9.3. Выставление различных версий опубликованного языка.png]]

Предохранительный слой (`anticorruption layer`), реализованный с помощью `API`-шлюза, может использоваться несколькими нижестоящими ограниченными контекстами. В таких случаях, как показано на рис. 9.4, предохранительный слой (`anticorruption layer`) действует как ограниченный контекст, специально предназначенный для интеграции. 

Такие ограниченные контексты, отвечающие в основном за преобразование моделей для более удобного использования другими компонентами, часто называют контекстами обмена.

![[Рис. 9.4. Совместно используемый предохранительный слой (anticorruption layer).png]]

### Асинхронный режим

Для преобразования моделей, используемых в режиме асинхронного обмена данными, можно реализовать прокси: промежуточный компонент, подписывающийся на сообщения, поступающие из исходного ограниченного контекста. Прокси-сервер выполнит все необходимые преобразования модели и перешлет полученные сообщения целевому подписчику (рис. 9.5). 

![[Рис. 9.5. Преобразование моделей при асинхронном режиме обмена данными.png]]

Помимо преобразования модели сообщений, проксирующий компонент также может уменьшить шум в целевом ограниченном контексте, отфильтровывая ненужные сообщения.

Преобразование модели в асинхронном режиме необходимо при реализации службы с открытым хостом. Весьма распространенной ошибкой является разработка и предоставление опубликованного языка (`published language`) для объектов модели и разрешение публикации событий предметной области в их исходном виде, что раскрывает модель реализации ограниченного контекста. Преобразование в асинхронном режиме можно использовать для перехвата событий предметной области и преобразования их в опубликованный язык (`published language`) — это обеспечит более надежную инкапсуляцию деталей реализации ограниченного контекста (рис. 9.6).

Кроме того, перевод сообщений на опубликованный язык (`published language`) позволяет различать закрытые события, предназначенные для внутренних потребностей ограниченного контекста, и открытые события, предназначенные для интеграции с другими ограниченными контекстами. Более широкое рассмотрение темы внутренних и публичных сообщений будет представлено в главе 15, посвященной взаимосвязи предметно-ориентированного проектирования и событийно-ориентированной архитектуры.

![[Рис. 9.6. События предметной области на опубликованном языке.png]]

### Преобразование моделей с отслеживанием состояния

Для более существенных преобразований моделей, например, когда механизм преобразования должен агрегировать исходные данные или объединить данные из нескольких источников в единую модель, может потребоваться преобразование с отслеживанием состояния. Давайте подробно обсудим каждый из этих вариантов использования.

#### Агрегирование входящих данных

Допустим, что для оптимизации производительности ограниченный контекст заинтересован в агрегировании входящих запросов и их пакетной обработке. В этом случае агрегирование может потребоваться для всех запросов, получаемых как в синхронном, так и в асинхронном режиме (см. рис. 9.7). 

![[Рис. 9.7. Пакетирование запросов.png]]

Другим распространенным вариантом агрегирования исходных данных является объединение нескольких детализированных сообщений в одно сообщение, содержащее унифицированные данные (см. рис. 9.8). 

![[Рис. 9.8. Объединение входящих событий.png]]

Преобразование модели с накоплением входящих данных не может быть реализовано с помощью API-шлюза (`API Gateway`), поэтому здесь требуется более сложная обработка с отслеживанием состояния. Для отслеживания входящих данных и соответствующей их обработки логике преобразования требуется собственное постоянное хранилище (рис. 9.9).

![[Рис. 9.9. Преобразование модели с отслеживанием состояния.png]]

В некоторых случаях для преобразования с отслеживанием состояния можно вместо создания собственного решения воспользоваться готовыми продуктами, например платформой потоковой обработки (`Kafka`, `AWS Kinesis` и т. д.) или решением для пакетной обработки (`Apache NiFi`, `AWS Glue`, `Spark` и т. д.).

#### Объединение нескольких источников

В ограниченном контексте может потребоваться обработка данных, накопленных сразу из нескольких источников, включая и те, что поступают из других ограниченных контекстов. Типичным примером такой обработки является применение паттерна backend-for-frontend, в котором пользовательский интерфейс должен объединять данные, поступающие сразу от нескольких сервисов.

Еще один пример — ограниченный контекст, который должен обрабатывать данные из множества других контекстов и реализовывать сложную бизнес-логику для обработки всех данных. В этом случае может быть полезно разделить сложности интеграции и бизнес-логики, покрывая ограниченный контекст предохранительным слоем (`anticorruption layer`), накапливающим данные из всех других ограниченных контекстов (рис. 9.10).

![[Рис. 9.10. Упрощение модели интеграции с использованием паттерна уровня защиты от изменений.png]]

### Интеграция агрегатов

В главе 6 уже говорилось, что одним из способов взаимодействия между агрегатами и всей остальной системой является публикация событий предметной области. Внешние компоненты могут подписываться на эти события предметной области и выполнять свою логику. Но как происходит публикация событий предметной области в шине сообщений?

Прежде чем перейти к решению, давайте разберем несколько распространенных ошибок, допускаемых в процессе публикации событий, и последствия каждого такого подхода. Рассмотрим следующий код:

```java
01 public class Campaign
02 {
03 ...
04 List<DomainEvent> _events;
05 IMessageBus _messageBus;
06 ...
07
08 public void Deactivate(string reason)
09 {
10 for (l in _locations.Values())
11 {
12 l.Deactivate();
13 }
14
15 IsActive = false;
16
17 var newEvent = new CampaignDeactivated(_id, reason);
18 _events.Append(newEvent);
19 _messageBus.Publish(newEvent);
20 }
21 }
```

В строке 17 создается экземпляр нового события. В следующих двух строках событие добавляется к внутреннему списку событий предметной области агрегата (строка 18) и публикуется в шине сообщений (строка 19). Эта реализация публикации событий предметной области проста, но неприемлема. Публикация события предметной области прямо из агрегата плоха по двум причинам:

Во-первых, событие будет отправлено до того, как новое состояние агрегата будет зафиксировано в базе данных. Подписчик может получить уведомление о деактивации кампании, но это будет противоречить состоянию этой кампании.

Во-вторых, что если транзакцию базы данных не удастся зафиксировать из-за состояния гонки (`race condition`), последующей логики накопления, делающей операцию недействительной, или просто из-за технической проблемы в базе данных? Несмотря на откат транзакции базой данных, событие уже опубликовано и передано подписчикам, и отменить его невозможно.

Давайте попробуем другой вариант:

```java
01 public class ManagementAPI
02 {
03 ...
04 private readonly IMessageBus _messageBus;
05 private readonly ICampaignRepository _repository;
06 ...
07 public ExecutionResult DeactivateCampaign(CampaignId id, string reason)
08 {
09 try
10 {
11 var campaign = repository.Load(id);
12 campaign.Deactivate(reason);
13 _repository.CommitChanges(campaign);
14
15 var events = campaign.GetUnpublishedEvents();
16 for (IDomainEvent e in events)
17 {
18 _messageBus.publish(e);
19 }
20 campaign.ClearUnpublishedEvents();
21 }
22 catch(Exception ex)
23 {
24 ...
25 }
26 }
27 }
```

В показанном выше листинге ответственность за публикацию новых событий предметной области перенесена на прикладной уровень. В строках 11–13 загружается соответствующий экземпляр агрегата `Campaign`, выполняется его команда `Deactivate`, и только после того, как обновленное состояние успешно зафиксировано в базе данных, в строках с 15 по 20 новые события предметной области публикуются на шине сообщений. Но можно ли довериться этому коду? Нет, нельзя.

В данном случае процесс, выполняющий логику, по какой-то причине может не опубликовать события предметной области. Возможно, шина сообщений не работает. Или сервер, на котором выполняется код, дает сбой сразу после фиксации транзакции базы данных, но перед публикацией событий система все равно будет находиться в несогласованном состоянии, что означает, что транзакция базы данных зафиксирована, но события предметной области никогда не будут опубликованы.

Все эти крайности можно обойти с помощью паттерна исходящих сообщений.

### Паттерн исходящих сообщений (`Outbox`)

Паттерн исходящих сообщений (рис. 9.11) обеспечивает надежную публикацию событий предметной области по следующему алгоритму:

 - Состояния обновленного агрегата и новые события предметной области фиксируются в одной и той же атомарной транзакции.
 - Ретранслятор сообщений извлекает только что зафиксированные события предметной области из базы данных.
 - Ретранслятор публикует события предметной области на шине сообщений.
 - При успешной публикации ретранслятор либо помечает события как опубликованные в базе данных, либо полностью их удаляет.

![[Рис. 9.11. Паттерн исходящих сообщений.png]]

При использовании реляционной базы данных лучше воспользоваться ее способностью атомарно фиксировать две таблицы и применить для хранения сообщений специально выделенную таблицу (см. рис. 9.12). 

![[Рис. 9.12. Таблица исходящих сообщений.png]]

При использовании базы данных `NoSQL`, которая не поддерживает транзакции с несколькими документами, исходящие события предметной области должны быть встроены в запись агрегата. Например:

```json
{
 "campaign-id": "364b33c3-2171-446d-b652-8e5a7b2be1af",
 "state": {
   "name": "Autumn 2017", 
   "publishing-state": "DEACTIVATED",
   "ad-locations": [
     ...
   ]
   ...
 },
 "outbox": [
   {
     "campaign-id": "364b33c3-2171-446d-b652-8e5a7b2be1af",
     "type": "campaign-deactivated",
     "reason": "Goals met",
     "published": false
   }
 ]
}
```

В этом примере можете заметить дополнительное свойство JSON-документа, `outbox`, содержащее список событий предметной области, подлежащих публикации.

#### Извлечение неопубликованных событий

Публикующий ретранслятор (`publishing relay`) может извлекать новые события предметной области как по запросу (`pull-based`), так и по уведомлению (`push-based`):

*   **Pull: запрос к поставщику (`producer`)**  
    Ретранслятор может постоянно запрашивать базу данных на предмет неопубликованных событий. Чтобы нагрузку на базу данных, вызванную постоянными запросами, свести к минимуму, нужно создать надлежащие индексы.

*   **Push: отслеживание журнала транзакций**  
    Здесь для упреждающего вызова публикующего ретранслятора (`publishing relay`) при добавлении новых событий можно воспользоваться набором функций базы данных. Например, некоторые реляционные базы данных позволяют получать уведомления об обновленных или вставленных записях путем отслеживания журнала транзакций базы данных. А некоторые базы данных `NoSQL` представляют зафиксированные изменения в виде потоков событий (например, `AWS DynamoDB Streams`).

Важно отметить, что паттерн исходящих сообщений (`outbox pattern`) гарантирует как минимум однократную (`at least once`) доставку сообщений: если ретранслятор выйдет из строя сразу после публикации сообщения, но до того, как оно будет помечено в базе данных как опубликованное, это же сообщение будет опубликовано снова при следующей итерации.

Далее будет рассмотрен способ использования надежной публикации событий предметной области для преодоления некоторых ограничений, налагаемых принципами проектирования агрегатов.

### Сага

Один из основных принципов построения агрегатов заключается в ограничении каждой транзакции одним экземпляром агрегата. Тем самым гарантируется, что границы агрегата будут тщательно продуманы и инкапсулированы в согласованный набор бизнес-функций. Но бывают случаи, когда нужно реализовать бизнес-процесс, охватывающий сразу несколько агрегатов.

Рассмотрим следующий пример: при активации рекламная кампания должна автоматически отправлять свои рекламные материалы своему издателю. После получения подтверждения от издателя статус публикации кампании должен измениться на `Published` (Опубликовано). В случае отклонения издателем кампания должна быть помечена как `Rejected` (Отклонено).

Эта последовательность действий охватывает две бизнес-сущности: рекламную кампанию и издательство. Совместное размещение сущностей в одной и той же границе агрегата определенно было бы излишним, поскольку это реально разные бизнес-сущности, которые имеют разные обязанности и могут принадлежать к разным ограниченным контекстам. Вместо этого данная последовательность действий может быть реализована в виде саги.

Под сагой понимается длительный бизнес-процесс. И речь здесь не обязательно о времени, поскольку саги могут длиться от нескольких секунд до нескольких лет, а скорее о транзакциях, а еще точнее, о бизнес-процессе, охватывающем сразу несколько транзакций. Транзакции могут обрабатываться не только агрегатами, но и любым компонентом, генерирующим события предметной области и отвечающим на команды. Сага отслеживает события, генерируемые соответствующими компонентами, и выдает последующие команды другим компонентам. Если один из шагов выполнения завершается с ошибкой, сага отвечает за запуск соответствующих компенсирующих действий, чтобы гарантировать, что состояние системы остается согласованным.

Давайте посмотрим, как процесс публикации рекламной кампании из предыдущего примера можно реализовать в виде саги (см. рис. 9.13). 

![[Рис. 9.13. Сага.png]]

Чтобы реализовать процесс публикации, сага должна отслеживать событие `CampaignActivated` из агрегата `Campaign` и события `PublishingConfirmed` и `PublishingRejected` из ограниченного контекста `AdPublishing`. Сага должна выполнить команду `SubmitAdvertisement` для `AdPublishing` и команды `TrackPublishingConfirmation` и `TrackPublishingRejection` для агрегата `Campaign`. В этом примере команда `TrackPublishingRejection` является компенсирующим действием, гарантирующим, что рекламная кампания не будет указана как активная. Рассмотрим код:

```java
public class CampaignPublishingSaga
{
 private readonly ICampaignRepository _repository;
 private readonly IPublishingServiceClient _publishingService;
 ...
 public void Process(CampaignActivated @event)
 {
   var campaign = _repository.Load(@event.CampaignId);
   var advertisingMaterials = campaign.GenerateAdvertisingMaterials();
   _publishingService.SubmitAdvertisement(@event.CampaignId, advertisingMaterials);
 }
 public void Process(PublishingConfirmed @event)
 {
   var campaign = _repository.Load(@event.CampaignId);
   campaign.TrackPublishingConfirmation(@event.ConfirmationId);
   _repository.CommitChanges(campaign);
 }
 public void Process(PublishingRejected @event)
 {
   var campaign = _repository.Load(@event.CampaignId);
   campaign.TrackPublishingRejection(@event.RejectionReason);
   _repository.CommitChanges(campaign);
 }
}
```

В показанном выше примере для доставки соответствующих событий и реакции на них с выполнением соответствующих команд используется инфраструктура обмена сообщениями. Это пример относительно простой саги, поскольку она не работает с состояниями. Но нередко попадаются саги, требующие управления состоянием: например, для отслеживания выполненных операций, чтобы в случае сбоя можно было принять соответствующие компенсирующие меры. В такой ситуации сага может быть реализована как агрегат, основанный на событиях, сохраняющий полную историю полученных событий и отправленных команд. Но логика выполнения команды должна быть вынесена за пределы самой саги и выполняться асинхронно, наподобие отправки событий предметной области в паттерне исходящих сообщений:

```java
public class CampaignPublishingSaga
{
 private readonly ICampaignRepository _repository;
 private readonly IList<IDomainEvent> _events;
 ...
 public void Process(CampaignActivated activated)
 {
   var campaign = _repository.Load(activated.CampaignId);
   var advertisingMaterials = campaign.GenerateAdvertisingMaterials();
   var commandIssuedEvent = new CommandIssuedEvent(
     target: Target.PublishingService,
     command: new SubmitAdvertisementCommand(activated.CampaignId,
     advertisingMaterials));
   _events.Append(activated);
   _events.Append(commandIssuedEvent);
 }
 public void Process(PublishingConfirmed confirmed)
 {
   var commandIssuedEvent = new CommandIssuedEvent(
     target: Target.CampaignAggregate,
     command: new TrackConfirmation(confirmed.CampaignId, confirmed.ConfirmationId));
   _events.Append(confirmed);
   _events.Append(commandIssuedEvent);
 }
 public void Process(PublishingRejected rejected)
 {
   var commandIssuedEvent = new CommandIssuedEvent(
     target: Target.CampaignAggregate,
     command: new TrackRejection(rejected.CampaignId, rejected.RejectionReason));
   _events.Append(rejected);
   _events.Append(commandIssuedEvent);
 }
}
```

В этом примере ретранслятор исходящих сообщений должен будет выполнять команды на соответствующих приемниках (`endpoints`) для каждого экземпляра `CommandIssuedEvent`. Как и в случае с публикацией событий предметной области, отделение перехода состояния саги от выполнения команд гарантирует стабильное выполнение команд даже при завершении процесса ошибкой на любом этапе.

### Согласованность

Несмотря на то что сага управляет транзакцией, которая включает изменение нескольких компонентов, состояние изменяемых компонентов в конечном счете подчиняется принципу согласованности (син. итоговая согласованность, `eventual consistency`). И хотя сага в конечном итоге выполнит соответствующие команды, никакие две транзакции нельзя считать атомарными. Это соотносится с еще одним принципом построения агрегатов:

> *Строго согласованными можно считать только данные в пределах границ агрегата. А все, что вне этих границ, может считаться согласованным только в конечном счете.*

Воспользуйтесь этим обстоятельством в качестве руководящего принципа, чтобы убедиться в отсутствии злоупотребления сагами с целью компенсации неверно выбранных границ агрегатов. Бизнес-операции, которые должны принадлежать одному агрегату, требуют строго согласованных данных.

Сагу часто путают с паттерном диспетчера процессов. Хотя их реализации похожи, они весьма различны. В следующем разделе будут рассмотрены назначение паттерна диспетчера процессов и его отличия от паттерна саги.

### Диспетчер процессов

Сага управляет простым линейным потоком действий. Строго говоря, сага сопоставляет события соответствующим командам. В примерах, использованных для демонстрации реализации саги, в действительности происходила реализация простого сопоставления событий с командами:

*   Событие `CampaignActivated` для команды `PublishingService.SubmitAdvertisement`.
*   Событие `PublishingConfirmed` для команды `Campaign.TrackConfirmation`.
*   Событие `PublishingRejected` для команды `Campaign.TrackRejection`.

Паттерн диспетчера процессов, показанный на рис. 9.14, предназначен для реализации процесса, основанного на бизнес-логике. Он определяется как центральный процессор, поддерживающий состояние последовательности и определяющий следующие этапы обработки.

Как правило, если сага для выбора правильного курса действий содержит инструкции `if-else`, то это, скорее всего, диспетчер процессов.

Еще одно отличие диспетчера процессов от саги заключается в том, что экземпляр саги создается неявно при отслеживании определенного события, как в `CampaignActivated` в предыдущих примерах. А вот диспетчер процессов не может быть привязан к одному исходному событию. Наоборот, это последовательный бизнес-процесс, состоящий из нескольких шагов. Следовательно, диспетчер процессов должен быть создан явным образом. Рассмотрим следующий пример: 

![[Рис. 9.14. Диспетчер процессов.png]]

Бронирование мест для командировки начинается с того, что по алгоритму маршрутизации выбирается наиболее экономичный маршрут полета и сотруднику поступает просьба о его утверждении. Если сотрудник предпочитает другой маршрут, его должен одобрить непосредственный руководитель этого сотрудника. После бронирования рейса необходимо забронировать один из предварительно утвержденных отелей на соответствующие даты. Если нет доступных отелей, билеты на самолет должны быть аннулированы.

В этом примере нет центрального объекта, инициирующего процесс бронирования поездки. Бронирование мест — это процесс, и он должен быть реализован как менеджер процессов (рис. 9.15). 

![[Рис. 9.15. Диспетчер бронирования.png]]

С позиции реализации диспетчеры процессов часто создаются в виде агрегатов, основанных либо на состояниях, либо на событиях. Например:

```java
public class BookingProcessManager
{
 private readonly IList<IDomainEvent> _events; 
 private BookingId _id;
 private Destination _destination;
 private TripDefinition _parameters;
 private EmployeeId _traveler;
 private Route _route;
 private IList<Route> _rejectedRoutes;
 private IRoutingService _routing;
 ...
 public void Initialize(Destination destination,
 TripDefinition parameters,
 EmployeeId traveler)
 {
   _destination = destination;
   _parameters = parameters;
   _traveler = traveler;
   _route = _routing.Calculate(destination, parameters);
   var routeGenerated = new RouteGeneratedEvent(
     BookingId: _id,
     Route: _route);
   var commandIssuedEvent = new CommandIssuedEvent(
     command: new RequestEmployeeApproval(_traveler, _route)
   );
   _events.Append(routeGenerated);
   _events.Append(commandIssuedEvent);
 }
 public void Process(RouteConfirmed confirmed)
 {
   var commandIssuedEvent = new CommandIssuedEvent(
     command: new BookFlights(_route, _parameters)
   );
   _events.Append(confirmed);
   _events.Append(commandIssuedEvent);
 }
 public void Process(RouteRejected rejected)
 {
   var commandIssuedEvent = new CommandIssuedEvent(
     command: new RequestRerouting(_traveler, _route)
   );
   _events.Append(rejected);
   _events.Append(commandIssuedEvent);
 } 
 public void Process(ReroutingConfirmed confirmed)
 {
   _rejectedRoutes.Append(route);
   _route = _routing.CalculateAltRoute(destination, parameters, rejectedRoutes);
   var routeGenerated = new RouteGeneratedEvent(
     BookingId: _id,
     Route: _route);
   var commandIssuedEvent = new CommandIssuedEvent(
     command: new RequestEmployeeApproval(_traveler, _route)
   );
   _events.Append(confirmed);
   _events.Append(routeGenerated);
   _events.Append(commandIssuedEvent);
 }
 public void Process(FlightBooked booked)
 {
   var commandIssuedEvent = new CommandIssuedEvent(
     command: new BookHotel(_destination, _parameters)
   );
   _events.Append(booked);
   _events.Append(commandIssuedEvent);
 }
 ...
}
```

В этом примере диспетчер процессов имеет свой явно указанный идентификатор и постоянное состояние, описывающее поездку, требующую бронирования. Как и в предыдущем примере саги, диспетчер процессов подписывается на события, управляющие рабочим процессом (`RouteConfirmed`, `RouteRejected`, `ReroutingConfirmed` и т. д.), и создает экземпляры событий типа `CommandIssuedEvent`, которые будут обрабатываться ретранслятором исходящих сообщений для выполнения конкретных команд.

### Вывод

В этой главе рассматривались различные паттерны интеграции компонентов системы. Глава началась с изучения паттернов для преобразования моделей, которые можно использовать для реализации предохранительного слоя (`anticorruption layer`) или сервисов с открытым протоколом (`open-host service`). Было показано, что преобразования могут осуществляться сходу или же следовать более сложной логике, требующей отслеживания состояний.

Паттерны исходящих сообщений (`outbox pattern`) являются надежным способом публикации событий предметной области, принадлежащих агрегатам. Они гарантируют четкую публикацию событий предметной области даже в случае сбоев различных процессов.

Сагу можно использовать для реализации простых бизнес-процессов, в которые вовлечено несколько компонентов. Более сложные бизнес-процессы могут быть реализованы с использованием паттерна диспетчера процессов. Оба паттерна основаны на асинхронных реакциях на события предметной области и отправке команд.