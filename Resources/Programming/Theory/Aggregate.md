---
updated_at: 2026-02-17T10:54:50.945+10:00
---
**Агрегат** ({{Aggregate|aggregate}}) — это кластер связанных объектов ([[Entity|сущностей]] и [[Value Object|объектов-значений]]), рассматриваемый как единое целое с точки зрения изменения данных. Агрегат гарантирует согласованность своих внутренних компонентов и защищает инварианты — бизнес-правила, которые должны всегда соблюдаться.

Каждый агрегат имеет корень ([[Aggregate Root|root]]), единственную сущность, через которую происходит доступ и модификация всех объектов внутри агрегата. Внешние компоненты могут ссылаться только на корень агрегата, но не на внутренние элементы.

### Назначение
Введение агрегатов решает ключевые задачи моделирования сложных предметных областей:

*   **Обеспечение транзакционной согласованности**. Агрегат определяет границы, в которых гарантируется атомарность и изоляция изменений. Все операции внутри одного агрегата выполняются в рамках одной транзакции.
*   **Упрощение модели**. Инкапсуляция сложных графов объектов за единой точкой входа снижает когнитивную нагрузку и предотвращает бесконтрольное связывание сущностей.
*   **Явное выражение инвариантов**. Агрегат содержит логику проверки и поддержания бизнес-правил, действующих для группы объектов.
*   **Масштабирование и распределение**. Чёткие границы агрегатов позволяют распределять данные по разным узлам, использовать [[Eventual Consistency|согласованность в конечном счёте]] между агрегатами и естественно отображаться на [[Microservices|микросервисы]].

### Ограничения
Применение агрегатов сопряжено с рядом трудностей и компромиссов:

1.  **Размер и производительность**. Слишком крупные агрегаты, включающие десятки и сотни объектов, создают узкое место: каждое изменение требует загрузки и сохранения всего агрегата целиком, что снижает пропускную способность.
2.  **Сложность проектирования**. Ошибочное выделение границ приводит либо к «гигантским» агрегатам с избыточной согласованностью, либо к излишне мелким, что вынуждает реализовывать сложные распределённые транзакции между ними.
3.  **Согласованность между агрегатами**. В [[Domain-Driven Design|предметно-ориентированном проектировании]] принято, что одна транзакция изменяет только один агрегат. Поддержание согласованности между несколькими агрегатами требует применения саг или других механизмов [[Eventual Consistency|согласованности в конечном счёте]], что сложнее ACID-транзакций.
4.  **Идентичность и ссылки**. Прямые ссылки на внутренние сущности агрегата извне разрушают инкапсуляцию и могут приводить к несогласованным изменениям. Требуется дисциплинированное использование идентификаторов вместо ссылок.
5.  **Конфликты при параллелизме**. При одновременном изменении одного агрегата несколькими пользователями или процессами возникают классические проблемы оптимистической блокировки, требующие версионирования или повторных попыток.

### Сложившиеся практики
Индустрия выработала устойчивый набор рекомендаций по проектированию и реализации агрегатов:

1.  **Проектирование от инвариантов**. Границы агрегата определяются бизнес-правилами, которые должны выполняться немедленно и атомарно. Если два объекта могут изменяться независимо без нарушения инвариантов, они должны находиться в разных агрегатах.

2.  **Маленькие агрегаты**. Предпочтительно стремиться к минимально возможному размеру. Идеальный агрегат содержит корень и небольшое число тесно связанных объектов-значений. Большинство агрегатов сводятся к одной сущности с несколькими атрибутами.

3.  **Ссылки по идентификатору ([[Identity|identity]])**. Агрегаты ссылаются друг на друга не напрямую, а через глобально уникальные идентификаторы корней. Это ослабляет связанность и позволяет размещать агрегаты в разных хранилищах.

4.  **Атомарность в пределах одного агрегата**. Транзакция никогда не должна изменять более одного агрегата. Если бизнес-процесс требует модификации нескольких агрегатов, он реализуется как [[Saga|сага]] с компенсирующими действиями.

5.  **Репозиторий только для корня ([[Repository (pattern)|repository]])**. Каждый агрегат имеет репозиторий, предоставляющий коллекционно-подобный доступ к корням. Внутренние объекты агрегата не имеют собственных репозиториев и не могут быть извлечены напрямую.

6.  **Загрузка целиком**. Агрегат должен загружаться из хранилища полностью; частичная загрузка нарушает инкапсуляцию и затрудняет проверку инвариантов. Это ограничение усиливает требование к небольшим размерам агрегатов.

7.  **Версионирование и оптимистическая блокировка**. Для обнаружения конфликтов параллельного изменения агрегат снабжается версией (или временной меткой). При сохранении версия проверяется, и при несовпадении транзакция отклоняется.

8.  **Использование объектов-значений**. Внутри агрегата предпочтение отдаётся неизменяемым [[Value Object|объектам-значениям]], а не сущностям. Это упрощает логику, исключает побочные эффекты и повышает тестируемость.

9.  **Моделирование команд в корне**. Все операции изменения агрегата выражаются как методы корня, явно проверяющие инварианты и порождающие [[Domain Event|события предметной области]]. Сеттеры и публичные поля не используются.

10. **Тестирование изолированно**. Агрегаты тестируются без обращения к инфраструктуре — репозиториям, базам данных, брокерам. Это гарантирует, что бизнес-логика корректна и не зависит от технических деталей.

Таким образом, агрегат является фундаментальным тактическим паттерном [[Domain-Driven Design|предметно-ориентированного проектирования]], позволяющим управлять сложностью за счёт явного определения границ согласованности. Успешное применение требует дисциплинированного следования инвариантам, осознанного выбора размера и последовательного использования идентификаторов для меж-агрегатных ссылок.