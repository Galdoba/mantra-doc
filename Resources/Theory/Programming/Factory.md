---
updated_at: 2026-02-12T17:42:33.106+10:00
---
## Фабрика: инкапсуляция создания объектов

**Фабрика** ({{Factory|factory}}) — это порождающий паттерн проектирования, делегирующий логику создания объектов специализированным классам или методам. Вместо прямого вызова [[Constructor|конструктора]] клиент запрашивает объект у фабрики, которая определяет конкретный тип и способ создания экземпляра. Существует несколько вариаций паттерна: **[[Factory Method|фабричный метод]]**, **[[Abstract Factory|абстрактная фабрика]]** и **[[Static Factory|статическая фабрика]]**.

### Назначение
Применение фабрик преследует цели отделения клиента от конкретных реализаций и централизации логики инстанцирования:

*   **Ослабление связанности ([[Decoupling|decoupling]])**. Клиент зависит от абстрактного интерфейса или базового класса, а не от конкретных классов продуктов. Это упрощает замену реализаций и расширение системы.
*   **Централизация сложной логики создания**. Если создание объекта требует инициализации зависимостей, выбора стратегии, чтения конфигурации или выполнения других подготовительных операций, эта логика инкапсулируется в фабрике, а не дублируется в клиентском коде.
*   **Управление жизненным циклом**. Фабрика может контролировать повторное использование объектов ([[Object Pool|пул объектов]]), кэширование или подсчёт ссылок.
*   **Сокрытие иерархий**. Клиент взаимодействует только с фабрикой и абстрактным продуктом; конкретные классы остаются скрытыми во внутренней реализации.
*   **Обеспечение соблюдения инвариантов**. Фабрика гарантирует, что созданные объекты находятся в корректном начальном состоянии.

### Ограничения
Применение фабрик сопряжено с рядом компромиссов:

1.  **Усложнение архитектуры**. Введение дополнительных классов и интерфейсов увеличивает общую сложность системы, что для простых сценариев может быть избыточно.
2.  **Смещение ответственности**. Неумеренное использование фабрик может привести к ситуации, когда «фабрики создаются фабриками», усложняя понимание потока управления.
3.  **Скрытие зависимостей**. Внедрение зависимостей через фабрику может маскировать реальные потребности класса; явный вызов конструктора с передачей зависимостей часто прозрачнее.
4.  **Невозможность статической проверки**. Некоторые реализации (особенно рефлективные фабрики) переносят ошибки с этапа компиляции на этап выполнения.
5.  **Избыточность для неизменяемых иерархий**. Если иерархия продуктов стабильна и редко расширяется, прямое использование конструкторов является более простым и читаемым решением.

### Сложившиеся практики
Индустрия выработала устойчивые подходы к реализации каждой вариации паттерна «Фабрика»:

1.  **[[Factory Method|Фабричный метод]]**. Базовый класс или интерфейс определяет метод создания объекта, а подклассы решают, экземпляр какого конкретного класса создавать. Широко используется в каркасах (фреймворках) для предоставления точек расширения.

2.  **[[Abstract Factory|Абстрактная фабрика]]**. Интерфейс, группирующий несколько фабричных методов для создания семейства взаимосвязанных продуктов. Клиент использует один экземпляр фабрики для получения всех необходимых объектов, гарантируя их совместимость.

3.  **[[Static Factory|Статическая фабрика]]**. Класс с одним или несколькими статическими методами, возвращающими экземпляры. Широко распространена в стандартных библиотеках (например, `Optional.of()`, `Collections.singletonList()`). Может возвращать заранее созданные экземпляры ([[Singleton|синглтоны]]), подтипы или объекты с кэшированием.

4.  **Именование фабричных методов**. Устоявшиеся префиксы: `create`, `newInstance`, `getInstance`, `valueOf`, `of`, `from`. Имя должно отражать не только факт создания, но и семантику: `createOrder`, `emptyList`, `parse`.

5.  **Комбинирование с внедрением зависимостей ([[Dependency Injection|DI]])**. В современных приложениях явные фабрики часто уступают место контейнерам IoC (Spring, Guice, Dagger), которые автоматически создают объекты с графом зависимостей. Однако фабрики остаются востребованными для ситуаций, когда тип объекта определяется динамически или требуется специфическая логика инициализации.

6.  **[[Parameterized Factory|Параметризованная фабрика]]**. Метод фабрики принимает параметр (обычно перечисление или строку), на основе которого выбирает конкретный класс для инстанцирования. Используется с осторожностью, так как усложняет добавление новых типов и нарушает [[Open-Closed Principle|принцип открытости/закрытости]].

7.  **[[Registry|Реестр]] фабрик**. Для поддержки расширяемости без модификации кода фабрики регистрируются в центральном реестре, а клиент выбирает нужную по ключу. Это вариант стратегии, часто используемый в плагинных архитектурах.

8.  **[[Factory vs Builder|Фабрика против строителя]]**. Фабрика отвечает за выбор конкретного типа и одномоментное создание объекта; [[Builder|строитель]] — за пошаговое конструирование сложного объекта. Паттерны не исключают друг друга и могут комбинироваться.

9.  **Тестирование с фабриками**. Фабрики облегчают подмену реализаций в тестах: клиент использует тестовую фабрику, возвращающую заглушки ([[Test Double|test doubles]]). Однако сами фабрики должны тестироваться отдельно на корректность создания объектов.

10. **Документирование контракта**. Фабрика должна чётко описывать предусловия (необходимые параметры) и постусловия (состояние возвращаемого объекта). Это особенно важно для статических фабрик, возвращающих разные подтипы.

Таким образом, фабрика является одним из фундаментальных порождающих паттернов, обеспечивающих гибкость и слабую связанность в объектно-ориентированных системах. Выбор конкретной вариации зависит от решаемой задачи: фабричный метод — для расширения поведения подклассами, абстрактная фабрика — для согласованных семейств продуктов, статическая фабрика — для простых, часто используемых операций создания. Современные практики интегрируют фабрики с внедрением зависимостей и реестрами, сохраняя их актуальность даже в эпоху контейнеров IoC.