---
updated_at: 2026-02-12T16:08:00.911+10:00
---
## Принцип открытости/закрытости: расширение без изменения

**Принцип открытости/закрытости** ({{Open-Closed Principle|Open-Closed Principle}}, OCP) — это принцип объектно-ориентированного проектирования, согласно которому программные сущности ([[Class|классы]], [[Module|модули]], [[Function|функции]]) должны быть **открыты для расширения** ([[Extension|extension]]) и **закрыты для модификации** ([[Modification|modification]]). Это означает, что поведение таких сущностей может быть расширено без изменения их исходного кода.

Сформулирован Бертраном Мейером в 1988 году и является вторым принципом [[SOLID|SOLID]].

### Назначение
Следование принципу открытости/закрытости обеспечивает защиту стабильного, проверенного кода и локализацию изменений:

*   **Устойчивость к изменениям**. Добавление новой функциональности не требует правки уже работающих и протестированных модулей, что снижает риск внесения [[Regression|регрессионных ошибок]].
*   **Снижение связанности**. Код, зависящий от абстракций, а не от конкретных реализаций, легче расширять и модифицировать.
*   **Повторное использование**. Абстрактные интерфейсы и базовые классы могут быть реализованы множеством способов, пригодных для различных контекстов.
*   **Параллельная разработка**. Независимые команды могут создавать новые расширения системы без координации с владельцами расширяемых модулей.
*   **Соответствие принципу единственной ответственности**. Модуль, закрытый для модификации, фокусируется на одной задаче, а изменения выносятся в отдельные расширения.

### Ограничения
Применение принципа открытости/закрытости сопряжено с рядом объективных сложностей:

1.  **Необходимость предвидения**. Чтобы корректно спроектировать модуль «закрытым» для будущих изменений, требуется предугадать возможные направления расширения. Избыточное абстрагирование под потенциальные, но никогда не реализуемые сценарии ведёт к ненужной сложности.
2.  **Усложнение архитектуры**. Введение дополнительных абстракций, фабрик и инверсии управления увеличивает количество классов и интерфейсов, что усложняет понимание системы.
3.  **Не все изменения можно закрыть**. Некоторые виды модификаций (исправление ошибок в алгоритме, изменение нерасширяемой бизнес-логики) невозможно выполнить без изменения исходного кода.
4.  **Компромисс с производительностью**. Косвенные вызовы через абстракции (виртуальные методы, вызовы через интерфейсы) могут создавать дополнительные накладные расходы в системах с жёсткими требованиями к скорости.
5.  **Соблазн преждевременной обобщённости**. Стремление сделать модуль «закрытым» на все случаи жизни приводит к созданию излишне параметризованных, трудночитаемых конструкций.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к реализации принципа открытости/закрытости:

1.  **Абстракция через интерфейсы ([[Interface|interface]])**. Код клиента зависит от абстрактного интерфейса, а не от конкретной реализации. Новые функциональности добавляются созданием новых классов, реализующих этот интерфейс, без изменения существующего кода клиента.

2.  **Наследование и базовые классы ([[Abstract Class|abstract class]])**. Базовая реализация предоставляет общую логику, а расширения переопределяют точки вариативности через защищённые методы ([[Template Method|шаблонный метод]]).

3.  **Паттерн «Стратегия» ([[Strategy|Strategy]])**. Поведение инкапсулируется в отдельные классы-стратегии, реализующие общий интерфейс. Контекст делегирует выполнение выбранной стратегии и может быть расширен добавлением новых стратегий без изменения кода контекста.

4.  **Паттерн «Декоратор» ([[Decorator|Decorator]])**. Расширение функциональности достигается обёртыванием объекта в класс-декоратор, реализующий тот же интерфейс. Декораторы могут комбинироваться в произвольном порядке без изменения исходных классов.

5.  **Паттерн «Фабричный метод» ([[Factory Method|Factory Method]])**. Создание объектов делегируется подклассам, что позволяет изменять тип создаваемых объектов без модификации существующего кода.

6.  **[[Dependency Injection|Внедрение зависимостей]]**. Зависимости передаются объекту извне (через конструктор, метод или свойство), а не создаются внутри. Это позволяет подменять реализации без изменения кода зависимого класса.

7.  **Параметризация поведения**. Вместо жёстко закодированных условных операторов (`if-else`, `switch`) поведение задаётся через переданные в конструктор или метод объекты-функции ([[Lambda expression|лямбда-выражения]], функциональные интерфейсы).

8.  **[[Open-Closed Principle|Следование OCP в API-дизайне]]**. Публичные интерфейсы библиотек и фреймворков проектируются как расширяемые (точки расширения, переопределяемые методы, конфигурационные обратные вызовы), чтобы потребители могли адаптировать поведение без изменения исходного кода библиотеки.

9.  **Избегание «божественных» условных конструкций**. Вместо класса, содержащего ветвления по типу, создаются полиморфные классы, реализующие общий интерфейс. Новый тип требует только создания новой реализации.

10. **Рефакторинг к OCP**. Не требуется изначально проектировать все модули по OCP. Практика рекомендует начинать с простой реализации и вводить абстракции при появлении второй, а лучше третьей, вариации поведения ([[Rule of Three|правило трёх]]).

Таким образом, принцип открытости/закрытости является ключевым для создания гибких, расширяемых систем, устойчивых к изменениям требований. Его применение требует баланса между предвидением точек расширения и прагматичным избеганием преждевременного усложнения. Дисциплинированное использование абстракций, порождающих паттернов и внедрения зависимостей позволяет достичь цели OCP — добавления новой функциональности путём написания нового кода, а не модификации старого.