---
updated_at: 2026-01-13T18:50:46.413+10:00
---
Слоистая архитектура разбивает кодовую базу на 4 основных слоя.
# Слой представления
(слой пользовательского интерфейса)
![[Рис. 8.2. Слой представления.png]]
В этом слое реализуется интерфейс взаимодействия программы с внешним миром:
* Графический интерфейс пользователя (GUI/TUI).
* Интерфейс командной строки (CLI).
* Интерфейс для интеграции с другими системами (API на вход) .
- Publish/Subscribe events (работа c событиями)

# Слой бизнес-логики
(слой доменов = слой предметной области = слой модели)
![[Рис. 8.3. Слой бизнес-логики.png]]
Тут реализуются основные процессы ради которых программа и была задумана. В этом слое работают тактические паттерны:
- [[Aggregate]] (точка входа для комбинированных структур)
- [[Entity]] (определяемые по id изменяемые объекты)
- services (если не вынесен в отдельный слой)
- [[Объект-значение]] (не имеющие id объекты - часто не изменяемые)

# Слой доступа к данным
(presentation = слой инфраструктуры)
![[Рис. 8.4. Слой доступа к данным.png]]
Слой доступа к данным обеспечивает доступ к механизмам хранения информации. Этот слой также включает интеграцию с различными внешними поставщиками информации, необходимую для решения функциональных задач программы: API-интерфейсы, предоставляемые внешними системами
- Базы данных
- Файловые хранилища
- Таблицы
- API для выхода (для работы с удаленными серверами)

# Слой сервисов (опционально)
(сервисный слой = прикладной слой)

Сервис - это stateless объект. Он настраивается, запускается и ждет... Сервис работает только если сработает какой-нибудь триггер (однако возможен вариант триггера запущенного на старте: "работай пока есть файлы в папке X"). В контексте архитектурного паттерна сервисный слой ([[Domain Service]]) является логической границей. Его не нужно рассматривать в качестве физического сервиса.

### Приемущества наличия 
Наличие явного сервисного слоя дает ряд преимуществ:
* Один и тот же сервисный слой может повторно использоваться сразу несколькими публичными интерфейсами, например графическим пользовательским интерфейсом и API. Дублирование логики оркестрации не требуется.
* Повышается модульность кода, все связанные методы собираются в одном месте.
* Происходит дополнительное разделение слоев представления и бизнес-логики.
* Упрощается тестирование функциональности бизнес-логики.

Сервисный слой действует как посредник между имеющимися у программы слоями представления и бизнес-логики. Для разделения слоя представления и базовой бизнес-логики логику управления транзакциями можно переместить на сервисный слой.

![[Рис. 8.6. Сервисный слой.png]]

Сервисный слой выступает в качестве фасада слоя бизнес-логики: он предоставляет интерфейс, который соответствует методам публичного интерфейса, инкапсулируя вызовы нижележащих слоев.

### Когда нужен сервисный слой?

Потребности в сервисном слое будут возникать, если паттерну бизнес-логики станет необходим внешний оркестратор, как в случае с паттерном активной записи. Тогда на сервисном слое будет реализован паттерн транзакционного сценария, а активные записи, с которыми он работает, будут находиться на слое бизнес-логики.

# Связь между слоями

Слои интегрированы в коммуникационную модель типа «сверху вниз»: каждый слой может иметь зависимость только от слоя, находящегося непосредственно под ним. Тем самым обеспечивается разделение задач реализации и уменьшение обмена знаниями между слоями. На рис. 8.5 слой представления ссылается только на слой бизнес-логики. Он абсолютно не в курсе дизайна слоя доступа к данным.

![[Рис. 8.5. Слоистая архитектура.png]]

# Когда предпочтительнее использовать слоистую архитектуру

Этот подход хорошо подходит для систем, бизнес-логика которых реализована с использованием транзакционного сценария или паттерна активной записи.

Но паттерн затрудняет реализацию модели предметной области, где бизнес-сущности (агрегаты и объекты-значения) не должны иметь никакой зависимости от базовой инфраструктуры и никаких знаний о ней. В слоистой архитектуре с ее зависимостью сверху вниз для выполнения этого требования нужно будет перепрыгивать через слои. Реализовать модель предметной области в слоистой архитектуре все же можно, но паттерн [[Порты и адаптеры]], подходит для этого гораздо лучше.

## Дополнительно: сравнение слоев и уровней

Слоистую архитектуру часто путают с архитектурой N-Tier (многоуровневой) и наоборот. Слои и уровни (tiers) концептуально различаются: 
- слой
	- это логическая граница
	- все слои связаны одним и тем же жизненным циклом: реализуются, развиваются и развертываются как единое целое.
- уровень
	- физическая граница. 
	- независимо развертываемый сервис, сервер или система.


Пример:

![[Рис. 8.7. Система с архитектурой N-Tier.png]]
Система отображает интеграцию физических сервисов, задействованных в системе. Потребитель использует браузер, который может работать на настольном компьютере или мобильном устройстве. Браузер взаимодействует с обратным прокси-сервером, который перенаправляет запросы в веб-приложение. Веб-приложение работает на веб-сервере и взаимодействует с сервером базы данных. Все эти компоненты могут работать на одном физическом сервере, представляющем собой составное устройство, или быть распределены между несколькими серверами. Но, поскольку каждый компонент может развертываться и управляться независимо от остальных, это уровни, а не слои.
