---
updated_at: 2026-02-12T15:13:42.960+10:00
---
**Сервис предметной области** ({{Domain Service|domain service}}) — это [[Stateless Service|сервис без состояния]], выражающий бизнес-операцию или правило, которое не может быть естественным образом размещено ни в [[Entity|сущности]], ни в [[Value Object|объекте-значении]]. Сервис предметной области оперирует объектами [[Domain Model|предметной модели]], координирует их взаимодействие и реализует логику, относящуюся к самой предметной области, а не к техническим аспектам приложения.

### Назначение
Введение сервисов предметной области вызвано необходимостью сохранить выразительность модели, не перегружая сущности и агрегаты чужеродной ответственностью:

*   **Операции над несколькими агрегатами**. Бизнес-процесс, затрагивающий несколько [[Aggregate|агрегатов]] и требующий координации между ними, не может принадлежать ни одному из них; его естественное место — сервис предметной области.
*   **Взаимодействие с внешними ресурсами**. Если правило предметной области требует обращения к [[Repository|репозиторию]], внешнему API или другому сервису, эта логика размещается в сервисе, а не в сущности.
*   **Сложные вычисления, не привязанные к состоянию**. Алгоритм, который использует множество объектов, но не изменяет их внутреннее состояние, реализуется как сервис.
*   **Преобразование одной модели в другую**. При взаимодействии [[Bounded Context|ограниченных контекстов]] трансляция объектов выполняется в сервисе предметной области.
*   **Инициирование длительных процессов**. Запуск [[Saga|саги]] или [[Domain Event|события предметной области]], инициирующего цепочку реакций, часто оформляется как сервис.

### Ограничения
Применение сервисов предметной области требует осторожности и дисциплины:

1.  **Риск анемичной модели**. Чрезмерное увлечение сервисами приводит к выхолащиванию сущностей: вся логика выносится наружу, а объекты превращаются в простые контейнеры данных. Это анти-паттерн [[Anemic Domain Model|анемичной модели]].
2.  **Размывание границ ответственности**. Если сервис становится хранилищем «всего, что не поместилось в сущность», он быстро превращается в [[God Object|«божественный объект»]].
3.  **Сложность тестирования**. В отличие от изолированных сущностей, сервисы часто зависят от репозиториев и других внешних компонентов, требуя подмены зависимостей.
4.  **Потеря инкапсуляции**. Сервис может манипулировать внутренним состоянием агрегатов, если те предоставляют доступ к своим данным, нарушая тем самым инварианты.
5.  **Неявное дублирование**. Одна и та же логика может быть случайно реализована в нескольких сервисах при отсутствии централизованного управления.

### Сложившиеся практики
Индустрия выработала устойчивый набор рекомендаций по проектированию и использованию сервисов предметной области:

1.  **Именование отражает действие**. Сервис называется глаголом, описывающим выполняемую операцию, или фразой, явно указывающей на бизнес-способность: `TransferService`, `FraudDetectionService`, `PricingCalculator`. Это отличает его от технических сервисов (например, `UserRepository`).

2.  **Без состояния ([[Stateless Service|stateless]])**. Сервис предметной области не хранит собственного состояния между вызовами. Все необходимые данные передаются в параметрах методов или получаются из переданных репозиториев.

3.  **Интерфейс в домене, реализация в инфраструктуре?** В строгой [[Hexagonal Architecture|гексагональной архитектуре]] интерфейс сервиса предметной области принадлежит доменному слою, а реализация — к инфраструктурному, если она требует обращения к внешним ресурсам. Если сервис реализует чисто вычислительную логику, он остаётся полностью в домене.

4.  **Композиция над наследованием**. Сервис использует другие доменные сервисы, репозитории и фабрики через явное [[Dependency Injection|внедрение зависимостей]]. Конструктор принимает все необходимые зависимости, что делает их видимыми и упрощает тестирование.

5.  **Минимальный интерфейс**. Метод сервиса принимает ровно те параметры, которые необходимы для выполнения операции, и возвращает результат (значение, событие, либо изменённые агрегаты). Побочные эффекты (сохранение) делегируются репозиториям вызывающим кодом.

6.  **Сервис не заменяет методы агрегатов**. Прежде чем создавать сервис, следует убедиться, что операция действительно не принадлежит ни одной сущности или объекту-значению. Типичный пример законного сервиса — операция, затрагивающая несколько агрегатов разных типов.

7.  **Координация, а не выполнение**. Сервис предметной области не должен выполнять примитивные операции над базой данных; он получает агрегаты через репозиторий, вызывает их методы для изменения состояния, а затем передаёт агрегаты обратно репозиторию для сохранения.

8.  **Явное выражение бизнес-правил**. Сложное бизнес-правило, использующее множество условий и внешних данных, реализуется в сервисе как чётко названный метод, документирующий само правило.

9.  **Сервис и [[Domain Event|события предметной области]]**. Часто сервис после выполнения операции публикует событие или возвращает его для публикации вызывающим слоем. Это обеспечивает слабую связанность.

10. **Тестирование с заглушками**. Модульные тесты для сервиса заменяют репозитории и другие зависимости заглушками, проверяя корректность координации и применения бизнес-правил.

Таким образом, сервис предметной области является необходимым, но потенциально опасным инструментом. Его уместное применение дополняет богатую модель, не разрушая её, и позволяет выразить операции, выходящие за рамки отдельных агрегатов. Дисциплинированное следование принципу «сначала сущность — потом сервис» сохраняет выразительность и целостность предметно-ориентированного проектирования.