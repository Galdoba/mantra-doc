---
updated_at: 2026-02-13T12:16:34.528+10:00
---
## Метод Update: операция модификации существующих данных

**Update** ({{Update|update}}) — это операция, отвечающая за изменение состояния уже существующей записи в постоянном хранилище. В рамках концепции [[CRUD|CRUD]] Update заменяет текущее представление объекта новым либо частично модифицирует его атрибуты, сохраняя при этом исходную идентичность ([[Identifier|идентификатор]]).

### Назначение
Операция Update обеспечивает возможность эволюции данных в соответствии с изменяющимися бизнес-требованиями:

*   **Корректировка ошибочных данных**. Исправление неточностей, опечаток или устаревшей информации.
*   **Отражение изменения состояния**. Перевод сущности из одного статуса в другой (например, «заказ оформлен» → «заказ оплачен»).
*   **Обновление атрибутов**. Изменение значений полей (адреса доставки, контактные данные, цены).
*   **Синхронизация с внешними системами**. Приведение внутреннего представления в соответствие с данными из доверенных источников.
*   **Поддержание актуальности**. Регулярное обновление производных, вычисляемых или агрегированных полей.

### Ограничения
Применение операции Update в чистом CRUD-подходе сопряжено с рядом существенных ограничений:

1.  **Потеря истории изменений**. Операция Update замещает предыдущее состояние новым, не сохраняя информацию о том, каким был объект до модификации. Это исключает возможность аудита, отката или анализа изменений без дополнительных механизмов.
2.  **Конфликты параллелизма ([[Lost Update|потерянные обновления]])**. При одновременном изменении одной записи несколькими пользователями или процессами последнее сохранение может перезаписать изменения, внесённые ранее, без какого-либо уведомления.
3.  **Неоднозначность семантики**. Операция Update не различает полную замену объекта и частичное обновление отдельных полей. Это приводит к неопределённости в интерпретации отсутствующих полей: следует ли их игнорировать, удалять или оставлять без изменений.
4.  **Нарушение инвариантов агрегатов**. Прямое обновление отдельных полей сущности извне позволяет обойти бизнес-правила и инварианты, которые должны поддерживаться на уровне модели.
5.  **Каскадное обновление и ссылочная целостность**. Изменение идентификатора или ключевого атрибута может нарушить связи с зависимыми объектами, если не предусмотрены механизмы каскадной синхронизации.
6.  **Избыточная передача данных**. При полной замене объекта клиент вынужден отправлять все поля, даже те, которые не изменялись, что увеличивает сетевой трафик и нагрузку на сериализацию.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к реализации операции Update, компенсирующих её недостатки:

1.  **Различение [[PUT|PUT]] и [[PATCH|PATCH]] в REST**. PUT реализует полную замену ([[Replace|replace]]) ресурса; клиент предоставляет полное представление, отсутствующие поля интерпретируются как установка значений по умолчанию или удаление. PATCH реализует частичное обновление ([[Partial Update|partial update]]) и передаёт только набор изменений в специализированном формате (например, JSON Patch, JSON Merge Patch).

2.  **[[Optimistic Locking|Оптимистическая блокировка]]**. Для обнаружения конфликтов параллельного обновления сущность снабжается версией (числовой счётчик, временная метка или хеш). При сохранении версия проверяется; если она не соответствует ожидаемой, операция отклоняется, и клиент уведомляется о необходимости разрешить конфликт.

3.  **[[Idempotency|Идемпотентность]] обновления**. Многократное применение одной и той же операции Update с одними и теми же данными не должно изменять состояние системы после первого выполнения. Это свойство критически важно для надёжности в условиях повторных попыток и достигается естественным путём при полной замене (PUT) и аккуратным проектированием частичных обновлений.

4.  **Методы изменения на уровне агрегатов**. В предметно-ориентированном проектировании прямое обновление полей заменяется явными бизнес-методами (например, `changeShippingAddress` вместо `setAddress`). Эти методы инкапсулируют проверку инвариантов и порождают [[Domain Event|события предметной области]].

5.  **[[Audit Trail|Аудиторский след]]**. Для критичных данных вместо прямого обновления используется подход «только добавление» ([[Append-Only|append-only]]): каждое изменение фиксируется как новая запись или событие, а текущее состояние вычисляется агрегацией. Это обеспечивает полную историю изменений и возможность отката.

6.  **[[Soft Delete|Мягкое удаление]] вместо обновления статуса**. Удаление часто реализуется как обновление специального флага `deleted`, что позволяет сохранить историю и восстановить данные при необходимости.

7.  **[[DTO|Объекты передачи данных]] для обновления**. Создаются специализированные DTO, содержащие только изменяемые поля. Внутренняя модель обновляется путём маппинга, что отделяет контракт API от внутреннего представления.

8.  **Валидация на уровне команд**. Операция Update принимает не сырые данные, а команду, выражающую намерение (например, `UpdateCustomerAddressCommand`). Команда валидируется перед применением, что гарантирует корректность входных данных.

9.  **[[Upsert|Upsert]] (обновление или вставка)**. В некоторых сценариях операция Update может создавать запись, если она ещё не существует. Это полезно для синхронизации, но требует чёткой спецификации поведения и проверки идемпотентности.

10. **[[Merge|Слияние]] вместо замены**. В системах с большим количеством независимо изменяемых атрибутов может применяться стратегия слияния (merge), при которой обновляются только явно указанные поля, а остальные сохраняют прежние значения.

11. **Тестирование сценариев обновления**. Обязательными являются тесты, проверяющие корректность частичных обновлений, обработку конфликтов версий, а также неизменность неявных полей (дата создания, автор).

Таким образом, операция Update в современной разработке выходит далеко за пределы простого SQL-вызова `UPDATE`. Её проектирование требует осознанного выбора между полной и частичной модификацией, реализации механизмов обнаружения конфликтов, обеспечения идемпотентности и сохранения аудиторского следа. В сложных предметных областях прямой CRUD-подход уступает место явным бизнес-методам и событийно-ориентированным архитектурам, где изменение состояния фиксируется как необратимый факт, а не как перезапись прошлого.