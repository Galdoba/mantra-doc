---
updated_at: 2026-02-12T13:51:27.118+10:00
---
## JSON: формат данных для обмена и хранения

**JSON** (JavaScript Object Notation) — это легковесный, текстовый, языконезависимый формат сериализации структурированных данных, основанный на подмножестве синтаксиса языка JavaScript. Данные в JSON представлены в виде пар «ключ-значение» и упорядоченных списков, что делает его естественным для большинства языков программирования.

### Назначение
JSON стал доминирующим форматом для обмена данными в вебе и за его пределами благодаря своей простоте и читаемости:

*   **Передача данных в [[API|API]]**. Является стандартом де-факто для RESTful и GraphQL API, заменяя более громоздкий XML.
*   **[[Configuration|Конфигурация]] приложений**. Широко используется для файлов настроек (package.json, .eslintrc, docker-compose.yml может быть и YAML, но JSON также популярен).
*   **Хранение документов**. NoSQL-базы данных (MongoDB, CouchDB) используют JSON или его бинарные аналоги в качестве основной модели данных.
*   **Сериализация объектов**. Преобразование внутренних структур данных в строку для сохранения в кэш, файл или отправки по сети.

JSON обеспечивает баланс между машинной эффективностью и человекочитаемостью, что обусловило его повсеместное распространение.

### Ограничения
Несмотря на популярность, JSON обладает рядом внутренних ограничений:

1.  **Ограниченный набор типов**. Поддерживаются строки, числа, булевы значения, null, массивы и объекты. Отсутствуют встроенные типы для дат, времени, бинарных данных, регулярных выражений, ссылок и циклических структур.
2.  **Числовая точность**. Спецификация не различает целые числа и числа с плавающей точкой; все числа представлены в десятичной записи. При десериализации в языках с различной числовой моделью возможна потеря точности для больших целых чисел (например, 64-битных).
3.  **Отсутствие комментариев**. JSON не поддерживает комментарии, что делает его менее удобным для конфигурационных файлов, редактируемых вручную, по сравнению с YAML или JSON5.
4.  **Избыточность**. Текстовое представление с повторяющимися ключами в каждом объекте приводит к большему объёму данных по сравнению с бинарными форматами ([[MessagePack]], [[CBOR]], [[Protocol Buffers]]).
5.  **Безопасность**. Использование функции `eval()` для разбора JSON в ранних веб-приложениях создавало уязвимости. Современные [[Parsing|парсеры]] безопасны, но legacy-код может представлять риск.
6.  **Отсутствие схемы по умолчанию**. JSON сам по себе не описывает структуру данных; требуется отдельный механизм валидации ([[JSON Schema]]).

### Сложившиеся практики
Индустрия выработала устойчивые приёмы эффективной работы с JSON, компенсирующие его ограничения:

1.  **Использование JSON Schema**. Для валидации структуры и типов данных применяется JSON Schema — декларативный язык описания ожидаемого формата JSON-документов. Схемы позволяют автоматически проверять входящие данные, генерировать документацию и тесты.

2.  **Соглашения об именовании**. В сообществе устоялись единые стили именования ключей: **camelCase** (JavaScript, Java) или **snake_case** (Python, Ruby). Для межязыковых систем выбирается один стандарт и фиксируется в документации.

3.  **Обработка дат и сложных типов**. Поскольку JSON не имеет типа «дата», применяются строковые представления в формате ISO 8601 (например, `"2025-03-21T10:00:00Z"`). Бинарные данные кодируются в Base64 и передаются как строки.

4.  **Версионирование через обёртки**. Для обеспечения обратной совместимости API в JSON-ответ добавляют поле `version` или оборачивают данные в контейнер `{ "data": ..., "version": 1 }`. Это позволяет эволюционировать схеме без нарушения клиентов.

5.  **Минификация и pretty-print**. Для передачи по сети JSON минифицируют (удаляют пробелы), для хранения в репозиториях и редактирования — форматируют с отступами. Серверы обычно отдают минифицированный JSON, клиентские инструменты могут «причесывать» его локально.

6.  **Безопасный парсинг**. В среде JavaScript обязательно используется `JSON.parse()` вместо `eval()`. В других языках применяются только проверенные библиотеки, устойчивые к некорректному вводу.

7.  **Добавление комментариев через препроцессинг**. Поскольку чистый JSON не поддерживает комментарии, в конфигурационных файлах часто применяются внешние инструменты, удаляющие комментарии перед передачей парсеру, либо используются надмножества (JSON5, HJSON), транслируемые в стандартный JSON.

8.  **Сериализация с игнорированием циклических ссылок**. При преобразовании объектов в JSON стандартные сериализаторы обычно не поддерживают циклические ссылки. Практика — использовать библиотеки, которые либо обходят циклы, либо заменяют повторяющиеся объекты ссылками (например, `JSON.stringify` с replacer-функцией в JavaScript).

9.  **Числовая безопасность**. Для передачи 64-битных целых чисел, не помещающихся в double (53 бита точности), используются строки или специализированные схемы (например, строковое представление в Protobuf JSON Mapping).

10. **Сжатие**. При передаче больших объёмов JSON-данных поверх HTTP применяется сжатие на уровне транспорта (gzip, Brotli). Это значительно сокращает объём трафика.

11. **Использование альтернатив по необходимости**. В случаях, когда критичны компактность, скорость или поддержка бинарных данных, JSON заменяют на бинарные форматы (MessagePack, CBOR, BSON, Avro). JSON остаётся выбором по умолчанию для публичных API и человекопонятных конфигураций.

Таким образом, JSON занял нишу универсального, простого и достаточно выразительного формата, который при соблюдении дисциплины схем и соглашений успешно обслуживает подавляющее большинство задач обмена и хранения данных в современных распределённых системах.