---
updated_at: 2026-02-12T13:31:22.967+10:00
---
**Процесс без состояния** (stateless process) — это экземпляр выполняющейся программы, который не хранит на своей стороне информацию о предыдущих взаимодействиях с клиентами или результаты промежуточных вычислений, необходимые для обработки последующих запросов. Каждый входящий запрос обслуживается изолированно, независимо от каких-либо данных, оставшихся в памяти или на локальном диске процесса от предыдущих операций.

Противоположностью является [[Stateful Process|процесс с состоянием]], который сохраняет контекст между вызовами внутри своего адресного пространства или локальной файловой системы.

### Назначение
Использование процессов без состояния преследует цели, связанные с эксплуатацией распределённых систем:

*   **[[Horizontal Scaling|Горизонтальное масштабирование]]**. Поскольку любой экземпляр процесса идентичен друг другу и не хранит уникальных данных, нагрузку можно распределять между произвольным количеством параллельно работающих копий. Добавление или удаление экземпляров не нарушает целостность системы.
*   **Отказоустойчивость**. Сбой одного процесса не приводит к потере данных о состоянии, так как состояние отсутствует. Балансировщик перенаправляет запросы на оставшиеся или вновь созданные экземпляры.
*   **Упрощение развёртывания**. Обновление версии приложения или откат не требуют миграции состояния; старые процессы останавливаются, новые запускаются, и трафик переключается на них.
*   **Тестируемость**. Отсутствие скрытого внутреннего состояния упрощает написание модульных и интеграционных тестов, так как каждый тест начинается с чистого листа.
*   **[[Disposability|Эфемерность]]**. Процессы могут быть быстро созданы и уничтожены без процедур корректного завершения, связанных с сохранением состояния.

Эти свойства делают модель без состояния доминирующей в архитектурах микросервисов и облачных нативных приложений, что закреплено, в частности, в методологии [[Twelve-Factor App|Двенадцати факторов]].

### Ограничения
Полный отказ от локального состояния накладывает ряд ограничений на проектирование приложений:

1.  **Необходимость внешних хранилищ**. Любые данные, которые должны пережить завершение процесса или быть доступны другим экземплярам, выносятся во [[External Store|внешние хранилища]] — базы данных, кэши (Redis, Memcached), объектные хранилища. Это увеличивает сетевые задержки и зависимость от доступности внешних сервисов.
2.  **Работа с сессиями**. В веб-приложениях традиционная аутентификация на основе серверных сессий требует хранения [[Session State|состояния сессии]]. В модели без состояния сессии либо выносятся в централизованное хранилище, либо заменяются само-достаточными токенами (JWT), содержащими все необходимые данные на стороне клиента.
3.  **Ограниченная применимость**. Некоторые классы задач по своей природе требуют долговременного внутреннего состояния: системы реального времени, обработка потоковых данных с окнами, сложные транзакции, требующие координации. Принудительное навязывание модели без состояния в таких случаях приводит к усложнению архитектуры.
4.  **Идемпотентность и консистентность**. При отсутствии состояния на стороне сервера повторная отправка одного и того же запроса (например, из-за сетевых таймаутов) может привести к дублированию операций, если обработчик не реализован [[Idempotency|идемпотентно]].
5.  **Когнитивная нагрузка**. Разработчики вынуждены явно проектировать границы состояния и управлять его согласованностью во внешних системах, что сложнее, чем полагаться на локальные переменные.

### Сложившиеся практики
Инженерное сообщество выработало устойчивые приёмы, позволяющие эффективно строить системы без сохранения локального состояния:

1.  **Вынесение состояния за пределы процесса**. Все изменяемые данные, разделяемые между запросами или экземплярами, размещаются в специализированных хранилищах. Для высоконагруженных сценариев используются распределённые кэши (Redis, Hazelcast), для долговременного хранения — реляционные или NoSQL базы данных. Это реализует [[Shared Nothing Architecture|архитектуру без общего состояния]].

2.  **Аутентификация и сессии**. Вместо серверных сессий применяются токены (JWT, PASETO), содержащие утверждения о пользователе и подписанные доверенным ключом. Сервер проверяет подпись и извлекает необходимые данные из токена, не обращаясь к общему хранилищу на каждый запрос. При необходимости отзыва используются короткоживущие токены и рефреш-токены, хранимые на клиенте.

3.  **Идемпотентность обработчиков**. Критические операции (платежи, создание ресурсов) проектируются идемпотентными: повторная отправка того же запроса с тем же идентификатором не приводит к повторному выполнению. Клиент генерирует уникальный ключ идемпотентности, сервер сохраняет результат выполнения в хранилище для данного ключа.

4.  **[[Stateless Protocol|Протоколы без состояния]]**. На транспортном уровне предпочитаются протоколы, не требующие хранения состояния соединения на сервере (HTTP/1.1 с keep-alive всё же хранит состояние TCP, но прикладной уровень остаётся stateless). HTTP/2 и gRPC также допускают stateless-дизайн приложения.

5.  **Контейнеризация и оркестрация**. Процессы без состояния естественным образом вписываются в модели [[Containerization|контейнеризации]] и [[Orchestration|оркестрации]] (Kubernetes). Платформа может произвольно масштабировать количество подов, перезапускать их, перемещать между узлами, не заботясь о сохранности локальных данных.

6.  **Файловые загрузки и артефакты**. Если приложение работает с загружаемыми пользователями файлами, они не сохраняются на локальном диске процесса, а сразу передаются в объектное хранилище (S3, MinIO) или CDN. Сам процесс лишь генерирует ссылки на внешние ресурсы.

7.  **Комбинирование с stateful-компонентами**. Полностью stateless-системы редки: зачастую состояние вытесняется на периферию — в базы данных, очереди, стриминговые платформы. Таким образом, общая система включает stateful-сервисы хранения, но прикладные процессы, реализующие бизнес-логику, остаются без состояния.

8.  **Graceful degradation**. При недоступности внешнего хранилища процессы без состояния должны корректно обрабатывать ситуацию, возвращая временные ошибки (503), а не падать или выдавать некорректные результаты.

Таким образом, процесс без состояния является краеугольным камнем современных масштабируемых архитектур. Его использование требует дисциплинированного вынесения состояния за пределы экземпляров приложения, но взамен даёт линейную масштабируемость, высокую отказоустойчивость и упрощение эксплуатации в облачных средах.