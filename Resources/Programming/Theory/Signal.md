---
updated_at: 2026-02-16T13:34:24.946+10:00
---
**Сигнал** ({{Signal|signal}}) — это асинхронное уведомление, отправляемое [[Process|процессу]] операционной системой или другим процессом для сообщения о событии. Сигналы являются простейшей формой [[Inter-Process Communication|межпроцессного взаимодействия]] и основным механизмом управления процессами в Unix-подобных системах. Каждый сигнал имеет уникальный номер и предопределённое значение (завершение, остановка, продолжение, игнорирование), которое может быть переопределено процессом с помощью обработчика сигнала [Signal Handler].

### Назначение
Сигналы обеспечивают асинхронную коммуникацию и управление жизненным циклом процессов:

*   **Завершение процессов**. Операционная система отправляет сигналы для корректного ([[SIGTERM]]) или принудительного ([[SIGKILL]]) завершения.
*   **Обработка исключительных ситуаций**. Сигналы генерируются при аппаратных ошибках (деление на ноль — SIGFPE, обращение к недопустимой памяти — SIGSEGV).
*   **Управление сессиями и терминалами**. Сигналы SIGHUP (обрыв связи), [[SIGINT]] (прерывание с клавиатуры), SIGTSTP (приостановка).
- **Оповещение о событиях**. Таймеры (SIGALRM), завершение дочернего процесса (SIGCHLD), изменение размера окна терминала (SIGWINCH).
- **Пользовательские уведомления**. Сигналы SIGUSR1 и SIGUSR2 могут быть использованы приложениями для произвольных целей (например, перезагрузка конфигурации, поворот логов).

### Ограничения
Использование сигналов сопряжено с существенными ограничениями:

1. **Асинхронность и реентерабельность**. Обработчик сигнала выполняется асинхронно относительно основного потока программы. Вызов небезопасных (async-signal-safe) функций внутри обработчика может привести к [[Race Condition|состоянию гонки]], взаимным блокировкам или повреждению данных.
2. **Ограниченный набор**. Существует фиксированное количество сигналов (обычно 31–64); пользовательских сигналов всего два (`SIGUSR1`, `SIGUSR2`). Это ограничивает выразительность и пригодность сигналов для сложных протоколов взаимодействия.
3. **Отсутствие очереди**. Стандартные сигналы не ставятся в очередь; если процесс уже имеет ожидающий сигнал того же типа, новый сигнал может быть потерян (исключение — сигналы реального времени в POSIX).
4. **Переносимость**. Поведение сигналов различается между Unix-подобными системами; Windows не поддерживает сигналы POSIX, предлагая другие механизмы ([Structured Exception Handling|SEH], события).
5. **Сложность отладки**. Сигнальные обработчики нарушают линейный поток выполнения, что затрудняет трассировку и отладку.
6. **Маскирование и блокировка**. Управление маской сигналов требует аккуратной работы с потоками: маска наследуется дочерними потоками и процессами.

### Сложившиеся практики
Индустрия выработала устойчивые подходы к безопасному и эффективному использованию сигналов:

1. **Минималистичные обработчики**. Обработчик сигнала должен выполнять только минимально необходимые действия: установить атомарный флаг ([[Volatile|volatile]] sig_atomic_t) и завершиться. Основная логика обработки события выполняется в главном цикле программы при проверке этого флага.

2. **Использование само-труб (self-pipe)**. Для интеграции сигналов с циклами событий (select, poll, epoll) обработчик записывает один байт в неблокирующий канал (pipe), а основной цикл отслеживает чтение из этого канала. Это безопасно и позволяет обрабатывать сигналы синхронно.

3. **Игнорирование SIGPIPE**. При записи в разорванное сетевое соединение генерируется SIGPIPE, который по умолчанию завершает процесс. В серверных приложениях принято игнорировать SIGPIPE и обрабатывать ошибку записи через возвращаемое значение.

4. **SIGTERM для корректного завершения**. Процесс должен перехватывать SIGTERM и инициировать процедуру [[Graceful Shutdown|корректного завершения]]: прекращение приёма новых запросов, завершение текущих операций, освобождение ресурсов. Это стандартный сигнал для плановой остановки.

5. **SIGHUP для перезагрузки конфигурации**. Демоны традиционно используют SIGHUP для перечитывания конфигурационных файлов и повторного открытия логов без полной остановки.

6. **SIGKILL и SIGSTOP не перехватываются**. Эти сигналы не могут быть обработаны или проигнорированы; они предназначены для принудительного завершения и остановки. Процессы не должны рассчитывать на возможность их обработки.

7. **Маскирование в многопоточных программах**. Потоки наследуют маску сигналов родительского потока. Рекомендуется блокировать все сигналы во всех рабочих потоках и иметь выделенный поток для синхронного ожидания сигналов (sigwait). Это исключает асинхронное прерывание потоков.

8. **Сигналы в контейнеризованных средах**. В контейнерах процесс с PID 1 имеет специальную роль: он должен явно обрабатывать SIGTERM и пересылать его дочерним процессам. Некоторые платформы (Kubernetes) отправляют SIGTERM и ожидают завершения в течение периода вежливости [Termination Grace Period].

9. **Сигналы реального времени [Real-time Signal]**. Для сценариев, требующих очереди сигналов и передачи дополнительных данных, используются сигналы реального времени (SIGRTMIN+...). Они поддерживают очередь и могут нести целочисленное значение.

10. **Тестирование обработки сигналов**. В тестовых сценариях принудительно отправляются сигналы (kill — команда или системный вызов) с проверкой ожидаемого поведения: корректное завершение, перезагрузка конфигурации, сохранение состояния.

Таким образом, сигналы остаются фундаментальным механизмом управления процессами и уведомления о событиях в Unix-подобных операционных системах. Современные практики направлены на ограничение асинхронного кода в обработчиках, интеграцию сигналов с управляемыми циклами событий и предсказуемое поведение в многопоточных и контейнеризованных окружениях. При соблюдении этих практик сигналы обеспечивают надёжное и эффективное управление приложениями без усложнения архитектуры.