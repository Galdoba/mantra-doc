---
updated_at: 2026-02-12T16:01:49.553+10:00
---
**Корректное завершение** ({{Graceful Shutdown|graceful shutdown}}) — это процедура остановки [[Process|процесса]] или [[Service|сервиса]], при которой система завершает свою работу контролируемо: завершает обработку текущих запросов, освобождает занятые ресурсы, закрывает сетевые соединения, сохраняет состояние и только после этого прекращает выполнение. Противоположностью является принудительное завершение ([[Hard Kill|hard kill]]), которое немедленно останавливает процесс, потенциально приводя к потере данных и некорректному состоянию.

### Назначение
Реализация корректного завершения критически важна для обеспечения целостности, надёжности и доступности систем:

*   **Предотвращение потери данных**. Завершающиеся транзакции получают возможность завершиться; данные в кэшах и буферах сбрасываются в постоянное хранилище.
*   **Сохранение консистентности состояния**. Избегание ситуаций, когда после аварийной остановки агрегаты или базы данных остаются в несогласованном состоянии.
*   **Улучшение пользовательского опыта**. Клиенты, отправившие запрос, получают ответ, а не ошибку соединения или таймаут.
*   **Поддержка [[Zero-Downtime Deployment|развёртывания без простоев]]**. В оркестрируемых средах старые экземпляры корректно завершаются только после того, как все запросы к ним завершены, а балансировщик трафика перенаправил новые запросы на новые экземпляры.
*   **Освобождение ресурсов**. Закрытие файловых дескрипторов, соединений с базами данных, очередей и других разделяемых ресурсов предотвращает их утечку.

### Ограничения
Корректное завершение не является универсальным решением и имеет объективные ограничения:

1.  **Невозможность бесконечного ожидания**. Некоторые операции могут зависнуть ([[Deadlock|взаимная блокировка]], бесконечный цикл, ожидание недоступного ресурса). Процесс должен иметь максимальное время ожидания, после которого завершение становится принудительным.
2.  **Неполнота реализации**. Не все приложения правильно обрабатывают сигналы завершения; некоторые библиотеки могут создавать фоновые потоки, не поддающиеся контролю.
3.  **Сложность распределённых сценариев**. В микросервисной архитектуре корректное завершение одного сервиса может нарушить работу других, если они не готовы к потере зависимости.
4.  **Потеря контекста при быстром перезапуске**. Если процесс завершается и перезапускается слишком быстро, операционная система может не успеть освободить порты, что приведёт к ошибкам привязки.
5.  **Дополнительная нагрузка на разработку**. Требуется явное программирование логики завершения, обработка сигналов и тестирование сценариев остановки.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к реализации корректного завершения:

1.  **Обработка сигналов ([[Signal|signal handling]])**. В Unix-подобных системах процесс перехватывает сигналы завершения ([[SIGTERM|SIGTERM]], [[SIGINT|SIGINT]]) и инициирует процедуру graceful shutdown. Сигнал [[SIGKILL|SIGKILL]] перехватить невозможно; он используется для принудительного завершения после истечения таймаута.

2.  **Таймаут на завершение ([[Shutdown Timeout|shutdown timeout]])**. Устанавливается максимальное время ожидания завершения текущих операций (обычно 30–60 секунд). По истечении таймаута процесс завершается принудительно.

3.  **Прекращение приёма новых запросов**. При получении сигнала завершения сервис немедленно переводится в состояние «не готов» (readiness probe возвращает неудачу), что исключает направление нового трафика от балансировщика или оркестратора.

4.  **Ожидание завершения активных запросов**. Сервис продолжает обработку уже принятых запросов, но не принимает новые. После завершения всех активных операций инициируется остановка.

5.  **[[Connection Draining|Опустошение соединений (connection draining)]]**. Балансировщики нагрузки (AWS ELB, Nginx, Envoy) при получении уведомления о завершении экземпляра прекращают направлять на него новые соединения, но продолжают проксировать существующие до их естественного закрытия.

6.  **[[PreStop Hook|PreStop Hook]] в Kubernetes**. Контейнерная платформа предоставляет механизм выполнения пользовательского скрипта перед отправкой SIGTERM. Это позволяет выполнить подготовку к остановке (например, уведомление балансировщика, сброс кэша) в течение заданного периода.

7.  **Освобождение ресурсов в обратном порядке приобретения**. Соединения, дескрипторы файлов, блокировки и другие ресурсы закрываются в порядке, обратном их созданию, что предотвращает ситуации частичного освобождения.

8.  **Идемпотентность процедуры завершения**. Повторный вызов shutdown не должен приводить к ошибкам или некорректному поведению. Реализуется через защитные проверки (например, `if (shutdownInitiated) return`).

9.  **Логирование процесса завершения**. Фиксируются ключевые этапы: получение сигнала, количество оставшихся активных запросов, успешность освобождения ресурсов, факт завершения. Это облегчает диагностику сбоев при остановке.

10. **Тестирование корректного завершения**. В тестовые сценарии включаются принудительные остановки во время выполнения длительных операций с последующей проверкой целостности данных и отсутствия утечек ресурсов.

11. **Каскадное завершение в распределённых системах**. При остановке группы связанных сервисов важен порядок: сначала завершаются потребители, затем поставщики, чтобы избежать отправки запросов в уже недоступные сервисы.

Таким образом, корректное завершение является не дополнительной опцией, а обязательным требованием к промышленным системам, особенно работающим в оркестрируемых средах (Kubernetes, Nomad). Его реализация требует системного подхода на всех уровнях — от прикладного кода до инфраструктурных компонентов, и обеспечивает сохранность данных, бесшовные обновления и общую надёжность платформы.