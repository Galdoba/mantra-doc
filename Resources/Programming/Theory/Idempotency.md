---
updated_at: 2026-02-12T14:12:30.088+10:00
---
**Идемпотентность** ({{Idempotency|idempotency}}) — это свойство операции, при котором многократное её применение с одними и теми же входными параметрами приводит к тому же результату, что и однократное применение, и не вызывает дополнительных [[Side Effect|побочных эффектов]]. Идемпотентная операция может быть выполнена один или несколько раз без изменения состояния системы за пределами первого успешного выполнения.

Понятие заимствовано из математики, где идемпотентным называется элемент, удовлетворяющий равенству \( f(f(x)) = f(x) \).

### Назначение
Идемпотентность является ключевым свойством для построения надёжных распределённых систем, в которых сбои сети, таймауты и повторные попытки неизбежны:

*   **Безопасные повторные попытки ([[Retry|retry]])**. Клиент может повторять запросы при сбоях, не опасаясь дублирования операций (например, повторного списания средств, создания дубликатов заказов).
*   **Гарантия [[Exactly-Once|ровно однократной]] обработки**. Идемпотентность в сочетании с механизмами повторных попыток позволяет достичь семантики exactly-once в условиях at-least-once доставки.
*   **Упрощение протоколов**. Отпадает необходимость в сложных протоколах подтверждения и согласования состояний.
*   **Отказоустойчивость**. Потребители сообщений могут безопасно перезапускаться и повторно обрабатывать сообщения без координации с отправителем.
*   **Идемпотентные [[HTTP метод|HTTP-методы]]**. Спецификация HTTP определяет GET, HEAD, PUT, DELETE, OPTIONS как идемпотентные, что позволяет кэширующим прокси и клиентам повторять запросы без риска.

### Ограничения
Обеспечение идемпотентности сопряжено с рядом ограничений и проектных компромиссов:

1.  **Необходимость хранения [[State|состояния]]**. Для обнаружения повторных запросов сервер должен хранить информацию о ранее обработанных операциях (как минимум их идентификаторы и результаты). Это увеличивает потребление памяти и диска.
2.  **Срок жизни состояния**. Невозможно хранить ключи идемпотентности бесконечно. Требуются политики устаревания, что может привести к коллизиям при очень поздних повторах.
3.  **Не все операции идемпотентны по своей природе**. Операции, генерирующие уникальные идентификаторы (POST /orders), инкрементирующие счётчики, добавляющие элементы в неупорядоченные коллекции, не являются идемпотентными без дополнительного проектирования.
4.  **Распределённая согласованность**. В распределённых системах обеспечение строгой идемпотентности требует координации между несколькими сервисами и базами данных, что усложняет архитектуру и снижает производительность.
5.  **Проектная сложность**. Реализация идемпотентности требует явного выделения ключей, проверки дубликатов и управления побочными эффектами, что увеличивает объём и сложность кода.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к обеспечению идемпотентности на разных уровнях системы:

1.  **Идемпотентные HTTP-методы и [[Safe Method|безопасные методы]]**. Разработка REST API строго следует семантике HTTP: GET, HEAD, OPTIONS не изменяют состояние; PUT и DELETE идемпотентны. POST, как правило, неидемпотентен, но может быть сделан идемпотентным с помощью явных ключей.

2.  **Ключ идемпотентности ([[Idempotency Key|idempotency key]])**. Для неидемпотентных операций (например, POST /payments) клиент генерирует уникальный ключ (UUID) и передаёт его в заголовке запроса (`Idempotency-Key`). Сервер сохраняет связку «ключ → результат выполнения» и при повторном запросе с тем же ключом немедленно возвращает ранее сохранённый ответ, не выполняя операцию повторно.

3.  **Хранение ключей с политикой устаревания**. Ключи идемпотентности хранятся ограниченное время (например, 24 часа), достаточное для покрытия типичных окон повторных попыток. Используются быстрые хранилища типа Redis с автоматическим истечением срока (TTL).

4.  **Идемпотентность на уровне базы данных**. Использование уникальных индексов и ограничений для предотвращения дублирования. Например, добавление внешнего идентификатора запроса в качестве уникального ключа таблицы — повторная вставка с тем же идентификатором вызовет ошибку, а не дубликат.

5.  **Идемпотентная обработка сообщений**. В системах с брокерами сообщений ([[Message Broker|брокер сообщений]]) потребители запоминают идентификаторы уже обработанных сообщений в распределённом кэше или базе данных. Это позволяет безопасно использовать семантику at-least-once.

6.  **Условные обновления (optimistic concurrency control)**. Вместо безусловной замены ресурса используется версионирование: клиент указывает ожидаемую версию (ETag), и сервер выполняет обновление только при совпадении версии. Это гарантирует идемпотентность повторных запросов, так как после первого успешного обновления версия изменится, и последующие запросы будут отклонены.

7.  **Коммутативные и идемпотентные операции в конечном счёте**. Для счётчиков и агрегатов применяются операции, которые можно применять многократно без искажения результата: например, вместо `x = x + 1` (неидемпотентно) использовать `x = max(x, new_value)` или записывать событие «инкремент», которое система может дедуплицировать на основе идентификатора события.

8.  **Тестирование идемпотентности**. В тестовые сценарии включаются повторные отправки одинаковых запросов с проверкой, что состояние системы и ответы идентичны однократному выполнению.

9.  **Документирование контрактов идемпотентности**. В спецификации API явно указывается, какие операции идемпотентны, какие требуют ключа идемпотентности, каков срок хранения ключей и как клиенту следует генерировать ключи.

10. **Идемпотентность в сагах ([[Saga|saga]])**. При реализации распределённых транзакций компенсирующие действия должны быть идемпотентными, чтобы при сбоях повторные выполнения саги не привели к некорректной отмене уже отменённых операций.

Таким образом, идемпотентность является обязательным качеством операций, работающих в ненадёжных сетевых средах. Её систематическое применение превращает недетерминированные повторные попытки в предсказуемый механизм обеспечения надёжности. Современные практики смещают ответственность за генерацию ключей на клиента, а за дедупликацию — на сервер, что позволяет достичь exactly-once семантики в условиях at-least-once доставки.