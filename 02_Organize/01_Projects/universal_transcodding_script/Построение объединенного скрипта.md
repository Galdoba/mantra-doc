---
updated_at: 2025-12-17T12:29:21.964+10:00
tags:
  - universal_transcoding_script
---
Вот унифицированный шаблон скрипта, который автоматически определяет количество и тип аудиодорожек с использованием вашей утилиты `defineAudioStreams`:

```bash
#!/bin/bash

# Основные параметры обработки
PRIORITY=5                                         # Приоритет обработки
INPUT_FILE="_____________"                         # Имя исходного файла
OUTPUT_BASE="__________"                           # Базовое имя выходных файлов
REVISION_SUFFIX="_HD"                              # Суффикс для версии файла

# Базовые пути
HOME_ROOT="/home/pemaltynov"                       # Корневая домашняя директория
MOUNT_ROOT="/mnt/pemaltynov"                       # Корневая точка монтирования
ROOT_SUBPATH="ROOT"                                # Общий подпуть для архивных путей
EDIT_SUBPATH="EDIT/_______"                        # Подпуть для редактирования
ARCHIVE_SUBPATH="IN/_______"                       # Подпуть для архивации

# Параметры аудио
AUDIO_SAMPLE_RATE=48000                            # Частота дискретизации аудио (Гц)
AUDIO_TEMPO_DENOMINATOR="__"                       # Знаменатель для atempo (25/__)

# Параметры видео
VIDEO_FRAMERATE=25                                 # Частота кадров видео (fps)
VIDEO_SCALE_DIVISOR=2                              # Делитель масштаба для proxy видео
VIDEO_SAR_FACTOR=2                                 # Множитель для SAR proxy видео

# Параметры кодирования HD видео
VIDEO_HD_CODEC="libx264"                           # Кодек для HD видео
VIDEO_HD_PRESET="medium"                           # Пресет кодирования HD
VIDEO_HD_CRF=16                                    # CRF значение для HD
VIDEO_HD_PIX_FMT="yuv420p"                         # Пиксельный формат HD
VIDEO_HD_GOP_SIZE=0                                # Размер GOP (0 - только ключевые кадры)

# Параметры кодирования proxy видео
VIDEO_PROXY_CODEC="libx264"                        # Кодек для proxy видео
VIDEO_PROXY_PRESET="superfast"                     # Пресет кодирования proxy
VIDEO_PROXY_PIX_FMT="yuv420p"                      # Пиксельный формат proxy
VIDEO_PROXY_BITRATE="2000k"                        # Битрейт для proxy видео
VIDEO_PROXY_MAXRATE="2000k"                        # Максимальный битрейт proxy
VIDEO_PROXY_INTERLACED=1                           # Флаг чересстрочности proxy

# Параметры кодирования HD аудио
AUDIO_HD_CODEC="alac"                              # Кодек для HD аудио
AUDIO_HD_COMPRESSION_LEVEL=0                       # Уровень сжатия ALAC

# Параметры кодирования proxy аудио
AUDIO_PROXY_CODEC="ac3"                            # Кодек для proxy аудио
AUDIO_PROXY_BITRATE="128k"                         # Битрейт для proxy аудио

# Таймауты и задержки
ARCHIVE_DELAY="10 hours"                           # Задержка перед архивацией

# Составные пути
# Входные директории
INPUT_DIR="${HOME_ROOT}/IN"
PROGRESS_DIR="${INPUT_DIR}/_IN_PROGRESS"
NOTIFICATION_DIR="${INPUT_DIR}/notifications"
DONE_DIR="${INPUT_DIR}/_DONE"
SCRIPT_ARCHIVE_DIR="${DONE_DIR}/bash"

# Редактирование и архивация
EDIT_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${EDIT_SUBPATH}"
ARCHIVE_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${ARCHIVE_SUBPATH}"

# Создание путей
ARCHIVE_OUTPUT_PATH="${ARCHIVE_BASE_PATH}/_DONE/${OUTPUT_BASE}"
FULL_EDIT_PATH="${EDIT_BASE_PATH}"
FULL_NOTIFICATION_PATH="${NOTIFICATION_DIR}/${OUTPUT_BASE}.done"
FULL_DONE_PATH="${DONE_DIR}"
READY_FILE_PATH="${FULL_EDIT_PATH}/${OUTPUT_BASE}.ready"

# Создание необходимых директорий
mkdir -p "${ARCHIVE_OUTPUT_PATH}"
mkdir -p "${FULL_EDIT_PATH}"

# Очистка экрана и перемещение входного файла
clear
mv "${INPUT_DIR}/${INPUT_FILE}" "${PROGRESS_DIR}/"

# Определение аудиодорожек с помощью внешней утилиты
AUDIO_SUFFIXES=($(defineAudioStreams "${PROGRESS_DIR}/${INPUT_FILE}"))
AUDIO_TRACK_COUNT=${#AUDIO_SUFFIXES[@]}

# Формирование строк фильтров
AUDIO_FILTER="aresample=${AUDIO_SAMPLE_RATE},atempo=${VIDEO_FRAMERATE}/(${AUDIO_TEMPO_DENOMINATOR})"

# Базовый видеофильтр
VIDEO_FILTER="[0:v:0]split=2[vidHD][inProxy]; [inProxy]scale=iw/${VIDEO_SCALE_DIVISOR}:ih, setsar=(1/1)*${VIDEO_SAR_FACTOR}[vidHD_pr]"

# Добавление аудиофильтров для каждой дорожки
AUDIO_FILTERS=""
for i in $(seq 0 $((AUDIO_TRACK_COUNT - 1))); do
    AUDIO_FILTERS+="[0:a:${i}]${AUDIO_FILTER}[audio_in_${i}]; [audio_in_${i}]asplit=2[audio_${i}][audio_${i}_pr]"
    if [ $i -lt $((AUDIO_TRACK_COUNT - 1)) ]; then
        AUDIO_FILTERS+="; "
    fi
done

# Объединение видео и аудио фильтров
if [ ${AUDIO_TRACK_COUNT} -gt 0 ]; then
    FILTER_COMPLEX="${VIDEO_FILTER}; ${AUDIO_FILTERS}"
else
    FILTER_COMPLEX="${VIDEO_FILTER}"
fi

# Формирование имен выходных файлов для видео
VIDEO_HD_OUTPUT="${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}.mp4"
VIDEO_PROXY_OUTPUT="${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_proxy.mp4"

# Построение команды ffmpeg
FFMPEG_CMD="fflite -r ${VIDEO_FRAMERATE} -i \"${PROGRESS_DIR}/${INPUT_FILE}\" \
  -filter_complex \"${FILTER_COMPLEX}\" \
  -map \"[vidHD]\" -c:v ${VIDEO_HD_CODEC} -preset ${VIDEO_HD_PRESET} -crf ${VIDEO_HD_CRF} \
  -pix_fmt ${VIDEO_HD_PIX_FMT} -g ${VIDEO_HD_GOP_SIZE} -map_metadata -1 -map_chapters -1 \"${VIDEO_HD_OUTPUT}\" \
  -map \"[vidHD_pr]\" -c:v ${VIDEO_PROXY_CODEC} -x264opts interlaced=${VIDEO_PROXY_INTERLACED} \
  -preset ${VIDEO_PROXY_PRESET} -pix_fmt ${VIDEO_PROXY_PIX_FMT} -b:v ${VIDEO_PROXY_BITRATE} \
  -maxrate ${VIDEO_PROXY_MAXRATE} -map_metadata -1 -map_chapters -1 \"${VIDEO_PROXY_OUTPUT}\""

# Добавление аудиокарт для каждой дорожки
for i in $(seq 0 $((AUDIO_TRACK_COUNT - 1))); do
    AUDIO_HD_OUTPUT="${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${AUDIO_SUFFIXES[i]}.m4a"
    AUDIO_PROXY_OUTPUT="${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${AUDIO_SUFFIXES[i]}_proxy.ac3"
    
    FFMPEG_CMD+=" \
  -map \"[audio_${i}]\" -c:a ${AUDIO_HD_CODEC} -compression_level ${AUDIO_HD_COMPRESSION_LEVEL} \
  -map_metadata -1 -map_chapters -1 \"${AUDIO_HD_OUTPUT}\" \
  -map \"[audio_${i}_pr]\" -c:a ${AUDIO_PROXY_CODEC} -b:a ${AUDIO_PROXY_BITRATE} \"${AUDIO_PROXY_OUTPUT}\""
done

# Выполнение обработки
eval ${FFMPEG_CMD} && \
  
# Создание файла готовности
touch "${READY_FILE_PATH}" && \
  
# Создание файла уведомления
echo "${EDIT_SUBPATH}/${OUTPUT_BASE}.ready" > "${FULL_NOTIFICATION_PATH}" && \
  
# Перемещение обработанного файла во временную директорию
mv "${PROGRESS_DIR}/${INPUT_FILE}" "${FULL_DONE_PATH}/" && \
  
# Отложенное перемещение файла в архив
at now + ${ARCHIVE_DELAY} <<< "mv ${FULL_DONE_PATH}/${INPUT_FILE} ${ARCHIVE_OUTPUT_PATH}" && \
  
# Очистка и архивация скрипта
clear
mv "$0" "${SCRIPT_ARCHIVE_DIR}/"
```

## Основные изменения:

1. **Автоматическое определение аудиодорожек**: 
   - Используется утилита `defineAudioStreams` для получения списка суффиксов
   - Результат сохраняется в массив `AUDIO_SUFFIXES`
   - Количество дорожек вычисляется автоматически

2. **Динамическое построение фильтров**:
   - Видеофильтр строится один раз
   - Аудиофильтры добавляются в цикле для каждой дорожки
   - Каждая дорожка получает уникальные имена потоков (`audio_0`, `audio_0_pr`, и т.д.)

3. **Динамическое построение команды ffmpeg**:
   - Базовая команда строится с видео картами
   - Аудиокарты добавляются в цикле для каждой дорожки
   - Имена выходных файлов формируются с использованием суффиксов из утилиты

4. **Гибкость**:
   - Работает с любым количеством аудиодорожек (0, 1, 2, 3, ...)
   - Поддерживает разные форматы дорожек (стерео, 5.1, моно и т.д.)
   - Автоматически определяет язык дорожки

## Особенности работы:

- Если аудиодорожек нет (`AUDIO_TRACK_COUNT=0`), скрипт создаст только видеофайлы
- Для каждой аудиодорожки создается пара файлов: HD (ALAC) и proxy (AC3)
- Имена файлов формируются по шаблону: `{BASENAME}_HD_{SUFFIX}.m4a` и `{BASENAME}_HD_{SUFFIX}_proxy.ac3`

Этот универсальный шаблон заменит оба ваших предыдущих скрипта и будет работать с любым количеством аудиодорожек.

---

Вот улучшенный скрипт с корректным добавлением разделителей в `filter_complex`:

```bash
#!/bin/bash

# Основные параметры обработки
PRIORITY=5                                         # Приоритет обработки
INPUT_FILE="_____________"                         # Имя исходного файла
OUTPUT_BASE="__________"                           # Базовое имя выходных файлов
REVISION_SUFFIX="_HD"                              # Суффикс для версии файла

# Базовые пути
HOME_ROOT="/home/pemaltynov"                       # Корневая домашняя директория
MOUNT_ROOT="/mnt/pemaltynov"                       # Корневая точка монтирования
ROOT_SUBPATH="ROOT"                                # Общий подпуть для архивных путей
EDIT_SUBPATH="EDIT/_______"                        # Подпуть для редактирования
ARCHIVE_SUBPATH="IN/_______"                       # Подпуть для архивации

# Параметры аудио
AUDIO_SAMPLE_RATE=48000                            # Частота дискретизации аудио (Гц)
AUDIO_TEMPO_DENOMINATOR="__"                       # Знаменатель для atempo (25/__)

# Параметры видео
VIDEO_FRAMERATE=25                                 # Частота кадров видео (fps)
VIDEO_SCALE_DIVISOR=2                              # Делитель масштаба для proxy видео
VIDEO_SAR_FACTOR=2                                 # Множитель для SAR proxy видео

# Параметры кодирования HD видео
VIDEO_HD_CODEC="libx264"                           # Кодек для HD видео
VIDEO_HD_PRESET="medium"                           # Пресет кодирования HD
VIDEO_HD_CRF=16                                    # CRF значение для HD
VIDEO_HD_PIX_FMT="yuv420p"                         # Пиксельный формат HD
VIDEO_HD_GOP_SIZE=0                                # Размер GOP (0 - только ключевые кадры)

# Параметры кодирования proxy видео
VIDEO_PROXY_CODEC="libx264"                        # Кодек для proxy видео
VIDEO_PROXY_PRESET="superfast"                     # Пресет кодирования proxy
VIDEO_PROXY_PIX_FMT="yuv420p"                      # Пиксельный формат proxy
VIDEO_PROXY_BITRATE="2000k"                        # Битрейт для proxy видео
VIDEO_PROXY_MAXRATE="2000k"                        # Максимальный битрейт proxy
VIDEO_PROXY_INTERLACED=1                           # Флаг чересстрочности proxy

# Параметры кодирования HD аудио
AUDIO_HD_CODEC="alac"                              # Кодек для HD аудио
AUDIO_HD_COMPRESSION_LEVEL=0                       # Уровень сжатия ALAC

# Параметры кодирования proxy аудио
AUDIO_PROXY_CODEC="ac3"                            # Кодек для proxy аудио
AUDIO_PROXY_BITRATE="128k"                         # Битрейт для proxy аудио

# Таймауты и задержки
ARCHIVE_DELAY="10 hours"                           # Задержка перед архивацией

# Составные пути
# Входные директории
INPUT_DIR="${HOME_ROOT}/IN"
PROGRESS_DIR="${INPUT_DIR}/_IN_PROGRESS"
NOTIFICATION_DIR="${INPUT_DIR}/notifications"
DONE_DIR="${INPUT_DIR}/_DONE"
SCRIPT_ARCHIVE_DIR="${DONE_DIR}/bash"

# Редактирование и архивация
EDIT_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${EDIT_SUBPATH}"
ARCHIVE_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${ARCHIVE_SUBPATH}"

# Создание путей
ARCHIVE_OUTPUT_PATH="${ARCHIVE_BASE_PATH}/_DONE/${OUTPUT_BASE}"
FULL_EDIT_PATH="${EDIT_BASE_PATH}"
FULL_NOTIFICATION_PATH="${NOTIFICATION_DIR}/${OUTPUT_BASE}.done"
FULL_DONE_PATH="${DONE_DIR}"
READY_FILE_PATH="${FULL_EDIT_PATH}/${OUTPUT_BASE}.ready"

# Функция для построения видеофильтра
build_video_filter() {
    local video_filter="[0:v:0]split=2[vidHD][inProxy]; "
    video_filter+="[inProxy]scale=iw/${VIDEO_SCALE_DIVISOR}:ih, setsar=(1/1)*${VIDEO_SAR_FACTOR}[vidHD_pr]"
    echo "$video_filter"
}

# Функция для построения аудиофильтров
build_audio_filter() {
    local audio_count=$1
    local audio_suffixes=("${!2}")
    local audio_filter_base="aresample=${AUDIO_SAMPLE_RATE},atempo=${VIDEO_FRAMERATE}/(${AUDIO_TEMPO_DENOMINATOR})"
    local audio_filters=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        audio_filters+="[0:a:${i}]${audio_filter_base}[audio_in_${i}]; "
        audio_filters+="[audio_in_${i}]asplit=2[audio_${i}][audio_${i}_pr]; "
    done
    
    # Удаляем последний разделитель "; "
    audio_filters="${audio_filters%; }"
    
    echo "$audio_filters"
}

# Функция для построения комплексного фильтра
build_filter_complex() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local filter_complex=""
    
    # Добавляем видеофильтр
    filter_complex+=$(build_video_filter)
    
    # Добавляем разделитель, если будут аудиофильтры
    if [ "$audio_count" -gt 0 ]; then
        filter_complex+="; "
        filter_complex+=$(build_audio_filter "$audio_count" audio_suffixes[@])
    fi
    
    echo "$filter_complex"
}

# Функция для построения видео карт
build_video_maps() {
    local video_maps=""
    
    # HD видео карта
    video_maps+="-map \"[vidHD]\" -c:v ${VIDEO_HD_CODEC} -preset ${VIDEO_HD_PRESET} -crf ${VIDEO_HD_CRF} "
    video_maps+="-pix_fmt ${VIDEO_HD_PIX_FMT} -g ${VIDEO_HD_GOP_SIZE} -map_metadata -1 -map_chapters -1 "
    video_maps+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}.mp4\" "
    
    # Proxy видео карта
    video_maps+="-map \"[vidHD_pr]\" -c:v ${VIDEO_PROXY_CODEC} -x264opts interlaced=${VIDEO_PROXY_INTERLACED} "
    video_maps+="-preset ${VIDEO_PROXY_PRESET} -pix_fmt ${VIDEO_PROXY_PIX_FMT} -b:v ${VIDEO_PROXY_BITRATE} "
    video_maps+="-maxrate ${VIDEO_PROXY_MAXRATE} -map_metadata -1 -map_chapters -1 "
    video_maps+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_proxy.mp4\" "
    
    echo "$video_maps"
}

# Функция для построения аудио карт
build_audio_maps() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    local audio_maps=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        # HD аудио карта
        audio_maps+="-map \"[audio_${i}]\" -c:a ${AUDIO_HD_CODEC} "
        audio_maps+="-compression_level ${AUDIO_HD_COMPRESSION_LEVEL} -map_metadata -1 -map_chapters -1 "
        audio_maps+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffixes[i]}.m4a\" "
        
        # Proxy аудио карта
        audio_maps+="-map \"[audio_${i}_pr]\" -c:a ${AUDIO_PROXY_CODEC} -b:a ${AUDIO_PROXY_BITRATE} "
        audio_maps+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffixes[i]}_proxy.ac3\" "
    done
    
    echo "$audio_maps"
}

# Функция для построения полной команды ffmpeg
build_ffmpeg_command() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local filter_complex=$(build_filter_complex "$audio_count" "${audio_suffixes[@]}")
    local video_maps=$(build_video_maps)
    local audio_maps=$(build_audio_maps "$audio_count" "${audio_suffixes[@]}")
    
    local command="fflite -r ${VIDEO_FRAMERATE} -i \"${PROGRESS_DIR}/${INPUT_FILE}\" "
    command+="-filter_complex \"${filter_complex}\" "
    command+="${video_maps}"
    
    if [ "$audio_count" -gt 0 ]; then
        command+="${audio_maps}"
    fi
    
    # Удаляем последний пробел
    command="${command% }"
    
    echo "$command"
}

# Создание необходимых директорий
mkdir -p "${ARCHIVE_OUTPUT_PATH}"
mkdir -p "${FULL_EDIT_PATH}"

# Очистка экрана и перемещение входного файла
clear
mv "${INPUT_DIR}/${INPUT_FILE}" "${PROGRESS_DIR}/"

# Определение аудиодорожек с помощью внешней утилиты
AUDIO_SUFFIXES=($(defineAudioStreams "${PROGRESS_DIR}/${INPUT_FILE}"))
AUDIO_TRACK_COUNT=${#AUDIO_SUFFIXES[@]}

# Построение и выполнение команды ffmpeg
FFMPEG_CMD=$(build_ffmpeg_command "$AUDIO_TRACK_COUNT" "${AUDIO_SUFFIXES[@]}")
eval ${FFMPEG_CMD} && \
  
# Создание файла готовности
touch "${READY_FILE_PATH}" && \
  
# Создание файла уведомления
echo "${EDIT_SUBPATH}/${OUTPUT_BASE}.ready" > "${FULL_NOTIFICATION_PATH}" && \
  
# Перемещение обработанного файла во временную директорию
mv "${PROGRESS_DIR}/${INPUT_FILE}" "${FULL_DONE_PATH}/" && \
  
# Отложенное перемещение файла в архив
at now + ${ARCHIVE_DELAY} <<< "mv ${FULL_DONE_PATH}/${INPUT_FILE} ${ARCHIVE_OUTPUT_PATH}" && \
  
# Очистка и архивация скрипта
clear
mv "$0" "${SCRIPT_ARCHIVE_DIR}/"
```

## Основные улучшения:

### 1. **Корректное построение `filter_complex`**:
   - Каждый блок фильтра добавляется с разделителем `"; "`
   - В конце каждого цикла добавляется разделитель
   - После завершения построения удаляется последний лишний разделитель с помощью `${filter%; }`

### 2. **Улучшенная функция `build_audio_filter()`**:
   - Добавлен разделитель после каждого аудиофильтра
   - Удаление последнего разделителя после завершения цикла
   - Более наглядное форматирование

### 3. **Функция `build_filter_complex()`**:
   - Построение начинается с видеофильтра
   - Добавляется разделитель только если есть аудиофильтры
   - Конкатенация частей выполняется корректно

### 4. **Функция `build_ffmpeg_command()`**:
   - Удаление последнего пробела в конце команды
   - Более чистое форматирование строки команды

### 5. **Консистентное использование разделителей**:
   - Все функции используют одинаковый подход с добавлением и последующим удалением разделителей
   - Улучшена читаемость и отладка фильтров

## Преимущества:

1. **Читаемость**: Теперь `filter_complex` выглядит как последовательность четко разделенных блоков
2. **Отладка**: Легче видеть, где заканчивается один блок и начинается другой
3. **Надежность**: Устранена возможность появления лишних разделителей в конце
4. **Расширяемость**: Легко добавлять новые блоки фильтров с тем же подходом

## Пример получаемого `filter_complex`:

Для файла с 2 аудиодорожками будет построен такой фильтр:
```
[0:v:0]split=2[vidHD][inProxy]; [inProxy]scale=iw/2:ih, setsar=(1/1)*2[vidHD_pr]; [0:a:0]aresample=48000,atempo=25/(__)[audio_in_0]; [audio_in_0]asplit=2[audio_0][audio_0_pr]; [0:a:1]aresample=48000,atempo=25/(__)[audio_in_1]; [audio_in_1]asplit=2[audio_1][audio_1_pr]
```

Каждый блок четко отделен точкой с запятой и пробелом, что делает фильтр легко читаемым и отлаживаемым.

---

Вот список функций, необходимых для построения окончательной строки команды ffmpeg в соответствии с блочной структурой:

```bash
# 1. Функция для построения глобальных параметров
build_global_parameters() {
    local global_params="-r ${VIDEO_FRAMERATE}"
    echo "$global_params"
}

# 2. Функция для построения блока входных файлов
build_inputs() {
    local inputs="-i \"${PROGRESS_DIR}/${INPUT_FILE}\""
    echo "$inputs"
}

# 3. Функция для построения видеофильтров (часть filter_complex)
build_video_filters() {
    local video_filters="[0:v:0]split=2[vidHD][inProxy]; "
    video_filters+="[inProxy]scale=iw/${VIDEO_SCALE_DIVISOR}:ih, setsar=(1/1)*${VIDEO_SAR_FACTOR}[vidHD_pr]"
    echo "$video_filters"
}

# 4. Функция для построения аудиофильтра для одной дорожки
build_audio_filter_for_track() {
    local track_index=$1
    local audio_filter_base="aresample=${AUDIO_SAMPLE_RATE},atempo=${VIDEO_FRAMERATE}/(${AUDIO_TEMPO_DENOMINATOR})"
    
    local audio_filter="[0:a:${track_index}]${audio_filter_base}[audio_in_${track_index}]; "
    audio_filter+="[audio_in_${track_index}]asplit=2[audio_${track_index}][audio_${track_index}_pr]"
    
    echo "$audio_filter"
}

# 5. Функция для построения всех аудиофильтров
build_all_audio_filters() {
    local audio_count=$1
    local audio_suffixes=("${!2}")
    local all_audio_filters=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        all_audio_filters+=$(build_audio_filter_for_track "$i")
        all_audio_filters+="; "
    done
    
    # Удаляем последний разделитель
    all_audio_filters="${all_audio_filters%; }"
    
    echo "$all_audio_filters"
}

# 6. Функция для построения всего filter_complex
build_filter_complex() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local filter_complex=$(build_video_filters)
    
    if [ "$audio_count" -gt 0 ]; then
        filter_complex+="; "
        filter_complex+=$(build_all_audio_filters "$audio_count" audio_suffixes[@])
    fi
    
    echo "$filter_complex"
}

# 7. Функция для построения карты HD видео
build_video_hd_map() {
    local map="-map \"[vidHD]\" "
    map+="-c:v ${VIDEO_HD_CODEC} "
    map+="-preset ${VIDEO_HD_PRESET} "
    map+="-crf ${VIDEO_HD_CRF} "
    map+="-pix_fmt ${VIDEO_HD_PIX_FMT} "
    map+="-g ${VIDEO_HD_GOP_SIZE} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}.mp4\""
    
    echo "$map"
}

# 8. Функция для построения карты proxy видео
build_video_proxy_map() {
    local map="-map \"[vidHD_pr]\" "
    map+="-c:v ${VIDEO_PROXY_CODEC} "
    map+="-x264opts interlaced=${VIDEO_PROXY_INTERLACED} "
    map+="-preset ${VIDEO_PROXY_PRESET} "
    map+="-pix_fmt ${VIDEO_PROXY_PIX_FMT} "
    map+="-b:v ${VIDEO_PROXY_BITRATE} "
    map+="-maxrate ${VIDEO_PROXY_MAXRATE} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_proxy.mp4\""
    
    echo "$map"
}

# 9. Функция для построения карты HD аудио для одной дорожки
build_audio_hd_map_for_track() {
    local track_index=$1
    local audio_suffix=$2
    
    local map="-map \"[audio_${track_index}]\" "
    map+="-c:a ${AUDIO_HD_CODEC} "
    map+="-compression_level ${AUDIO_HD_COMPRESSION_LEVEL} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffix}.m4a\""
    
    echo "$map"
}

# 10. Функция для построения карты proxy аудио для одной дорожки
build_audio_proxy_map_for_track() {
    local track_index=$1
    local audio_suffix=$2
    
    local map="-map \"[audio_${track_index}_pr]\" "
    map+="-c:a ${AUDIO_PROXY_CODEC} "
    map+="-b:a ${AUDIO_PROXY_BITRATE} "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffix}_proxy.ac3\""
    
    echo "$map"
}

# 11. Функция для построения всех аудио карт (HD + proxy для каждой дорожки)
build_all_audio_maps() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    local all_audio_maps=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        all_audio_maps+=$(build_audio_hd_map_for_track "$i" "${audio_suffixes[i]}")
        all_audio_maps+=" "
        all_audio_maps+=$(build_audio_proxy_map_for_track "$i" "${audio_suffixes[i]}")
        all_audio_maps+=" "
    done
    
    # Удаляем последний пробел
    all_audio_maps="${all_audio_maps% }"
    
    echo "$all_audio_maps"
}

# 12. Функция для построения всех видео карт (HD + proxy)
build_all_video_maps() {
    local video_maps=$(build_video_hd_map)
    video_maps+=" "
    video_maps+=$(build_video_proxy_map)
    
    echo "$video_maps"
}

# 13. Функция для построения всех карт вывода (видео + аудио)
build_all_maps() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local all_maps=$(build_all_video_maps)
    
    if [ "$audio_count" -gt 0 ]; then
        all_maps+=" "
        all_maps+=$(build_all_audio_maps "$audio_count" "${audio_suffixes[@]}")
    fi
    
    echo "$all_maps"
}

# 14. Функция для построения полной команды ffmpeg
build_ffmpeg_command() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local global_params=$(build_global_parameters)
    local inputs=$(build_inputs)
    local filter_complex=$(build_filter_complex "$audio_count" "${audio_suffixes[@]}")
    local maps=$(build_all_maps "$audio_count" "${audio_suffixes[@]}")
    
    local command="fflite ${global_params} ${inputs} "
    command+="-filter_complex \"${filter_complex}\" "
    command+="${maps}"
    
    echo "$command"
}
```

## Структура функций соответствует блокам команды:

### **Глобальные параметры**:
1. `build_global_parameters()` - строит глобальные параметры (например, `-r 25`)

### **Входные файлы**:
2. `build_inputs()` - строит блок входных файлов (например, `-i "/path/to/file.mxf"`)

### **Фильтры (filter_complex)**:
3. `build_video_filters()` - строит видеофильтры
4. `build_audio_filter_for_track()` - строит аудиофильтр для одной дорожки
5. `build_all_audio_filters()` - строит все аудиофильтры
6. `build_filter_complex()` - объединяет все фильтры

### **Карты вывода (maps)**:
7. `build_video_hd_map()` - строит карту для HD видео
8. `build_video_proxy_map()` - строит карту для proxy видео
9. `build_audio_hd_map_for_track()` - строит карту для HD аудио одной дорожки
10. `build_audio_proxy_map_for_track()` - строит карту для proxy аудио одной дорожки
11. `build_all_audio_maps()` - строит все аудио карты
12. `build_all_video_maps()` - строит все видео карты
13. `build_all_maps()` - объединяет все карты

### **Финальная сборка**:
14. `build_ffmpeg_command()` - собирает все компоненты в полную команду

## Преимущества такой структуры:

1. **Модульность**: Каждая функция отвечает за один небольшой компонент
2. **Переиспользование**: Функции можно легко комбинировать для разных сценариев
3. **Тестируемость**: Каждый компонент можно тестировать отдельно
4. **Расширяемость**: Легко добавлять новые типы потоков (например, субтитры, дополнительные видеоформаты)
5. **Читаемость**: Четкое соответствие между структурой команды и функциями

Эта структура позволяет легко модифицировать любой аспект команды ffmpeg без изменения остальной логики.

---

Вот унифицированный скрипт с использованием функций построения блоков команды ffmpeg:

```bash
#!/bin/bash

# Основные параметры обработки
PRIORITY=5                                         # Приоритет обработки
INPUT_FILE="_____________"                         # Имя исходного файла
OUTPUT_BASE="__________"                           # Базовое имя выходных файлов
REVISION_SUFFIX="_HD"                              # Суффикс для версии файла

# Базовые пути
HOME_ROOT="/home/pemaltynov"                       # Корневая домашняя директория
MOUNT_ROOT="/mnt/pemaltynov"                       # Корневая точка монтирования
ROOT_SUBPATH="ROOT"                                # Общий подпуть для архивных путей
EDIT_SUBPATH="EDIT/_______"                        # Подпуть для редактирования
ARCHIVE_SUBPATH="IN/_______"                       # Подпуть для архивации

# Параметры аудио
AUDIO_SAMPLE_RATE=48000                            # Частота дискретизации аудио (Гц)
AUDIO_TEMPO_DENOMINATOR="__"                       # Знаменатель для atempo (25/__)

# Параметры видео
VIDEO_FRAMERATE=25                                 # Частота кадров видео (fps)
VIDEO_SCALE_DIVISOR=2                              # Делитель масштаба для proxy видео
VIDEO_SAR_FACTOR=2                                 # Множитель для SAR proxy видео

# Параметры кодирования HD видео
VIDEO_HD_CODEC="libx264"                           # Кодек для HD видео
VIDEO_HD_PRESET="medium"                           # Пресет кодирования HD
VIDEO_HD_CRF=16                                    # CRF значение для HD
VIDEO_HD_PIX_FMT="yuv420p"                         # Пиксельный формат HD
VIDEO_HD_GOP_SIZE=0                                # Размер GOP (0 - только ключевые кадры)

# Параметры кодирования proxy видео
VIDEO_PROXY_CODEC="libx264"                        # Кодек для proxy видео
VIDEO_PROXY_PRESET="superfast"                     # Пресет кодирования proxy
VIDEO_PROXY_PIX_FMT="yuv420p"                      # Пиксельный формат proxy
VIDEO_PROXY_BITRATE="2000k"                        # Битрейт для proxy видео
VIDEO_PROXY_MAXRATE="2000k"                        # Максимальный битрейт proxy
VIDEO_PROXY_INTERLACED=1                           # Флаг чересстрочности proxy

# Параметры кодирования HD аудио
AUDIO_HD_CODEC="alac"                              # Кодек для HD аудио
AUDIO_HD_COMPRESSION_LEVEL=0                       # Уровень сжатия ALAC

# Параметры кодирования proxy аудио
AUDIO_PROXY_CODEC="ac3"                            # Кодек для proxy аудио
AUDIO_PROXY_BITRATE="128k"                         # Битрейт для proxy аудио

# Таймауты и задержки
ARCHIVE_DELAY="10 hours"                           # Задержка перед архивацией

# Составные пути
# Входные директории
INPUT_DIR="${HOME_ROOT}/IN"
PROGRESS_DIR="${INPUT_DIR}/_IN_PROGRESS"
NOTIFICATION_DIR="${INPUT_DIR}/notifications"
DONE_DIR="${INPUT_DIR}/_DONE"
SCRIPT_ARCHIVE_DIR="${DONE_DIR}/bash"

# Редактирование и архивация
EDIT_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${EDIT_SUBPATH}"
ARCHIVE_BASE_PATH="${MOUNT_ROOT}/${ROOT_SUBPATH}/${ARCHIVE_SUBPATH}"

# Создание путей
ARCHIVE_OUTPUT_PATH="${ARCHIVE_BASE_PATH}/_DONE/${OUTPUT_BASE}"
FULL_EDIT_PATH="${EDIT_BASE_PATH}"
FULL_NOTIFICATION_PATH="${NOTIFICATION_DIR}/${OUTPUT_BASE}.done"
FULL_DONE_PATH="${DONE_DIR}"
READY_FILE_PATH="${FULL_EDIT_PATH}/${OUTPUT_BASE}.ready"

# ============================================================================
# ФУНКЦИИ ПОСТРОЕНИЯ БЛОКОВ КОМАНДЫ FFMEPG
# ============================================================================

# Функция для построения глобальных параметров
build_global_parameters() {
    local global_params="-r ${VIDEO_FRAMERATE}"
    echo "$global_params"
}

# Функция для построения блока входных файлов
build_inputs() {
    local inputs="-i \"${PROGRESS_DIR}/${INPUT_FILE}\""
    echo "$inputs"
}

# Функция для построения видеофильтров (часть filter_complex)
build_video_filters() {
    local video_filters="[0:v:0]split=2[vidHD][inProxy]; "
    video_filters+="[inProxy]scale=iw/${VIDEO_SCALE_DIVISOR}:ih, setsar=(1/1)*${VIDEO_SAR_FACTOR}[vidHD_pr]"
    echo "$video_filters"
}

# Функция для построения аудиофильтра для одной дорожки
build_audio_filter_for_track() {
    local track_index=$1
    local audio_filter_base="aresample=${AUDIO_SAMPLE_RATE},atempo=${VIDEO_FRAMERATE}/(${AUDIO_TEMPO_DENOMINATOR})"
    
    local audio_filter="[0:a:${track_index}]${audio_filter_base}[audio_in_${track_index}]; "
    audio_filter+="[audio_in_${track_index}]asplit=2[audio_${track_index}][audio_${track_index}_pr]"
    
    echo "$audio_filter"
}

# Функция для построения всех аудиофильтров
build_all_audio_filters() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    if [ "$audio_count" -eq 0 ]; then
        echo ""
        return 0
    fi
    
    local all_audio_filters=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        all_audio_filters+=$(build_audio_filter_for_track "$i")
        all_audio_filters+="; "
    done
    
    # Удаляем последний разделитель
    all_audio_filters="${all_audio_filters%; }"
    
    echo "$all_audio_filters"
}

# Функция для построения всего filter_complex
build_filter_complex() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local filter_complex=$(build_video_filters)
    local audio_filters=$(build_all_audio_filters "$audio_count" "${audio_suffixes[@]}")
    
    if [ -n "$audio_filters" ]; then
        filter_complex+="; "
        filter_complex+="$audio_filters"
    fi
    
    echo "$filter_complex"
}

# Функция для построения карты HD видео
build_video_hd_map() {
    local map="-map \"[vidHD]\" "
    map+="-c:v ${VIDEO_HD_CODEC} "
    map+="-preset ${VIDEO_HD_PRESET} "
    map+="-crf ${VIDEO_HD_CRF} "
    map+="-pix_fmt ${VIDEO_HD_PIX_FMT} "
    map+="-g ${VIDEO_HD_GOP_SIZE} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}.mp4\""
    
    echo "$map"
}

# Функция для построения карты proxy видео
build_video_proxy_map() {
    local map="-map \"[vidHD_pr]\" "
    map+="-c:v ${VIDEO_PROXY_CODEC} "
    map+="-x264opts interlaced=${VIDEO_PROXY_INTERLACED} "
    map+="-preset ${VIDEO_PROXY_PRESET} "
    map+="-pix_fmt ${VIDEO_PROXY_PIX_FMT} "
    map+="-b:v ${VIDEO_PROXY_BITRATE} "
    map+="-maxrate ${VIDEO_PROXY_MAXRATE} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_proxy.mp4\""
    
    echo "$map"
}

# Функция для построения карты HD аудио для одной дорожки
build_audio_hd_map_for_track() {
    local track_index=$1
    local audio_suffix=$2
    
    local map="-map \"[audio_${track_index}]\" "
    map+="-c:a ${AUDIO_HD_CODEC} "
    map+="-compression_level ${AUDIO_HD_COMPRESSION_LEVEL} "
    map+="-map_metadata -1 "
    map+="-map_chapters -1 "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffix}.m4a\""
    
    echo "$map"
}

# Функция для построения карты proxy аудио для одной дорожки
build_audio_proxy_map_for_track() {
    local track_index=$1
    local audio_suffix=$2
    
    local map="-map \"[audio_${track_index}_pr]\" "
    map+="-c:a ${AUDIO_PROXY_CODEC} "
    map+="-b:a ${AUDIO_PROXY_BITRATE} "
    map+="\"${FULL_EDIT_PATH}/${OUTPUT_BASE}${REVISION_SUFFIX}_${audio_suffix}_proxy.ac3\""
    
    echo "$map"
}

# Функция для построения всех аудио карт (HD + proxy для каждой дорожки)
build_all_audio_maps() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    if [ "$audio_count" -eq 0 ]; then
        echo ""
        return 0
    fi
    
    local all_audio_maps=""
    
    for i in $(seq 0 $((audio_count - 1))); do
        all_audio_maps+=$(build_audio_hd_map_for_track "$i" "${audio_suffixes[i]}")
        all_audio_maps+=" "
        all_audio_maps+=$(build_audio_proxy_map_for_track "$i" "${audio_suffixes[i]}")
        all_audio_maps+=" "
    done
    
    # Удаляем последний пробел
    all_audio_maps="${all_audio_maps% }"
    
    echo "$all_audio_maps"
}

# Функция для построения всех видео карт (HD + proxy)
build_all_video_maps() {
    local video_maps=$(build_video_hd_map)
    video_maps+=" "
    video_maps+=$(build_video_proxy_map)
    
    echo "$video_maps"
}

# Функция для построения всех карт вывода (видео + аудио)
build_all_maps() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local all_maps=$(build_all_video_maps)
    local audio_maps=$(build_all_audio_maps "$audio_count" "${audio_suffixes[@]}")
    
    if [ -n "$audio_maps" ]; then
        all_maps+=" "
        all_maps+="$audio_maps"
    fi
    
    echo "$all_maps"
}

# Функция для построения полной команды ffmpeg
build_ffmpeg_command() {
    local audio_count=$1
    shift
    local audio_suffixes=("$@")
    
    local global_params=$(build_global_parameters)
    local inputs=$(build_inputs)
    local filter_complex=$(build_filter_complex "$audio_count" "${audio_suffixes[@]}")
    local maps=$(build_all_maps "$audio_count" "${audio_suffixes[@]}")
    
    local command="fflite ${global_params} ${inputs} "
    command+="-filter_complex \"${filter_complex}\" "
    command+="${maps}"
    
    echo "$command"
}

# ============================================================================
# ОСНОВНОЙ КОД СКРИПТА
# ============================================================================

# Создание необходимых директорий
mkdir -p "${ARCHIVE_OUTPUT_PATH}"
mkdir -p "${FULL_EDIT_PATH}"

# Очистка экрана и перемещение входного файла
clear
mv "${INPUT_DIR}/${INPUT_FILE}" "${PROGRESS_DIR}/"

# Определение аудиодорожек с помощью внешней утилиты
AUDIO_SUFFIXES=($(defineAudioStreams "${PROGRESS_DIR}/${INPUT_FILE}"))
AUDIO_TRACK_COUNT=${#AUDIO_SUFFIXES[@]}

echo "Найдено аудиодорожек: ${AUDIO_TRACK_COUNT}"
if [ ${AUDIO_TRACK_COUNT} -gt 0 ]; then
    echo "Суффиксы аудиодорожек: ${AUDIO_SUFFIXES[@]}"
fi

# Построение и выполнение команды ffmpeg
echo "Построение команды ffmpeg..."
FFMPEG_CMD=$(build_ffmpeg_command "$AUDIO_TRACK_COUNT" "${AUDIO_SUFFIXES[@]}")
echo "Выполнение команды:"
echo "${FFMPEG_CMD}"
echo ""

eval ${FFMPEG_CMD} && \
  
# Создание файла готовности
touch "${READY_FILE_PATH}" && \
  
# Создание файла уведомления
echo "${EDIT_SUBPATH}/${OUTPUT_BASE}.ready" > "${FULL_NOTIFICATION_PATH}" && \
  
# Перемещение обработанного файла во временную директорию
mv "${PROGRESS_DIR}/${INPUT_FILE}" "${FULL_DONE_PATH}/" && \
  
# Отложенное перемещение файла в архив
at now + ${ARCHIVE_DELAY} <<< "mv ${FULL_DONE_PATH}/${INPUT_FILE} ${ARCHIVE_OUTPUT_PATH}" && \
  
# Очистка и архивация скрипта
clear
mv "$0" "${SCRIPT_ARCHIVE_DIR}/"
```

## Структура скрипта:

### **Часть 1: Определение параметров** (строки 1-78)
- Все переменные конфигурации (пути, параметры кодирования, таймауты)

### **Часть 2: Функции построения блоков** (строки 83-229)
- **`build_global_parameters()`**: Глобальные параметры ffmpeg (частота кадров)
- **`build_inputs()`**: Блок входных файлов (-i параметры)
- **`build_video_filters()`**: Видеофильтры для filter_complex
- **`build_audio_filter_for_track()`**: Аудиофильтр для одной дорожки
- **`build_all_audio_filters()`**: Все аудиофильтры
- **`build_filter_complex()`**: Полный filter_complex (видео + аудио)
- **`build_video_hd_map()`**: Карта для HD видео
- **`build_video_proxy_map()`**: Карта для proxy видео
- **`build_audio_hd_map_for_track()`**: Карта для HD аудио одной дорожки
- **`build_audio_proxy_map_for_track()`**: Карта для proxy аудио одной дорожки
- **`build_all_audio_maps()`**: Все аудиокарты (HD + proxy для каждой дорожки)
- **`build_all_video_maps()`**: Все видеокарты (HD + proxy)
- **`build_all_maps()`**: Все карты вывода (видео + аудио)
- **`build_ffmpeg_command()`**: Полная команда ffmpeg

### **Часть 3: Основной код** (строки 234-276)
- Создание директорий
- Перемещение входного файла
- Определение аудиодорожек через утилиту defineAudioStreams
- Построение и выполнение команды ffmpeg
- Пост-обработка (файлы готовности, уведомления, архивация)

## Ключевые особенности:

1. **Модульность**: Каждый блок команды ffmpeg строится отдельной функцией
2. **Гибкость**: Легко добавлять новые типы потоков (субтитры, дополнительные видеоформаты)
3. **Масштабируемость**: Функции могут быть легко переиспользованы в других скриптах
4. **Поддержка любого количества аудиодорожек**: От 0 до N
5. **Корректное форматирование**: Правильное добавление и удаление разделителей между блоками
6. **Отладочная информация**: Вывод информации о найденных аудиодорожках и команде ffmpeg

## Пример использования:

Скрипт автоматически определяет количество и тип аудиодорожек, строит соответствующую команду ffmpeg и выполняет ее. Все созданные файлы помещаются в нужные директории, а исходный файл после обработки перемещается в архив с задержкой.