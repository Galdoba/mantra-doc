---
updated_at: 2026-02-12T16:51:28.461+10:00
---
## Тестовая заглушка: имитация зависимостей в изолированном тестировании

**Тестовая заглушка** ({{Test Double|test double}}) — это обобщённое название для любых объектов или компонентов, заменяющих реальные зависимости тестируемой системы в условиях изолированного тестирования. Термин введён Джерардом Месарошем и охватывает все разновидности имитационных объектов: [[Dummy|фиктивные объекты]], [[Stub|заглушки]], [[Spy|шпионы]], [[Mock|имитации]] и [[Fake|подделки]]. Тестовая заглушка предоставляет контролируемое окружение, позволяя проверять поведение тестируемого модуля без влияния реальных зависимостей.

### Назначение
Применение тестовых заглушек решает фундаментальные задачи модульного тестирования и не только:

*   **Изоляция тестируемого кода**. Устранение зависимости от баз данных, сетевых сервисов, файловой системы, времени и других недетерминированных или медленных компонентов.
*   **Контроль над входными данными**. Возможность моделировать любые возвращаемые значения, исключения и состояния зависимостей для проверки всех ветвлений логики.
*   **Верификация взаимодействий**. Проверка того, что тестируемый модуль вызывает определённые методы зависимостей с ожидаемыми параметрами и в нужной последовательности.
*   **Ускорение выполнения тестов**. Заглушки работают в памяти и не выполняют реальных операций ввода-вывода, что сокращает время тестирования на порядки.
*   **Воспроизводимость**. Тесты перестают зависеть от внешних факторов и дают одинаковый результат при каждом запуске.

### Ограничения
Применение тестовых заглушек сопряжено с рядом ограничений и рисков:

1.  **Хрупкость тестов ([[Brittle Tests|brittle tests]])**. Чрезмерная спецификация взаимодействий (особенно с использованием [[Mock|mock-объектов]]) приводит к тому, что даже безобидный рефакторинг внутренней реализации ломает тесты, хотя внешнее поведение сохраняется.
2.  **Расхождение с реальным поведением**. Заглушка может неточно имитировать поведение реальной зависимости: не воспроизводить все возможные ошибки, особенности производительности или состояния гонки.
3.  **Сложность поддержки**. При изменении интерфейса или контракта реальной зависимости необходимо обновлять все заглушки, что создаёт дополнительную работу.
4.  **Ложная уверенность**. Успешное прохождение тестов с заглушками не гарантирует корректной работы системы с реальными зависимостями; требуются также интеграционные тесты.
5.  **Избыточность**. Для простых зависимостей (например, вычислительных сервисов без состояния) создание заглушек может быть неоправданным; достаточно использовать реальные объекты.

### Сложившиеся практики
Индустрия выработала устойчивую классификацию и рекомендации по использованию тестовых заглушек:

1.  **Классификация тестовых заглушек (по Месарошу)**:
    *   **[[Dummy|Фиктивный объект (dummy)]]** — передаётся в тестируемый код, но никогда не используется; обычно заполняет требования сигнатуры метода. Не имеет реализации и часто представлен `null` или пустым объектом.
    *   **[[Stub|Заглушка (stub)]]** — предоставляет заранее заданные ответы на вызовы методов. Используется, чтобы направить тестируемый код по определённому пути выполнения.
    *   **[[Spy|Шпион (spy)]]** — записывает информацию о произведённых вызовах (количество, параметры, порядок) для последующей верификации.
    *   **[[Mock|Имитация (mock)]]** — предварительно программируется ожиданиями о том, какие вызовы должны произойти; при выполнении проверяет соответствие фактических вызовов ожидаемым.
    *   **[[Fake|Подделка (fake)]]** — работоспособная, но упрощённая реализация зависимости, непригодная для продакшна (например, репозиторий, хранящий данные в оперативной памяти).

2.  **Предпочтение заглушек перед имитациями**. Рекомендуется использовать [[Stub|stub]] для возврата значений и [[Spy|spy]] для проверки состояния, а [[Mock|mock]] применять только для проверки взаимодействий, которые являются частью контракта, а не реализации.

3.  **[[Fake|Подделки]] для сложных зависимостей**. Для репозиториев, сервисов кэширования и других компонентов с существенной логикой часто создаются [[In-Memory Database|in-memory]] реализации, которые используются как в тестах, так и в прототипировании.

4.  **Инверсия зависимостей ([[Dependency Inversion Principle|DIP]]) как предпосылка**. Возможность подмены зависимостей обеспечивается проектированием, ориентированным на интерфейсы, и внедрением зависимостей через конструктор или фабричные методы.

5.  **Библиотеки для создания заглушек**. Использование специализированных фреймворков (Mockito, Moq, EasyMock, Sinon.js, unittest.mock) снижает объём шаблонного кода и улучшает читаемость тестов.

6.  **Осторожность с частичными заглушками ([[Partial Mock|partial mock]])**. Замена только отдельных методов реального объекта при сохранении остальной реализации может приводить к непредсказуемому поведению и усложняет понимание теста.

7.  **Чёткое разграничение модульных и интеграционных тестов**. Модульные тесты активно используют заглушки; интеграционные тесты работают с реальными зависимостями (или их подделками, приближенными к реальности). Смешение уровней снижает ценность обоих подходов.

8.  **Верификация только публичного контракта**. Проверка взаимодействий должна основываться на наблюдаемом поведении, а не на внутренних вызовах. Следует избегать утверждений о вызовах приватных методов.

9.  **Документирование через заглушки**. Хорошо написанный тест с заглушками служит исполняемой спецификацией: он показывает, какие зависимости требуются тестируемому модулю и как он с ними взаимодействует.

10. **Регулярная ревизия и удаление устаревших заглушек**. При изменении кода заглушки, не соответствующие новому интерфейсу или контракту, должны своевременно обновляться или удаляться.

Таким образом, тестовая заглушка является незаменимым инструментом модульного тестирования, обеспечивающим изоляцию, скорость и детерминизм. Выбор конкретного типа заглушки диктуется целью теста: проверка состояния, возвращаемого значения или взаимодействия. Дисциплинированное применение классификации и ориентация на контракты, а не на реализацию, позволяет создавать устойчивые к рефакторингу тесты, сохраняющие высокую диагностическую ценность.