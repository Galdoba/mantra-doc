---
updated_at: 2025-12-12T16:56:15.740+10:00
tags:
  - part4
  - chapter15
---
Наряду с микросервисами в современных распределенных системах нашла широкое распространение и событийно-ориентированная архитектура (`event-driven architecture, EDA`). Довольно часто попадаются советы использовать событийно-ориентированный обмен данными в качестве исходного механизма интеграции при разработке слабосвязанных, масштабируемых и отказоустойчивых распределенных систем.

Событийно-ориентированная архитектура часто связана с предметно-ориентированным проектированием. Ведь `EDA` основана на событиях, которые занимают видное место и в предметно-ориентированном проектировании (`DDD`), где имеются события предметной области, и в случае необходимости они даже используются в качестве источника данных в системе. Может возникнуть соблазн воспользоваться `DDD`-событиями в качестве основы для использования событийно-ориентированной архитектуры. Но стоит ли это делать?

События — это не какая-то секретная приправа, которую можно просто добавить в прежнюю систему и сделать ее слабо связанной и распределенной. Как раз-таки наоборот: опрометчивое применение `EDA` может превратить модульный монолит в распределенный большой ком грязи.

В этой главе будет исследовано взаимодействие `EDA` и `DDD`. Вы изучите основные строительные блоки событийно-ориентированной архитектуры, самые распространенные причины неудач проектов на `EDA` и возможности использования `DDD`-инструментов для разработки эффективных асинхронно интегрированных систем.

## Событийно-ориентированная архитектура

В простом изложении событийно-ориентированная архитектура представляет собой архитектурный стиль, в котором компоненты системы взаимодействуют друг с другом асинхронно, обмениваясь сообщениями о событиях (см. рис. 15.1). Вместо синхронного вызова эндпоинтов (`endpoints`) сервисов компоненты публикуют события, чтобы уведомлять другие элементы системы об изменениях в предметной области системы. Компоненты могут подписываться на события, возникающие в системе, и соответствующим образом на них реагировать. Типичным примером потока выполнения, управляемого событиями, является паттерн саги (`saga pattern`), рассмотренный в главе 9. 

![[Рис. 15.1. Асинхронный обмен данными.png]]

Важно подчеркнуть разницу между событийно-ориентированной архитектурой и паттерном «События как источник данных» (`event sourcing`). Как уже говорилось в главе 7, «События как источник данных» — это метод регистрации изменений состояния в виде серии событий.

Хотя и событийно-ориентированная архитектура, и «События как источник данных» основаны на событиях, эти два паттерна концептуально различаются. `EDA` относится к взаимодействию сервисов, а «События как источник данных» происходит внутри сервиса. События, разработанные при применении паттерна «События как источник данных», представляют переходы состояний (агрегатов в модели предметной области, основанной на событиях), реализованные в сервисе. Эти события нацелены на фиксацию нюансов бизнес-области и не предназначены для интеграции сервиса с другими компонентами системы.

Далее в главе будет показано, что существуют три типа событий, из которых одни подходят для интеграции больше других.

## События

В `EDA`-системе обмен событиями является ключевым механизмом обмена данными с целью интеграции компонентов и превращения их в систему. Давайте взглянем на события попристальнее и посмотрим, чем они отличаются от сообщений.

### События, команды и сообщения

Исходя из ранее изложенного, событие практически ничем не отличается от определения паттерна сообщения (`message`). И все же они разные. Событие — это сообщение, но сообщение — не обязательно событие. Существуют два типа сообщений:

- **Событие**: Сообщение, описывающее уже произошедшее изменение.
- **Команда**: Сообщение, описывающее операцию, которую необходимо выполнить.

Событие — это то, что уже произошло, тогда как команда — это инструкция, предписывающая некое действие. И события, и команды могут передаваться асинхронно в виде сообщений. Но команда может быть отклонена: получатель команды может отказаться от ее выполнения, например если команда недействительна или противоречит бизнес-правилам системы. А событие его получатель отменить не может. В нем описывается то, что уже произошло. Единственное, что можно сделать, чтобы отменить событие, — это выполнить компенсирующее действие — команду, наподобие того, как это делается в паттерне саги.

Поскольку событие описывает что-то, что уже произошло, название события должно быть сформулировано в прошедшем времени: например, `DeliveryScheduled` (доставка запланирована), `ShipmentCompleted` (отгрузка завершена) или `DeliveryConfirmed` (доставка подтверждена).

### Структура

Событие — это структура данных, которую можно сериализовать и передать с помощью выбранной платформы обмена сообщениями. Типичная схема события включает метаданные события и его полезную нагрузку (`payload`) — информацию, передаваемую событием:

```json
{
 "type": "delivery-confirmed",
 "event-id": "14101928-4d79-4da6-9486-dbc4837bc612",
 "correlation-id": "08011958-6066-4815-8dbe-dee6d9e5ebac",
 "delivery-id": "05011927-a328-4860-a106-737b2929db4e",
 "timestamp": 1615718833,
 "payload": {
   "confirmed-by": "17bc9223-bdd6-4382-954d-f1410fd286bd",
   "delivery-time": 1615701406
 }
}
```

Полезная нагрузка не только описывает информацию, передаваемую событием, но и определяет тип события. Давайте более подробно рассмотрим три типа событий, и разберемся, чем они отличаются друг от друга.

## Типы событий

События можно отнести к одному из трех типов: уведомление, передача состояния с помощью события или события предметной области.

### Уведомление

Уведомление (`event notification`) — это сообщение об изменении в предметной области, на которое будут реагировать другие компоненты. К ним среди прочего можно отнести `PaycheckGenerated` (расчетный чек создан) и `CampaignPublished` (реклама опубликована).

Уведомление не должно быть излишне подробным: цель — уведомить заинтересованные стороны о событии, но уведомление не должно содержать всю информацию, необходимую подписчикам для проявления реакции на событие. Например:

```json
{
 "type": "paycheck-generated",
 "event-id": "537ec7c2-d1a1-2005-8654-96aee1116b72",
 "delivery-id": "05011927-a328-4860-a106-737b2929db4e",
 "timestamp": 1615726445,
 "payload": {
   "employee-id": "456123",
   "link": "/paychecks/456123/2021/01"
 }
}
```

В предыдущем коде событие уведомляет внешние компоненты о созданном чеке. В нем не содержится информация, связанная с чеком. Для получения дополнительной информации получатель может воспользоваться ссылкой. Именно такой поток уведомлений изображен на рис. 15.2. 

![[Рис. 15.2. Поток уведомлений о событиях.png]]

В определенном смысле интеграция посредством сообщений с уведомлениями аналогична системе `Wireless Emergency Alert` (`WEA`) в США и `EU-Alert` в Европе (рис. 15.3). Системы используют вышки сотовой связи для передачи коротких сообщений, уведомляющих граждан о проблемах в общественном здравоохранении, угрозах безопасности и других чрезвычайных ситуациях. Системы ограничены отправкой сообщений с максимальной длиной 360 знаков. Этого короткого сообщения достаточно, чтобы уведомить вас о чрезвычайной ситуации, но для получения более подробной информации нужно самостоятельно воспользоваться другими источниками информации. 

![[Рис. 15.3. Система аварийного оповещения.png]]

Краткие уведомления могут быть предпочтительнее в целом ряде сценариев. Давайте более подробно рассмотрим два из них: безопасность и конкурентность.

*   **Безопасность.** Принуждение получателя к явному запросу подробной информации требует дополнительной авторизации подписчиков для доступа к данным.
*   **Конкурентность.** В силу асинхронной природы событийно-ориентированной интеграции информация, дошедшая до подписчиков, может уже оказаться устаревшей. Во избежание состояния гонки, если характер информации чувствителен к нему, актуальное состояние можно получить, сделав явный запрос.

Кроме того, в случае конкурирующих потребителей, когда событие должно обрабатываться только одним подписчиком, процесс запроса может быть интегрирован с пессимистической блокировкой. Тем самым сторона поставщика получит гарантию, что обработать сообщение не сможет никакой другой потребитель.

### Передача состояния с помощью события

Сообщения передачи состояния с помощью события (`Event-carried state transfer, ECST`) уведомляют подписчиков об изменениях во внутреннем состоянии поставщика. В отличие от сообщений с уведомлением о событии, `ECST`-сообщения включают все данные, отражающие изменение состояния.

`ECST`-сообщения могут поступать в двух формах. Первая форма содержит полный срез состояния (`snapshot`) измененного объекта:

```json
{
 "type": "customer-updated",
 "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
 "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
 "timestamp": 1615728520,
 "payload": {
   "first-name": "Carolyn",
   "last-name": "Hayes",
   "phone": "555-1022",
   "status": "follow-up-set",
   "follow-up-date": "2021/05/08",
   "birthday": "1982/04/05",
   "version": 7
 }
}
```

`ECST`-сообщение, показанное в предыдущем примере, включает в себя полный снимок обновленного состояния клиента. При работе с большими структурами данных может оказаться целесообразным включать в `ECST`-сообщение только поля, подвергшиеся фактическим изменениям:

```json
{
 "type": "customer-updated",
 "event-id": "6b7ce6c6-8587-4e4f-924a-cec028000ce6",
 "customer-id": "01b18d56-b79a-4873-ac99-3d9f767dbe61",
 "timestamp": 1615728520,
 "payload": {
   "status": "follow-up-set",
   "follow-up-date": "2021/05/10",
   "version": 8
 }
}
```

Что бы ни было в `ECST`-сообщениях, полные срезы состояния или же только обновленные поля, поток таких событий позволяет потребителям хранить локальный кеш состояний объектов и работать с ним. Концептуально использование сообщений с передачей состояний с помощью события представляет собой механизм асинхронной репликации данных. Такой подход повышает отказоустойчивость системы, а это означает, что потребители получают возможность продолжать работу, даже если поставщик недоступен. Он также дает возможность повысить производительность компонентов, нацеленных на обработку данных из нескольких источников. Вместо запросов, посылаемых каждый раз в источники востребованных данных, все эти данные, как показано на рис. 15.4, можно кешировать локально. Рис. 15.4. Бэкенд (`backend`) для фронтенда (`frontend`)

![[Рис. 15.4. Бэкенд (backend) для фронтенда (frontend).png]]

## События предметной области (`domain event`)

Третий тип сообщений о событиях относится к событиям предметной области, рассмотренным в главе 6. В определенном смысле события предметной области одновременно похожи как на уведомления, так и на `ECST`-сообщения: в них не только дается описание важного события в бизнес-области, но и содержатся все характеризующие это событие данные. Несмотря на сходство, концепция у всех этих типов сообщений разная.

### Сравнение событий предметной области и уведомлений

В событиях предметной области, как и в уведомлениях, дается описание изменения, произошедшего в бизнес-области поставщика события. И все же здесь есть два концептуальных различия.

Во-первых, события предметной области включают всю информацию, описывающую событие. Чтобы получить полную картину, потребителю не нужно предпринимать никаких дополнительных действий.

Во-вторых, при моделировании в них вкладывается разный смысл. Уведомления разработаны с целью упростить интеграцию с другими компонентами. А события предметной области предназначены для моделирования и описания предметной области. События предметной области могут оказаться полезными, даже если в них не заинтересован ни один внешний потребитель. Это особенно актуально для систем с событиями как источником данных (`Event Sourcing`), где события предметной области используются для моделирования всех возможных переходов состояний.

Наличие внешних потребителей, заинтересованных во всех доступных событиях предметной области, приведет к неоптимальному дизайну ПО. Более подробно эта ситуация будет рассмотрена в данной главе чуть позже.

### Сравнение событий предметной области с `ECST`-сообщениями

Данные, содержащиеся в событиях предметной области, концептуально отличаются от схемы типичного `ECST`-сообщения.

`ECST`-сообщение предоставляет достаточную информацию для хранения локального кеша данных поставщика этого сообщения. Ни одно отдельно взятое событие предметной области не должно выставлять на всеобщее обозрение такую содержательную модель. Так, данных, включенных в конкретное событие предметной области, недостаточно для кеширования состояния агрегата, к тому же на те же самые поля могут повлиять другие события предметной области, на которые не подписан потребитель.

Кроме того, как и в случае уведомлений о событиях, в эти два типа сообщений вкладывается совершенно разный смысл. Данные, включенные в события предметной области, не предназначены для описания состояния агрегата. В них описывается бизнес-событие, произошедшее в течение его жизненного цикла.

### Типы событий: Пример

Возьмем пример, демонстрирующий различия между тремя типами событий. Рассмотрим следующие три способа представления события вступления в брак:

```json
eventNotification = {
 "type": "marriage-recorded",
 "person-id": "01b9a761",
 "payload": {
   "person-id": "126a7b61",
   "details": "/01b9a761/marriage-data"
 }
};

ecst = {
 "type": "personal-details-changed",
 "person-id": "01b9a761",
 "payload": {
   "new-last-name": "Williams"
 }
};

domainEvent = {
 "type": "married",
 "person-id": "01b9a761",
 "payload": {
   "person-id": "126a7b61",
   "assumed-partner-last-name": true
 }
};
```

`marriage-recorded` является уведомлением о событии. В нем не содержится никакой информации, кроме факта, что человек с указанным идентификатором вступил в брак. О самом событии здесь минимум информации, а потребитель, интересующийся подробностями, должен будет проследовать по ссылке из поля `details`.

`personal-details-changed` является сообщением передачи состояния с помощью события. В нем описываются изменения в личных данных человека, т. е. изменение его фамилии. В сообщении не объясняется причина, по которой она изменилась. Непонятно, женился человек или развелся?

И наконец, `married` является событием предметной области. Оно смоделировано в форме, максимально приближенной к естественному событию в предметной области. В него включены идентификатор человека и флаг, указывающий, принял ли человек фамилию своего партнера.

## Проектирование событийно-ориентированной интеграции

Как уже говорилось в главе 3, проектирование программных продуктов в основном связано с границами. Границы определяют, что будет внутри, а что останется снаружи и, что более важно, что будет переходить через границы, т. е. как именно будет происходить интеграция компонентов. События в системе, основанной на `EDA`-архитектуре, являются первостепенными элементами дизайна, влияющими не только на способ интеграции компонентов, но и на сами границы этих компонентов. Выбор правильного типа сообщения о событии формирует (развязывает) или разрушает (связывает) распределенную систему.

В этом разделе будут рассмотрены эвристические подходы к применению различных типов событий. Но сначала давайте посмотрим, как можно использовать события для проектирования сильно связанного распределенного большого кома грязи (`big ball of mud`).

### Распределенный большой ком грязи

Рассмотрим систему, показанную на рис. 15.5. 

![[Рис. 15.5. Сильно связанная распределенная система.png]]

Ограниченный контекст (`bounded context`) `CRM` (системы управления информацией о клиентах) реализован в виде модели предметной области, основанной на событиях (`event-sourced domain model`). Когда `CRM`-систему необходимо было интегрировать с ограниченным контекстом `Marketing` (изучение рынка), команды решили воспользоваться гибкостью модели данных, основанных на событиях, и позволить потребителю — в данном случае `Marketing` — подписаться на события предметной области `CRM`, применив их для проецирования модели, соответствующей его потребностям.

После введения ограниченного контекста `AdsOptimization` (оптимизации рекламы) он также должен был обрабатывать информацию, произведенную ограниченным контекстом `CRM`. Команды решили позволить `AdsOptimization` подписываться на все события предметной области, выдаваемые `CRM`, и спроецировать модель, соответствующую потребностям `AdsOptimization`.

Интересно, что ограниченные контексты `Marketing` и `AdsOptimization` должны были представлять информацию о клиентах в одном и том же формате и, следовательно, проецировали одну и ту же модель из событий предметной области `CRM`: упрощенный срез (`snapshot`) состояния каждого клиента.

Ограниченный контекст `Reporting` (создание отчетов) подписан только на подмножество событий предметной области, публикуемых `CRM` и используемых в качестве уведомлений о событиях для извлечения результатов вычислений, выполненных в контексте `AdsOptimization`. Но, поскольку оба ограниченных контекста `AdsOptimization` и `Reporting` используют для запуска своих вычислений, обеспечивающих обновление модели `Reporting`, одни и те же события, в контекст `Reporting` введена задержка. Сообщения в нем обрабатываются через пять минут после их получения.

Дизайн получился хуже некуда. Давайте проанализируем все виды связанностей в этой системе. 

#### Временная связанность (связанность по времени)

Связанность ограниченных контекстов `AdsOptimization` и `Reporting` носит временной характер: она зависит от четкого порядка выполнения программы. Компонент `AdsOptimization` должен завершить свою обработку данных до запуска модуля `Reporting`. Если порядок выполнения программы будет обратным, в отчетность попадут противоречивые данные.

Чтобы обеспечить необходимый порядок выполнения, программисты ввели в систему `Reporting` задержку. Эта пятиминутная задержка позволяет компоненту `AdsOptimization` завершить все необходимые вычисления. И все же нетрудно заметить, что все это не гарантирует правильный порядок выполнения:

*   `AdsOptimization` может быть перегружен и не сможет завершить обработку за пять минут.
*   Проблема с сетью может привести к задержке доставки входящих сообщений сервису `AdsOptimization`.
*   Компонент `AdsOptimization` может выйти из строя и прекратить обработку входящих сообщений.

#### Функциональная связанность

Ограниченные контексты `Marketing` и `AdsOptimization` подписывались на события предметной области `CRM`, из-за чего в них была реализована одна и та же проекция данных о клиентах. Иными словами, бизнес-логика, преобразующая входящие события предметной области в представление на основе состояния, дублировалась в обоих ограниченных контекстах, и у нее были одни и те же причины для изменений: эти ограниченные контексты должны были представлять данные клиентов в одном и том же формате. Следовательно, если проекция была изменена в одном из компонентов, изменение должно было повториться и во втором ограниченном контексте.

Здесь мы имеем дело с функциональной связанностью: несколько компонентов реализуют одну и ту же бизнес-функциональность, и если она изменится, то изменения должны быть одновременно произведены в обоих компонентах.

#### Связанность на уровне реализации

Это уже более сложный тип связанности. Ограниченные контексты `Marketing` и `AdsOptimization` подписаны на все события предметной области, выдаваемые моделью `CRM`, основанной на событиях. Следовательно, изменения, вносимые в реализацию `CRM`, например добавление нового события предметной области или изменение схемы существующего события, должны отражаться в обоих подписанных ограниченных контекстах! Невыполнение этого требования может привести к несогласованности данных. Например, если схема события изменится, логика проецирования, имеющаяся у подписчиков, не сработает. Если же в модель `CRM` добавляется новое событие предметной области, оно потенциально может повлиять на те модели, на которые оно проецируется, и, следовательно, его игнорирование приведет к проецированию несогласованного состояния.

### Реорганизация событийно-ориентированной интеграции

Как видите, непродуманное введение событий в систему не избавляет ее ни от связанности, ни от отказов. Можно, конечно, посчитать этот пример выдумкой, но, к сожалению, он основан на вполне реальной истории. Давайте посмотрим, как можно изменить события, чтобы существенно улучшить дизайн.

Предоставление на всеобщее обозрение всех событий предметной области, составляющих модель данных `CRM`, обусловливает связанность подписчиков с деталями реализации поставщика событий. Связанность реализаций может быть устранена путем предоставления либо гораздо более ограниченного набора событий, либо совершенно другого типа событий.

Выступающие в роли подписчиков `Marketing` и `AdsOptimization` функционально связаны друг с другом за счет реализации одних и тех же бизнес-функций.

И связанность реализаций, и функциональная связанность могут быть устранены путем инкапсуляции логики проецирования в коде поставщика событий, в ограниченных контекстах `CRM`. Вместо раскрытия подробностей своей реализации `CRM` может последовать паттерну контракта, ориентированного на потребителя: спроецировать модель, необходимую потребителям, и сделать ее частью опубликованного языка ограниченного контекста, превратив все в интеграционную модель, не связанную с внутренней моделью реализации. В результате потребители получат все необходимые им данные и ничего не узнают о модели реализации `CRM`.

Чтобы устранить временную связанность контекстов `AdsOptimization` и `Reporting`, компонент `AdsOptimization` может публиковать уведомления о событиях, активизируя тем самым компонент `Reporting` для получения им необходимых данных. Эта реорганизованная система показана на рис. 

![[Рис. 15.6. Реорганизованная система.png]]

### Творческий подход к событийно-ориентированному проектированию

Правильное сопоставление типов событий с поставленными задачами делает получаемый в результате этого проект на несколько порядков менее связанным, более гибким и отказоустойчивым. Давайте сформулируем эвристический подход к проектированию применительно к внесенным изменениям.

#### Предполагайте худшее

Как сказал Эндрю Гроув (`Andrew Grove`), выживают только параноики. Используйте это высказывание в качестве руководящего принципа при разработке событийно-ориентированных систем:

*   Сеть будет медленной.
*   Серверы выйдут из строя в самый неподходящий момент.
*   События будут поступать не по порядку.
*   События будут дублироваться.

Самое главное, что все эти неприятности чаще всего будут случаться в выходные и праздничные дни.

Слово «ориентированное» в выражении «событийно-ориентированная архитектура» означает, что вся ваша система зависит от успешной доставки сообщений. Следовательно, не смейте даже и думать, что «все обязательно будет хорошо». Сделайте так, чтобы события, несмотря ни на что, всегда доставлялись своим чередом:

*   Для надежной публикации сообщений воспользуйтесь паттерном «Ящик исходящих сообщений» (`outbox pattern`).
*   При публикации сообщений убедитесь, что подписчики смогут избавиться от дубликатов сообщений, а также выявить и переупорядочить неупорядоченные сообщения.
*   При оркестровке трансграничных контекстных процессов, требующих выполнения компенсирующих действий, воспользуйтесь сагой и диспетчером процессов.

#### Используйте публичный интерфейс и приватные события

Остерегайтесь раскрытия подробностей реализации при публикации событий предметной области, особенно в агрегатах, основанных на событиях. Рассматривайте события в качестве неотъемлемой части публичного интерфейса ограниченного контекста. Поэтому при реализации паттерна сервиса с открытым протоколом (`open-host service`) убедитесь, что события отражены в опубликованном языке (`published language`) ограниченного контекста. Паттерны преобразования моделей, основанных на событиях, рассмотрены в главе 9.

При проектировании публичных интерфейсов ограниченных контекстов используйте различные типы событий. Сообщения передачи состояния с помощью события позволяют привести модель реализации к более компактной форме, которая передает потребителям только востребованную ими информацию.

Для еще большей минимизации открытого интерфейса можно воспользоваться уведомлениями о событиях.

И наконец, для связи с внешними ограниченными контекстами событиями предметной области нужно пользоваться как можно реже. Нужно изыскивать возможности разработки специализированного набора таких событий.

#### Оценивайте требования к согласованности

При проектировании событийно-ориентированного обмена данными в качестве еще одной составляющей эвристического подхода к выбору типа сообщений следует оценивать требования к согласованности ограниченных контекстов:

*   Если компоненты могут довольствоваться данными, согласованными по принципу согласованности в конечном счете (`eventual consistency`), используйте сообщения передачи состояния с помощью события (`ECST`-сообщения).
*   Если потребителю необходимо прочитать последние изменения в состоянии поставщика сообщения, выдайте сообщение с уведомлением о событии с возможностью отправки последующего запроса на получение актуального состояния поставщика.

## Вывод

В этой главе в качестве неотъемлемого аспекта проектирования публичного интерфейса ограниченного контекста была представлена событийно-ориентированная архитектура. Были рассмотрены три типа событий, которыми можно воспользоваться для обмена данными между ограниченными контекстами:

1.  **Уведомление**: Уведомление о том, что произошло что-то важное, но требующее от потребителя явного запроса дополнительной информации у поставщика уведомления.
2.  **Передача состояния с помощью события**: Механизм репликации данных на основе сообщений. Каждое событие содержит срез состояния, которым можно воспользоваться для поддержания локального кеша данных поставщика.
3.  **Событие предметной области**: Сообщение с описанием события в предметной области поставщика.

Использование неподходящих типов событий приведет к разрушению системы на основе `EDA`-архитектуры, невольно превратив ее в большой ком грязи. Чтобы выбрать для интеграции правильный тип событий, нужно оценить требования согласованности ограниченных контекстов и проявить осмотрительность в раскрытии подробностей их реализации. Следует разработать четкий набор публичных и приватных событий. И наконец, следует обеспечить доставку системой сообщений даже в случае технических проблем и сбоев.