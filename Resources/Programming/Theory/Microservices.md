---
updated_at: 2026-02-12T13:55:42.867+10:00
---
**Микросервисы** (microservices) — это архитектурный стиль, в рамках которого программное обеспечение компонуется из небольших, слабосвязанных, независимо развертываемых [[Service|сервисов]]. Каждый сервис реализует одну бизнес-способность, владеет собственным хранилищем данных и взаимодействует с другими сервисами исключительно через сетевые протоколы, обычно HTTP/REST или асинхронный обмен сообщениями.

Микросервисная архитектура противопоставляется [[Monolith|монолитному]] стилю, где вся функциональность объединена в едином процессе и общей кодовой базе.

### Назначение
Переход к микросервисам мотивирован потребностями масштабирования разработки и эксплуатации крупных, долгоживущих систем:

*   **Независимость разработки**. Разные команды могут разрабатывать, тестировать и развертывать свои сервисы асинхронно, без блокировок и согласования с остальной частью системы.
*   **Технологическая гетерогенность**. Для каждого сервиса допустим выбор языка, фреймворка, базы данных и инструментов, оптимальных для решаемой задачи.
*   **Изоляция сбоев**. Отказ одного сервиса не приводит к остановке всей системы при условии реализации устойчивости (таймауты, [[Circuit Breaker|автоматические выключатели]], избыточность).
*   **Независимое масштабирование**. Сервисы масштабируются по отдельности в соответствии с их индивидуальной нагрузкой, что эффективнее, чем масштабирование монолита целиком.
*   **Автономия команд**. Команды владеют полным жизненным циклом своих сервисов («вы это построили — вы это эксплуатируете»), что сокращает передачу знаний и ускоряет поставку изменений.

### Ограничения
Применение микросервисов сопряжено с фундаментальными издержками, которые часто недооцениваются при переходе от монолита:

1.  **Распределённая сложность**. Межсервисное взаимодействие происходит по сети, что вносит задержки, требует обработки частичных отказов, таймаутов, повторных попыток и обеспечения безопасности на уровне транспорта.
2.  **Управление данными**. Транзакции, охватывающие несколько сервисов, не могут быть реализованы через ACID; требуются компенсирующие транзакции, [[Saga|саги]] и [[Eventual Consistency|согласованность в конечном счёте]].
3.  **Операционная нагрузка**. Множество сервисов требует автоматизации развёртывания, мониторинга, логирования, трассировки и обнаружения сервисов. Без зрелой инфраструктуры ([[Containerization|контейнеризация]], [[Orchestration|оркестрация]]) эксплуатация становится невозможной.
4.  **Сложность тестирования**. Сквозные сценарии, затрагивающие множество сервисов, сложны в реализации и поддержке. Заместители сервисов ([[Test Double|тестовые дублёры]]) становятся обязательными.
5.  **Сетевые издержки и задержки**. Каждый межсервисный вызов добавляет накладные расходы, что особенно критично для низколатентных систем.
6.  **Распределённый монолит**. При неудачном проектировании границ сервисы обрастают избыточными синхронными связями и разделяемыми базами данных, что нивелирует преимущества, сохраняя все недостатки распределённости.

### Сложившиеся практики
За последнее десятилетие индустрия выработала обширный набор практик, позволяющих успешно реализовывать и эксплуатировать микросервисные системы:

1.  **Декомпозиция по бизнес-способностям**. Границы сервисов определяются не техническими функциями (слоями), а автономными функциями бизнеса («Управление заказами», «Обработка платежей», «Доставка»). Каждый сервис соответствует [[Bounded Context|ограниченному контексту]] в терминах [[Domain-Driven Design|предметно-ориентированного проектирования]].

2.  **[[Database per Service|База данных на сервис]]**. Микросервисы не разделяют общие схемы данных. Каждый владеет своей базой и предоставляет доступ к данным только через публичный API. Это обеспечивает слабую связанность, но требует решения задач распределённого управления данными.

3.  **API-первое проектирование (API-first)**. Интерфейс сервиса проектируется, документируется и версионируется до начала реализации. Используются декларативные языки описания (OpenAPI, gRPC proto, GraphQL SDL). По контракту генерируются клиенты и заглушки.

4.  **Асинхронное взаимодействие как предпочтение**. Там, где возможно, синхронные вызовы заменяются асинхронной передачей событий через [[Message Broker|брокеры сообщений]] (Kafka, RabbitMQ, NATS). Это снижает связанность и повышает отказоустойчивость.

5.  **[[Service Discovery|Обнаружение сервисов]]**. В динамических средах (Kubernetes, Nomad) местоположение экземпляров сервиса не фиксировано. Используются реестры (DNS, Consul, etcd) или встроенные механизмы платформы, позволяющие клиентам находить доступные экземпляры.

6.  **[[API Gateway|API-шлюз]]**. Для внешних клиентов и часто для внутренних потребителей вводится единая точка входа, которая маршрутизирует запросы, выполняет аутентификацию, ограничение скорости, агрегацию ответов и трансформацию протоколов.

7.  **[[Service Mesh|Сервисная сетка]]**. На уровне инфраструктуры внедряется выделенный слой sidecar-прокси (Istio, Linkerd), берущий на себя обнаружение, балансировку, шифрование ([[Mutual TLS|mTLS]]), наблюдаемость и контроль доступа, освобождая прикладной код от этих задач.

8.  **[[Observability|Наблюдаемость]] как обязательное требование**. Каждый сервис инструментируется для генерации метрик, структурированных логов и распределённых трассировок (OpenTelemetry, Jaeger). Без всесторонней наблюдаемости диагностика распределённой системы становится практически невозможной.

9.  **[[CI/CD|Непрерывная интеграция и доставка]]**. Каждый сервис имеет собственный конвейер сборки, тестирования и развёртывания. Изменения могут попадать в продакшн независимо от других сервисов, часто многократно в день.

10. **[[Chaos Engineering|Хаос-инжиниринг]]**. Преднамеренное внесение сбоев в производственную систему для проверки её устойчивости (Netflix Chaos Monkey). Формирует культуру проектирования, предполагающего отказы как норму.

11. **Эволюционное выделение**. Рекомендуется начинать с монолита и постепенно выделять из него микросервисы по мере роста сложности и появления ясных границ. «Big Bang»-переходы часто заканчиваются неудачей.

12. **Команда на сервис**. Организационная структура отражает архитектуру: одна кросс-функциональная команда (разработка, тестирование, эксплуатация) владеет одним или несколькими родственными сервисами на протяжении всего их жизненного цикла.

Таким образом, микросервисы — это не столько технология, сколько организационный и архитектурный паттерн. Успех его применения критически зависит от зрелости процессов, автоматизации инфраструктуры и дисциплины команд. При соблюдении этих условий микросервисная архитектура позволяет достичь высокой скорости изменений и масштабируемости, недоступной монолитным системам в условиях крупных распределённых организаций.