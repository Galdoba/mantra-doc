---
updated_at: 2026-02-12T15:09:32.851+10:00
---
**Репозиторий** ({{Repository|repository}}) — это архитектурный паттерн, инкапсулирующий логику получения, сохранения и поиска [[Domain Model|объектов предметной области]]. Репозиторий предоставляет коллекционно-подобный интерфейс для работы с [[Aggregate Root|корнями агрегатов]], скрывая детали хранения (базы данных, файловой системы, внешних сервисов) от остальных слоёв приложения.

В контексте [[Domain-Driven Design|предметно-ориентированного проектирования]] репозиторий создаётся только для [[Aggregate|агрегатов]]; каждый агрегат имеет соответствующий репозиторий, обеспечивающий доступ к его корням.

### Назначение
Введение репозиториев преследует несколько взаимосвязанных целей:

*   **Отделение бизнес-логики от инфраструктуры**. Код предметной области не содержит ссылок на конкретные технологии хранения (SQL, ORM, файловые системы), что повышает его тестируемость и переносимость.
*   **Единообразный интерфейс**. Репозиторий предоставляет стандартные операции (`get`, `add`, `remove`, `update`, `find`) вне зависимости от реализации, упрощая взаимодействие с различными источниками данных.
*   **Централизация логики запросов**. Сложные запросы, специфичные для предметной области, инкапсулируются в репозитории, не размазываясь по сервисам и контроллерам.
*   **Поддержка модульного тестирования**. Репозиторий легко заменяется заглушкой ([[Test Double|test double]]) или [[In-Memory Repository|репозиторием в памяти]], позволяя тестировать бизнес-логику без подключения к реальной базе данных.
*   **Управление жизненным циклом объектов**. Репозиторий отвечает за восстановление сохранённых объектов из хранилища и их синхронизацию при изменениях.

### Ограничения
Применение паттерна «репозиторий» сопряжено с рядом объективных сложностей:

1.  **Дополнительный уровень абстракции**. Каждый агрегат требует создания как минимум одного интерфейса и одной реализации, что увеличивает объём кода и порог входа в проект.
2.  **Утечка деталей хранения**. Несмотря на абстракцию, некоторые особенности базы данных (пагинация, сортировка, оптимистическая блокировка, транзакции) неизбежно проникают в интерфейс репозитория, размывая границы ответственности.
3.  **Сложность реализации сложных запросов**. Гибкая система фильтрации и поиска требует введения дополнительных паттернов ([[Specification|спецификация]], критерии), что повышает сложность.
4.  **Синхронизация с [[Unit of Work|единицей работы]]**. При использовании репозиториев совместно с ORM необходимо согласовывать операции добавления, удаления и сохранения с контекстом базы данных, что часто приводит к неявному поведению (автоматическое сохранение).
5.  **Неоднозначность границ**. Не всегда очевидно, для каких объектов следует создавать репозиторий; попытка создать репозиторий для каждой таблицы ([[Database Table|таблицы]]) приводит к вырождению паттерна в простую обёртку над ORM.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и реализации репозиториев:

1.  **Репозиторий только для корней агрегатов ([[Aggregate Root|aggregate root]])**. В соответствии с [[Domain-Driven Design|предметно-ориентированным проектированием]], репозиторий создаётся исключительно для корневых сущностей агрегата. Внутренние [[Entity|сущности]] и [[Value Object|объекты-значения]] не имеют собственных репозиториев и загружаются только через корень.

2.  **Интерфейс в домене, реализация в инфраструктуре**. Интерфейс репозитория принадлежит доменному слою, а его реализация — инфраструктурному. Это обеспечивает соблюдение принципа инверсии зависимостей ([[Dependency Inversion Principle|DIP]]) и позволяет подменять реализацию без изменения доменного кода.

3.  **Коллекционно-подобный интерфейс**. Репозиторий имитирует поведение коллекции: `add` (вставка нового объекта), `remove` (удаление), `getById` (получение по идентификатору). Методы сохранения (`save`, `update`) часто не выделяются явно, поскольку добавленный объект подразумевает необходимость сохранения.

4.  **Один репозиторий на агрегат**. Для каждого агрегата создаётся ровно один репозиторий. Если агрегат может быть получен разными способами (по идентификатору, по атрибуту, по сложному критерию), все эти методы размещаются в одном интерфейсе.

5.  **Использование [[Specification|спецификаций]] для запросов**. Для гибкого поиска без привязки к конкретному языку запросов применяется паттерн «Спецификация». Предикат формируется как объект в доменном слое и интерпретируется репозиторием в критерии базы данных. Альтернативно — использование Query Object или критериев, определённых в интерфейсе репозитория.

6.  **Возврат агрегатов целиком**. Репозиторий всегда возвращает полностью загруженный агрегат. Частичная загрузка (выборочные поля) нарушает инкапсуляцию и может привести к некорректным проверкам инвариантов.

7.  **Асинхронные интерфейсы**. В современных приложениях методы репозитория проектируются асинхронными (`Task<T>`, `CompletableFuture`, `Promise`), чтобы не блокировать потоки при обращении к медленным хранилищам.

8.  **[[Data Mapper|Преобразователь данных (Data Mapper)]]**. Репозиторий часто реализуется поверх ORM (Hibernate, Entity Framework, Doctrine), используя маппер для преобразования между доменными объектами и записями базы данных. Это противопоставляется паттерну [[Active Record|активная запись]], где доменный объект сам содержит методы сохранения.

9.  **[[In-Memory Repository|Репозиторий в памяти]]**. Для тестирования и прототипирования создаётся простая реализация, хранящая объекты в коллекции. Это позволяет выполнять модульные тесты без настройки базы данных и ускоряет обратную связь.

10. **Прозрачное управление транзакциями**. Репозиторий сам по себе не управляет транзакциями; границы транзакций определяются на уровне прикладных сервисов или Use Case'ов. Репозиторий лишь участвует в уже открытой транзакции через разделяемый контекст (например, `DbContext`, `EntityManager`).

11. **Методы для массовых операций**. При необходимости репозиторий может содержать методы для удаления или обновления нескольких объектов по критерию, но такие методы должны быть явными и не нарушать инкапсуляцию агрегатов.

12. **Избегание «божественного» репозитория**. Репозиторий не должен обрастать десятками методов для разных вариантов выборки; вместо этого вводятся объекты критериев или спецификаций, а метод `find` принимает параметры запроса.

Таким образом, репозиторий является критически важным паттерном для отделения доменной модели от инфраструктуры хранения. Его систематическое применение позволяет сохранить выразительность и тестируемость бизнес-логики при работе с любой технологией постоянства. Дисциплинированное следование описанным практикам обеспечивает чистоту архитектурных границ и долгосрочную сопровождаемость кода.