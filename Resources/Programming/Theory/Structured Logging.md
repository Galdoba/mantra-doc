---
updated_at: 2026-02-12T14:34:42.402+10:00
tags:
  - logging
aliases:
  - структурированный логгер
---
**Структурированный логгер** (structured logger) — это компонент системы логирования, который формирует записи не в виде произвольных текстовых строк, а в виде структурированных данных, организованных по схеме «ключ-значение». Каждая запись лога представляет собой набор [[Field|полей]] с явно заданными именами и типизированными значениями, что позволяет выполнять автоматическую обработку, фильтрацию и анализ без применения регулярных выражений.

В отличие от традиционного [[Plaintext Logging|текстового логирования]], где вся информация смешана в одной строке, структурированный логгер разделяет содержание и форму представления, сериализуя события в машинно-читаемый формат, чаще всего [[JSON|JSON]].

### Назначение
Переход к структурированному логированию вызван потребностями современных распределённых систем и практик [[Observability|наблюдаемости]]:

*   **Автоматический анализ**. Позволяет системам централизованного сбора (Elasticsearch, Loki, Splunk) индексировать отдельные поля и выполнять по ним высокопроизводительные запросы и агрегации.
*   **Корреляция событий**. Благодаря включению [[Correlation ID|идентификаторов корреляции]], trace id и span id, можно связать записи, относящиеся к одному запросу, проходящему через множество сервисов.
*   **Контекстная диагностика**. Разработчик добавляет в лог-запись релевантные переменные (идентификатор пользователя, заказа, сессии) в виде отдельных полей, что упрощает поиск причин инцидентов.
*   **Гибкость представления**. Структурированные данные могут быть отображены по-разному для человека (цветное форматирование в терминале) и для машин (JSON для передачи).
*   **Интеграция с системами мониторинга**. Метрики могут извлекаться из структурированных логов путём подсчёта определённых значений полей.

### Ограничения
Внедрение структурированного логирования сопряжено с рядом практических ограничений:

1.  **Накладные расходы на сериализацию**. Формирование JSON или другого структурированного формата требует дополнительных вычислений и выделения памяти, что может быть критично в высоконагруженных системах.
2.  **Читаемость для человека**. Необработанный JSON в терминале менее читаем, чем аккуратно отформатированное текстовое сообщение. Требуются инструменты pretty-printing или фильтрации для комфортной работы разработчика.
3.  **Сложность управления схемами**. При большом количестве различных событий возникает необходимость в поддержании [[Schema|схемы полей]] и контроле за их согласованностью между сервисами.
4.  **Риск избыточности**. Неопытные разработчики могут включать в каждую запись множество избыточных полей, что резко увеличивает объём хранимых данных.
5.  **Безопасность и конфиденциальность**. Структурированные логи могут непреднамеренно включать чувствительные поля ([[Secret|секреты]], персональные данные), которые затем легко извлекаются и анализируются. Требуется строгая политика фильтрации.

### Сложившиеся практики
Индустрия выработала устойчивые подходы к эффективному использованию структурированных логгеров:

1.  **JSON как стандартный формат**. Подавляющее большинство реализаций используют JSON благодаря его универсальности, поддержке во всех языках программирования и встроенным средствам парсинга. Альтернативы (CBOR, Apache Avro) применяются только при экстремальных требованиях к производительности или размеру.

2.  **Именование полей по единому стандарту**. В организации устанавливаются общие правила именования (snake_case, camelCase) и словарь общих полей: `@timestamp`, `level`, `logger`, `thread`, `service.name`, `trace.id`. Это обеспечивает единообразие при агрегации из разных источников.

3.  **Выделение контекста**. Логгер предоставляет API для добавления контекстных полей, которые автоматически включаются во все последующие записи в рамках потока выполнения. Это избавляет от необходимости передавать идентификаторы явно в каждый вызов.

4.  **Структурированные сообщения без потери читаемости**. Сообщение (`message`) остаётся текстовым и содержит читаемое описание события, но все переменные выносятся в отдельные поля. Например: `"message": "User logged in", "user_id": 12345, "ip": "192.168.1.1"`.

5.  **Уровни логирования**. Сохраняется иерархия [[Log Level|уровней]] (DEBUG, INFO, WARN, ERROR). Поле уровня выделяется отдельно и используется для фильтрации и маршрутизации.

6.  **Автоматическое добавление метаданных**. На этапе инициализации логгера настраивается автоматическое добавление статических полей (имя сервиса, версия, хост, окружение), что исключает их ручное проставление.

7.  **Вывод в stdout/stderr**. В соответствии с [[Twelve-Factor App|методологией Двенадцати факторов]], структурированные логи направляются в стандартный вывод. Инфраструктурные агенты (Fluentd, Logstash, Vector) подхватывают поток и передают в системы хранения.

8.  **Асинхронная запись**. Для снижения влияния на производительность приложения структурированные логгеры часто работают в асинхронном режиме: запись в буфер и отправка в отдельном потоке.

9.  **Фильтрация и маскирование чувствительных данных**. На уровне логгера или на этапе сбора применяются правила для автоматического обнаружения и замены паролей, токенов, номеров карт на плейсхолдеры (`***`).

10. **Схемы и валидация**. В крупных системах внедряются реестры схем логирования (например, JSON Schema), по которым автоматически проверяется соответствие структуры событий утверждённому формату. Это предотвращает появление неконсистентных данных.

11. **Инструменты разработки**. Для локальной разработки используются утилиты, преобразующие поток JSON в цветной человекочитаемый вывод (bunyan, pino-pretty, winston). Это сохраняет преимущества структурированности на этапе отладки.

12. **Семантическое логирование**. Практика, при которой имена полей и их значения несут предметно-ориентированный смысл, понятный не только разработчикам, но и аналитикам бизнеса (например, `order.status`, `payment.amount`).

Таким образом, структурированный логгер является не просто библиотекой для записи событий, а ключевым элементом инфраструктуры наблюдаемости. Он смещает фокус с генерации текста для чтения человеком на генерацию данных для автоматической обработки, что в современных распределённых системах является необходимым условием поддержания управляемости и диагностируемости.