---
updated_at: 2026-02-16T12:47:50.803+10:00
---
## Взаимная блокировка: тупиковая ситуация при конкуренции за ресурсы

**Взаимная блокировка** ({{Deadlock|deadlock}}) — это ситуация в многозадачной среде, при которой два или более [[Process|процесса]] (или [[Thread|потока]]) бесконечно ожидают освобождения ресурсов, удерживаемых другими участниками этой группы. Каждый процесс удерживает ресурс, запрошенный другим процессом, и не может продолжить выполнение, пока не получит недостающий ресурс, который никогда не будет освобождён.

### Назначение
Изучение и предотвращение взаимных блокировок необходимо для обеспечения надёжности и отказоустойчивости параллельных систем:

*   **Предсказуемость поведения**. Взаимная блокировка приводит к полной остановке части системы; ни один из вовлечённых процессов не может завершить работу или освободить ресурсы.
*   **Целостность данных**. В тупиковой ситуации ресурсы могут оставаться в несогласованном состоянии, что затрудняет восстановление.
*   **Утилизация ресурсов**. Процессы, находящиеся в deadlock, бесполезно удерживают ресурсы, снижая общую пропускную способность системы.
*   **Проектирование устойчивых систем**. Понимание условий возникновения взаимных блокировок позволяет разработчикам создавать алгоритмы, исключающие или корректно обрабатывающие такие ситуации.

### Ограничения
Борьба с взаимными блокировками сопряжена с фундаментальными компромиссами:

1.  **Необходимые условия (условия Коффмана)**. Для возникновения взаимной блокировки должны одновременно выполняться четыре условия:
    *   **взаимное исключение** — ресурс не может быть одновременно использован несколькими процессами;
    *   **удержание и ожидание** — процесс удерживает выделенный ресурс и ожидает получения дополнительных;
    *   **отсутствие принудительного освобождения** — ресурс может быть освобождён только самим удерживающим процессом;
    *   **циклическое ожидание** — существует замкнутая цепочка процессов, каждый из которых ожидает ресурс, удерживаемый следующим в цепи.
    Устранение любого из этих условий предотвращает deadlock, но каждое устранение имеет свою цену.

2.  **Накладные расходы на предотвращение**. Методы предотвращения (например, упорядоченный захват ресурсов) требуют дополнительной логики и могут снижать параллелизм.

3.  **Сложность обнаружения**. Алгоритмы обнаружения взаимных блокировок требуют построения и анализа графа распределения ресурсов, что вычислительно затратно и должно выполняться периодически.

4.  **Неприменимость для некоторых систем**. В системах реального времени или высоконагруженных приложениях методы обнаружения и восстановления могут быть неприемлемы из-за непредсказуемых задержек.

5.  **Недетерминизм**. Взаимная блокировка может проявляться только при определённом стечении обстоятельств (тайминги, порядок планирования), что затрудняет её выявление при тестировании.

### Сложившиеся практики
Индустрия выработала четыре стратегических подхода к работе с взаимными блокировками: предотвращение, обход, обнаружение с восстановлением и игнорирование.

1.  **Предотвращение (deadlock prevention)**. Устранение одного из условий Коффмана:
    *   **Упорядоченный захват ресурсов (lock ordering)** — все процессы захватывают ресурсы в едином, глобально определённом порядке. Это устраняет циклическое ожидание.
    *   **Прерываемые запросы** — процесс, которому не удалось захватить все ресурсы немедленно, освобождает уже захваченные и повторяет попытку (устранение условия удержания и ожидания).
    *   **Атомарный захват** — запрос всех ресурсов одновременно (там, где это возможно).
    *   **Вытеснение ресурсов** — принудительное изъятие ресурса у ожидающего процесса (реализуется редко, только в специализированных ОС).

2.  **Обход (deadlock avoidance)**. Динамическая оценка безопасности каждого запроса ресурса. Система проверяет, приведёт ли удовлетворение запроса к возможной взаимной блокировке в будущем. Классический алгоритм — алгоритм банкира (Дейкстра). Требует априорного знания максимальной потребности каждого процесса в ресурсах.

3.  **Обнаружение и восстановление (deadlock detection and recovery)**:
    *   **Периодическое построение графа распределения ресурсов** и поиск циклов. При обнаружении deadlock выполняется восстановление.
    *   **Завершение процесса ([[Process Termination|process termination]])** — принудительное завершение одного или нескольких процессов, участвующих в тупике (с возможной откатом состояния).
    *   **Вытеснение ресурса (resource preemption)** — принудительное изъятие ресурса у процесса и передача его другому; требует сохранения состояния для последующего восстановления.

4.  **Игнорирование (страусиный алгоритм)**. Предположение, что взаимные блокировки происходят крайне редко, и затраты на их предотвращение или обнаружение не оправданы. Распространено в пользовательских приложениях, где deadlock обычно воспринимается как зависание и устраняется перезапуском.

5.  **Использование таймаутов (lock timeout)**. При захвате ресурса указывается максимальное время ожидания. По истечении таймаута запрос прерывается, ресурсы освобождаются, выполняется повторная попытка. Это не предотвращает deadlock, но позволяет из него выйти.

6.  **Иерархия блокировок (lock hierarchy)**. В сложных системах вводится числовой уровень для каждого ресурса; поток может захватывать ресурсы только с монотонно возрастающими уровнями. Нарушение порядка вызывает исключение.

7.  **Инструменты статического и динамического анализа**. Использование анализаторов кода (ThreadSanitizer, Helgrind) для обнаружения потенциальных deadlock-ситуаций на этапе тестирования.

8.  **Проектирование без блокировок (lock-free programming)**. Использование атомарных операций и неблокирующих алгоритмов, полностью исключающих необходимость во взаимных исключениях. Наиболее радикальный, но и наиболее сложный подход.

9.  **Документирование протоколов синхронизации**. Явное описание порядка захвата ресурсов в проектной документации, код-ревью с акцентом на соблюдение этого порядка.

Таким образом, взаимная блокировка является классической проблемой параллельного программирования, не имеющей универсального решения без компромиссов. Выбор конкретной стратегии зависит от класса системы, стоимости простоев и вероятности возникновения тупиковых ситуаций. Современные практики смещают акцент от универсальных алгоритмов (алгоритм банкира) к прагматичным комбинациям упорядоченного захвата, таймаутов и автоматического обнаружения, адаптированным к конкретным архитектурам и сценариям использования.