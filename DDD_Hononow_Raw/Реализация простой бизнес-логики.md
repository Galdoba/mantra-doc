---
updated_at: 2025-12-11T17:33:26.608+10:00
tags:
  - part2
  - chapter5
---
Бизнес-логика — наиболее важная часть программного обеспечения. Именно она является первоочередной целью создания программного обеспечения. Пользовательский интерфейс системы может быть привлекательным, а ее база данных может быть невероятно быстрой и масштабируемой. Но если программное обеспечение бесполезно для бизнеса, это не более чем дорогостоящая демонстрация технологий. 
В *главе 2* уже упоминалось, что не все поддомены одинаковы. У разных поддоменов разные уровни стратегической важности и сложности. В этой главе мы приступим к изучению различных способов моделирования и реализации бизнес-логики. Начнем с двух паттернов, подходящих для весьма простой бизнес-логики: транзакционный сценарий (transaction script) и активная запись (active record).

# Транзакционный сценарий
Организует бизнес-логику по процедурам, где каждая процедура обрабатывает один запрос от пользователя. 
		*– Мартин Фаулер (Martin Fowler)*
		
Как показано на рис. 5.1, общедоступный интерфейс системы можно рассматривать в качестве набора бизнес-транзакций, доступных для выполнения потребителями. Эти транзакции могут извлекать информацию из системы, изменять ее или же делать и то и другое. Паттерн выстраивает бизнес-логику системы на основе процедур, где каждая процедура реализует операцию, выполняемую потребителем системы через публичный интерфейс. По сути, публичные операции (интерфейс) системы используются как границы инкапсуляции.

![[Рис. 5.1. Интерфейс транзакционного сценария.png]]

# Реализация 
Каждая процедура реализована в виде простого и понятного процедурного сценария. В нем для интеграции с хранилищами данных может использоваться тонкая прослойка абстракции, но может осуществляться и непосредственное обращение к базам данных. 
Единственным непреложным требованием к процедурам является их транзакционное поведение. Каждая операция должна завершаться либо успехом, либо неудачей, но никогда не приводить к недопустимому состоянию. Даже если выполнение транзакционного сценария завершается сбоем в самый неподходящий момент, система должна оставаться согласованной — либо путем отката всех изменений, которые она сделала до сбоя, либо путем выполнения компенсирующих действий. Транзакционное поведение отражено в названии паттерна: транзакционный сценарий. 
Ниже приведен пример транзакционного сценария, преобразующего файл формата JSON в файл формата XML: 

```
DB.StartTransaction( ); 

var job = DB.LoadNextJob( ); 
var json = LoadFile(job.Source); 
var xml = ConvertJsonToXml(json); 
WriteFile(job.Destination, xml.ToString( ); 
DB.MarkJobAsCompleted(job); 

DB.Commit( )
```

## Это не так-то просто! 
Когда я представляю паттерн транзакционного сценария на своих занятиях по предметно-ориентированному проектированию, мои студенты часто удивляются, а некоторые даже спрашивают: «Стоит ли на это тратить наше время? Разве мы здесь не ради более сложных моделей и приемов программирования?» 
Дело в том, что паттерн транзакционного сценария служит основой для более сложных паттернов реализации бизнес-логики, которые будут рассматриваться в следующих главах. Более того, несмотря на его кажущуюся простоту, в нем проще всего ошибиться. Множество производственных проблем, которые я так или иначе помогал отладить и исправить, часто сводились к неправильной реализации транзакционного поведения бизнес-логики системы. 
Давайте рассмотрим три обычных примера повреждения данных из реальной жизни, которые возникают в результате неправильной реализации транзакционного сценария.

### Отсутствие транзакционного поведения 
Элементарный пример неспособности реализовать транзакционное поведение — выпуск сразу нескольких обновлений без оборачивающей их транзакции. Рассмотрим следующий метод, обновляющий запись в таблице Users и вставляющий запись в таблицу VisitsLog:

```
01 public class LogVisit 
02 { 
03 ... 
04 
05 public void Execute(Guid userId, DataTime visitedOn) 
06   { 
07   _db.Execute("UPDATE Users SET last_visit=@p1 WHERE user_id=@p2", 
08       visitedOn, userId); 
09   _db.Execute(@"INSERT INTO VisitsLog(user_id, visit_date) 
10       VALUES(@p1, @p2)", userId, visitedOn); 
11   } 
12 }
```

Если после обновления записи в таблице пользователей (строка 7), но до успешного добавления записи в журнал в строке 9 возникнет какая-либо проблема, система окажется в несогласованном состоянии. Таблица Users будет обновлена, но соответствующая запись в таблицу VisitsLog записана не будет. Проблема может быть связана с чем угодно: от сбоя сети и до тайм-аута или взаимоблокировки в базе данных, или даже со сбоем сервера, выполняющего всю эту работу. 
Ситуацию можно исправить путем правильного добавления транзакции, охватывающей оба изменения данных:

```java
public class LogVisit 
	{ 
		... 
		public void Execute(Guid userId, DataTime visitedOn) 
		{ 
			try 
			{ 
				_db.StartTransaction( ); 
				
				_db.Execute(@"UPDATE Users SET last_visit=@p1 
				WHERE user_id=@p2",
				 visitedOn, userId); 
				_db.Execute(@"INSERT INTO VisitsLog(user_id, visit_date) 
				VALUES(@p1, @p2)", 
				userId, visitedOn); 
				
				_db.Commit( ); 
			} catch { 
				_db.Rollback( ); 
				throw; 
			} 
		} 
	}
```

Эти исправления легко осуществить благодаря имеющейся в реляционных базах данных встроенной поддержке транзакций, позволяющих атомарно выполнять сразу несколько операций. Но когда нужно выполнить несколько обновлений в базе данных, не поддерживающей транзакции для атомарного выполнения нескольких операций, или когда работа ведется с несколькими хранилищами данных, не поддающимися объединению в распределенную транзакцию, задача сильно усложняется. Давайте рассмотрим пример такого случая.

### Распределенные транзакции 
В современных распределенных системах общепринятой практикой является внесение изменений в данные в базе данных, а затем уведомление других компонентов системы об изменениях путем публикации сообщений в шине сообщений. Представьте, что при реализации предыдущего примера вместо регистрации посещения в таблице нам нужно опубликовать сообщение о нем в шине сообщений:

```
01 public class LogVisit 
02 { 
03 ... 
04 
05 public void Execute(Guid userId, DataTime visitedOn) 
06   { 
07     _db.Execute("UPDATE Users SET last_visit=@p1 WHERE user_id=@p2", 
08         visitedOn,userId); 
09     _messageBus.Publish("VISITS_TOPIC", 
10         new { UserId = userId, VisitDate = visitedOn }); 
11   } 
12 }
```

Как и в предыдущем примере, любой сбой, случившийся после выполнения кода в строке 7, но до успешного выполнения кода в строке 9, приведет к порче состояния системы. Таблица Users будет обновлена, но другие компоненты уведомлены не будут, поскольку публикация на шине сообщений даст сбой. 
К сожалению, решить проблему так же просто, как в предыдущем примере, не получится. Распределенные транзакции, охватывающие сразу несколько хранилищ данных, сложны, трудномасштабируемы, не устойчивы к ошибкам, и поэтому их обычно избегают. В *главе 8* будет рассматриваться использование архитектурного паттерна CQRS, предназначенного для заполнения сразу нескольких хранилищ данных. Кроме того, в *главе 9* будет представлен паттерн исходящих сообщений (outbox pattern), позволяющий обеспечить надежную публикацию сообщения после внесения изменений в базу данных. 
Давайте рассмотрим более сложный пример неверной реализации транзакционного поведения.

### Неявные распределенные транзакции 
Рассмотрим следующий, на первый взгляд довольно простой метод:
```java

public class LogVisit 
{ 
... 
	public void Execute(Guid userId) 
		{ _db.Execute("UPDATE Users SET visits=visits+1 WHERE user_id=@p1", 
		userId); 
	} 
}
```

Вместо отслеживания, как в предыдущих примерах, даты последнего посещения этот метод реализует счетчик посещений каждого пользователя. Вызов метода увеличивает значение соответствующего счетчика на единицу. Этот метод всего лишь обновляет одно значение в одной таблице, находящейся в одной базе данных. И тем не менее это все еще распределенная транзакция, которая потенциально может привести к несогласованному состоянию. 
Этот пример, как показано на рис. 5.2, представляет собой распределенную транзакцию, поскольку она передает информацию в базу данных и внешнему процессу, вызвавшему метод.

![[Рис. 5.2. Операция LogVisit обновляет данные и уведомляет вызывающую сторону об успешном или неудачном выполнении операции.png]]

Несмотря на то что метод execute имеет тип void, т. е. не возвращает никаких данных, он все же сообщает о результате выполнения операции: так, в случае неудачи вызывающая сторона получит исключение. А что если метод завершится успешно, но возврат результата вызывающему субъекту даст сбой?

Например: 
- если LogVisit является частью REST-сервиса и произошел сбой сети; 
- если и LogVisit, и вызывающий субъект запущены в одном и том же процессе, но процесс завершается со сбоем до того, как вызывающий объект успевает отследить успешное выполнение действия LogVisit?
В обоих случаях потребитель предполагает, что произошла ошибка и пытается снова вызвать LogVisit. Повторное выполнение логики LogVisit приведет к некорректному увеличению значения счетчика. Получится его увеличение на 2 вместо 1.
Как и в предыдущих двух примерах, код не может правильно реализовать паттерн транзакционного сценария, что непреднамеренно приводит к неверному состоянию системы. 
Как и в предыдущем примере, простого решения проблемы не существует. Все зависит от предметной области и ее потребностей. В данном конкретном примере один из способов обеспечить транзакционное поведение — сделать операцию идемпотентной, т. е. приводящей к одному и тому же результату даже при многократном повторении. 
Например, можно запросить у потребителя значение счетчика. Чтобы предоставить значение счетчика, вызывающая сторона должна будет сначала прочитать текущее значение, увеличить его локально, а затем предоставить обновленное значение в качестве параметра. Даже если операция будет выполняться несколько раз, конечный результат не изменится:

```java 
public class LogVisit 
{ 
... 
	public void Execute(Guid userId, long visits) 
		{ 
		_db.Execute("UPDATE Users SET visits = @p1 WHERE user_id=@p2", visits,userId); 
	} 
}
```

Еще один способ решения этой проблемы предусматривает использование оптимистической блокировки: перед вызовом операции LogVisit вызывающая сторона считывает текущее значение счетчика и передает его в LogVisit в качестве параметра. LogVisit обновит значение счетчика только в том случае, если оно равно значению, изначально прочитанному вызывающей программой:

```java

public class LogVisit 
{ 
... 
public void Execute(Guid userId, long expectedVisits) 
	{ 
		_db.Execute(@"UPDATE Users SET visits=visits+1 WHERE user_id=@p1 and visits = @p2", 
	userId, visits); 
	} 
}
```

Все последующие выполнения LogVisit с теми же входными параметрами не изменят данные, т. к. не будет выполняться условие WHERE...visits = p2.

Когда следует применять транзакционный сценарий Паттерн транзакционного сценария хорошо подойдет самым элементарным предметным областям, в которых бизнес-логика напоминает простые процедурные операции. Например, в операциях извлечения-преобразования-загрузки (extracttransform-load, ETL) каждая операция извлекает данные из источника, применяет логику трансформации для их преобразования в другую форму и загружает результат в целевое хранилище. Этот процесс показан на рис. 5.3.

![[Рис. 5.3. Поток данных в схеме извлечение-преобразование-загрузка.png]]

Паттерн транзакционного сценария органично вписывается во вспомогательные поддомены (supporting subdomains), где бизнес-логика по определению не отличается особой сложностью. Его также можно использовать в качестве адаптера для интеграции с внешними системами, например с универсальными поддоменами (generic subdomains) или в качестве части предохранительного слоя (anticorruption layer) (подробнее этот вариант применения будет рассмотрен в главе 9). 
Основным преимуществом паттерна транзакционного сценария является его простота. В нем вводится минимальное число абстракций, и его характеризуют минимальные издержки производительности в ходе выполнения программы, в реализуемой им бизнес-логике нетрудно разобраться. Но простота является и основным недостатком данного паттерна. Чем сложнее становится бизнес-логика, тем больше нарастает тенденция дублирования бизнес-логики среди процедур и, как следствие, отличающегося поведения, когда происходит рассинхронизация продублированного кода. В силу этого транзакционный сценарий ни в коем случае не следует использовать в основных поддоменах (core subdomain), поскольку он не справится с высокой сложностью их бизнес-логики. 
Простота, присущая транзакционному сценарию, создала ему сомнительную репутацию. Иногда данный паттерн даже рассматривается как антипаттерн. В конечном счете, если сложная бизнес-логика реализована в виде транзакционного сценария, то рано или поздно она превратится в неподдерживаемый большой ком грязи (big ball of mud). И все же нужно отметить, что, несмотря на все недостатки, паттерн транзакционного сценария получил в сфере разработки программного обеспечения весьма широкое распространение. Все паттерны реализации бизнес-логики, подлежащие рассмотрению в этой и последующих главах, так или иначе основаны на паттерне транзакционного сценария.

Активная запись 
	Объект, представляющий строку в таблице или представлении базы данных, инкапсулирует доступ к базе данных и бизнес-логику, оперирующую этими данными. 
		*– Мартин Фаулер (Martin Fowler)* 
Активная запись (active record), как и паттерн транзакционного сценария, пригодится в случаях простой бизнес-логики. Но в этом случае бизнес-логика может работать с более сложными структурами данных. Например, как показано на рис. 5.4, вместо простых записей могут применяться более сложные деревья объектов и иерархии.

![[Рис. 5.4. Более сложная модель данных с отношениями «один ко многим» и «многие ко многим».png]]

Работа с такими структурами данных с использованием транзакционного сценария привела бы к большому объему повторяющегося кода: сопоставление данных с их представлением в памяти будет дублироваться повсюду.

### Реализация 
В свою очередь, этим паттерном для представления сложных структур данных используются специальные объекты, известные как активные записи (active records). Помимо структуры данных, в этих объектах также реализуются методы доступа к данным для создания, чтения, обновления и удаления записей — так называемые CRUD-операции. В результате объекты активных записей связаны с объектнореляционным отображением (object-relational mapping, ORM) или каким-либо другим фреймворком доступа к данным. Название паттерна дано на основании того факта, что каждая структура данных является «активной», т. е. в нем реализуется логика доступа к данным. 
Как и в предыдущем паттерне, бизнес-логика системы организована в виде транзакционного сценария. Разница между этими двумя паттернами заключается в том, что в данном случае вместо прямого доступа к базе данных транзакционный сценарий манипулирует объектами активной записи. По окончании сценария операция должна либо успешно завершиться, либо дать сбой, т. е. вести себя как атомарная транзакция:

```java
public class CreateUser 
{ 
	... 

	public void Execute(userDetails) 
	{ 
		try 
		{ 
		_db.StartTransaction( ); 

		var user = new User( ); 
		user.Name = userDetails.Name; 
		user.Email = userDetails.Email; 
		user.Save( ); 
		_db.Commit( ); 
			} catch { 
		_db.Rollback( ); 
			throw; 
		} 
	} 
}
```

Цель паттерна — инкапсулировать сложность сопоставления объекта в памяти на схему базы данных. Помимо того, что объекты активной записи отвечают за операции с хранилищем, они могут содержать бизнес-логику, например выполнять проверку новых значений, присваиваемых полям, или даже заниматься реализацией бизнес-процедур, манипулирующих данными объекта. При этом отличительной особенностью объекта активной записи является разделение структур данных и поведения (бизнес-логики). Обычно поля активной записи имеют общедоступные методы чтения и записи, позволяющие внешним процедурам изменять их состояние.

### Когда следует применять активную запись 
Поскольку по своей сути активная запись представляет собой транзакционный сценарий, оптимизирующий доступ к базам данных, этот паттерн может поддерживать только относительно простую бизнес-логику, такую как CRUD-операции, которые в лучшем случае смогут проверить пользовательский ввод. 
Следовательно, паттерн активной записи, как и паттерн транзакционного сценария, подходит для вспомогательных поддоменов, интеграции внешних решений для универсальных поддоменов или для решения задач преобразования модели. Разница между паттернами заключается в том, что активная запись решает задачу сопоставления сложных структур данных на схему базы данных. 
Паттерн активной записи также называют антипаттерном «анемичная модель» предметной области или же неверно спроектированной моделью предметной области. Я предпочитаю воздерживаться от негативного подтекста слов «анемичный» и «антипаттерн». Этот паттерн является инструментом. Как и любой другой инструмент, он может решать поставленные перед ним задачи, но, если его применять в неправильном месте, потенциально он может причинить больше вреда, чем пользы. Если бизнес-логика не отличается особой сложностью, то в использовании активных записей нет ничего плохого. Кроме того, использование более сложного паттерна при реализации простой бизнес-логики также нанесет вред, поскольку приведет к неоправданной сложности. В следующей главе будет раскрыто понятие паттерна доменной модели и показано, чем она отличается от паттерна активной записи.

---
*Важно подчеркнуть, что в данном контексте активная запись относится к паттерну проектирования, а не к фреймворку Active Record. Название паттерна было придумано Мартином Фаулером (Martin Fowler) в книге «Patterns of Enterprise Application Architecture». Фреймворк появился позже в качестве одного из способов реализации паттерна. В контексте этой главы речь идет о паттерне проектирования и концепциях, лежащих в его основе, а не о конкретной реализации.*

---

## Придерживайтесь прагматичного подхода 
Хотя бизнес-данные важны, а разрабатываемый и создаваемый код должен обеспечивать их целостность, в некоторых случаях предпочтительнее придерживаться прагматичного подхода. 
Бывают случаи, когда гарантии согласованности данных могут быть ослаблены, особенно при высоких требованиях масштабируемости. Проверьте, действительно ли одна испорченная запись из миллиона является непреодолимым препятствием для бизнеса и может ли она негативно повлиять на эффективность и прибыльность бизнеса. Предположим, к примеру, что создается система, которая ежедневно принимает миллиарды событий с устройств Интернета вещей (IoT). Станет ли большой проблемой то обстоятельство, при котором 0,001% событий будут продублированы или утрачены? 
Как всегда, универсальных законов просто не существует. Все зависит от области бизнеса, в которой вы работаете. Можно «срезать углы» везде, где это возможно, просто нужно убедиться, что рискам и последствиям для бизнеса дана разумная оценка.

# Вывод 
В этой главе были рассмотрены два паттерна для реализации бизнес-логики: 
*Транзакционный сценарий* 
	Этот паттерн организует операции системы в виде простых и понятных процедурных сценариев. Процедуры гарантируют, что каждая операция является транзакционной — либо успешной, либо неудачной. Паттерн транзакционного сценария подходит для вспомогательных поддоменов, а бизнес-логика напоминает простые операции, подобные извлечению-преобразованию-загрузке (extract-transform-load, ETL). 
*Активная запись* 
	Когда бизнес-логика не отличается особой сложностью, но предусматривает работу со сложными структурами данных, эти структуры можно реализовать в виде активных записей. Объект активной записи — это структура данных, предоставляющая простые CRUD-методы доступа к данным. 
Рассмотренные в этой главе два паттерна, ориентированы на случаи применения сравнительно простой бизнес-логики. В следующей главе будет рассмотрена более сложная бизнес-логика и предложены способы преодоления дополнительных сложностей путем применения паттерна «модель предметной области».