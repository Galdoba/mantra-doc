---
updated_at: 2026-02-12T14:59:03.674+10:00
---
**Событие предметной области** ({{Domain Event|domain event}}) — это запись о факте, произошедшем в пределах [[Bounded Context|ограниченного контекста]] и имеющем значение для экспертов предметной области. Событие выражает состоявшееся изменение состояния [[Aggregate|агрегата]] или другого элемента модели и содержит все данные, необходимые для его обработки другими компонентами системы.

В отличие от команды, выражающей намерение выполнить действие, событие предметной области всегда фиксирует свершившийся факт, который уже не может быть отменён — только скомпенсирован другим событием.

### Назначение
Введение событий предметной области как первоклассных элементов модели решает комплекс задач стратегического и тактического проектирования:

*   **Коммуникация между ограниченными контекстами**. События служат основным носителем информации при асинхронном взаимодействии через [[Message Broker|брокер сообщений]], обеспечивая слабую связанность.
*   **Реализация сложных бизнес-процессов**. Последовательности событий естественным образом моделируют долгоживущие процессы (саги), где завершение одного шага инициирует следующий.
*   **Аудит и соответствие требованиям**. Неизменяемый поток событий формирует достоверный, хронологически упорядоченный журнал всех изменений системы.
*   **[[Event Sourcing|Событийный сторинг]]**. Хранение состояния агрегата в виде последовательности породивших его событий позволяет восстанавливать состояние на любой момент времени и анализировать историю.
*   **Реактивность и расширяемость**. Подписчики на события могут добавляться без изменения кода издателя, что облегчает развитие системы.

### Ограничения
Применение событий предметной области вносит существенные изменения в архитектуру и сопряжено с рядом ограничений:

1.  **Согласованность в конечном счёте ([[Eventual Consistency|eventual consistency]])**. Подписчики видят изменения не мгновенно, а с задержкой; строгая мгновенная согласованность между агрегатами или контекстами недостижима без синхронной координации.
2.  **Сложность эволюции схем ([[Schema Evolution|schema evolution]])**. Со временем структура событий изменяется; необходимо обеспечивать обратную и прямую совместимость версий, что требует дисциплины и инструментов.
3.  **Идемпотентность обработчиков ([[Idempotency|idempotency]])**. Поскольку доставка событий может повторяться, подписчики должны быть спроектированы идемпотентными, иначе повторное применение события приведёт к некорректному состоянию.
4.  **Нарушение порядка**. В распределённых системах события могут поступать подписчикам в порядке, отличном от времени их возникновения; для критичных сценариев требуется явное упорядочивание.
5.  **Атомарность публикации**. Сохранение состояния агрегата и публикация события должны быть атомарными — либо происходит и то, и другое, либо ничего. Реализация этой атомарности нетривиальна в распределённых средах.
6.  **Детерминизм воспроизведения**. При событийном сторинге повторное применение исторических событий должно приводить к тому же состоянию; любая недетерминированная операция (текущее время, случайные числа) нарушает это свойство.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию, реализации и использованию событий предметной области:

1.  **Именование в прошедшем времени**. Событие обозначается глаголом в форме Past Simple: `OrderShipped`, `InvoicePaid`, `CustomerRelocated`. Это подчёркивает его природу как свершившегося факта и отличает от команд (`ShipOrder`, `PayInvoice`).

2.  **Неизменяемость ([[Immutability|immutability]])**. Событие после создания не может быть изменено. Корректировка ошибочных данных выполняется публикацией нового, компенсирующего события, а не редактированием существующего.

3.  **Богатая структура**. Промышленный формат события включает три категории полей:
    *   **метаданные** — уникальный идентификатор события, тип, временная метка, версия схемы, идентификатор агрегата, [[Correlation ID|идентификатор корреляции]];
    *   **данные события** — бизнес-контекст, необходимый для обработки (сумма заказа, адрес доставки, статус);
    *   **трассировочная информация** — идентификаторы для распределённой трассировки.

4.  **Публикация после фиксации транзакции**. Событие публикуется только после успешного сохранения состояния агрегата в постоянном хранилище. Это достигается через паттерн [[Transactional Outbox|транзакционный исходящий ящик]]: событие записывается в ту же базу данных в отдельную таблицу в рамках одной транзакции, а отдельный процесс ретранслирует его в брокер.

5.  **Идемпотентные обработчики**. Подписчики событий запоминают идентификаторы уже обработанных событий (в локальном кэше или базе данных) и при повторной доставке игнорируют их. Альтернативно операции проектируются идемпотентными по своей природе.

6.  **Версионирование схем ([[Schema Versioning|schema versioning]])**. Каждое событие снабжается версией схемы. При изменении структуры создаётся новая версия; старая и новая версии сосуществуют в системе до тех пор, пока все подписчики не будут готовы к переходу. Используются реестры схем (Schema Registry) для контроля совместимости.

7.  **[[CQRS|Разделение команд и запросов]] (CQRS)**. Часто комбинируется с событийным сторингом: команды изменяют состояние агрегата, порождая события; события сохраняются в хранилище и асинхронно формируют проекции для чтения. Это обеспечивает масштабирование моделей записи и чтения независимо.

8.  **Проекции ([[Projection|projection]])**. События используются для обновления материализованных представлений, оптимизированных для конкретных запросов. Проекции могут перестраиваться с нуля путём повторной обработки всей истории событий.

9.  **Карта событий ([[Event Map|event map]])**. Документирование всех событий, их источников и подписчиков в рамках ограниченного контекста и между контекстами. Помогает отслеживать поток данных и зависимости.

10. **Атомарные группы событий**. Одна бизнес-операция может породить несколько событий, которые должны обрабатываться как единое целое. Практика заключается в публикации их в рамках одной транзакции или с использованием групповых идентификаторов.

11. **Тестирование событийной логики**. Проверяется, что при выполнении команды порождаются ожидаемые события (модульное тестирование агрегата), что обработчики событий корректно изменяют состояние и что контракты событий совместимы с подписчиками (контрактное тестирование).

Таким образом, событие предметной области превращается из второстепенного технического элемента в центральную абстракцию, вокруг которой строится архитектура сложных предметно-ориентированных систем. Дисциплинированное применение описанных практик позволяет реализовать масштабируемые, расширяемые и поддающиеся аудиту решения, в которых поток изменений является явным и наблюдаемым.