---
updated_at: 2026-02-12T16:34:43.418+10:00
---
## Чистая архитектура: изоляция бизнес-правил через правило зависимостей

**Чистая архитектура** ({{Clean Architecture|Clean Architecture}}) — это архитектурный паттерн, сформулированный Робертом Мартином, в котором система организуется в концентрические слои с жёстко заданным направлением зависимостей: зависимости могут направлены только внутрь, к наиболее абстрактным и стабильным слоям. В центре находится независимая от внешнего мира модель предметной области и бизнес-правила, а на периферии — детали инфраструктуры, пользовательские интерфейсы и внешние системы.

Чистая архитектура объединяет идеи [[Hexagonal Architecture|гексагональной архитектуры]], [[Onion Architecture|луковичной архитектуры]] и [[Boundary Control Entity|BCE]] (граница-контроллер-сущность).

### Назначение
Применение Чистой архитектуры направлено на создание систем, устойчивых к изменениям технологий и требований:

*   **Независимость от фреймворков**. Архитектура не зависит от существования какой-либо библиотеки или фреймворка; они используются как инструменты, но не встраиваются в ядро системы.
*   **Тестируемость ([[Testability|testability]])**. Бизнес-правила могут быть протестированы в изоляции, без UI, базы данных или внешних сервисов.
*   **Независимость от UI**. Пользовательский интерфейс может быть легко заменён (веб, консоль, голосовой ассистент) без изменения бизнес-логики.
*   **Независимость от базы данных**. Система не привязана к конкретной СУБД; хранилище может быть заменено с сохранением всех бизнес-правил.
*   **Независимость от внешних сервисов**. Интеграция с внешними системами осуществляется через адаптеры, что позволяет менять поставщиков без переписывания ядра.

### Ограничения
Применение Чистой архитектуры сопряжено с рядом объективных ограничений:

1.  **Значительная начальная сложность**. Для небольших приложений или прототипов введение многослойной структуры с явными границами и маппингом может быть неоправданным.
2.  **Большое количество косвенных вызовов**. Каждый запрос проходит через несколько уровней абстракции (контроллер → входной порт → сценарий использования → выходной порт → адаптер), что усложняет понимание потока управления.
3.  **Дублирование структур данных ([[DTO|DTO]])**. Внутренние модели предметной области не должны выходить за пределы ядра, поэтому на каждой границе приходится создавать отдельные объекты передачи данных и мапперы.
4.  **Требование высокой дисциплины**. Разработчики должны строго соблюдать правило зависимостей; нарушения легко допустить и трудно обнаружить без автоматических проверок.
5.  **Неприменимость для систем с жёсткими требованиями к производительности**. Дополнительные уровни косвенности и маппинга создают накладные расходы, неприемлемые в низкоуровневых или high-frequency системах.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к реализации Чистой архитектуры:

1.  **Правило зависимостей ([[Dependency Rule|dependency rule]])**. Ключевой принцип: зависимости исходного кода могут направлены только внутрь, к более высокоуровневым политикам. Ничто во внутренних кругах не может знать о внешних кругах.

2.  **Четыре основных слоя (концентрические круги)**:
    *   **[[Entity|Сущности (Entities)]]** — самый внутренний круг. Содержит критически важные бизнес-правила, общие для всей организации или приложения. Сущности имеют методы, реализующие эти правила.
    *   **[[Use Case|Сценарии использования (Use Cases)]]** — прикладные бизнес-правила, специфичные для данного приложения. Координируют потоки данных к сущностям и от них, реализуют полные сценарии.
    *   **[[Interface Adapter|Адаптеры интерфейсов (Interface Adapters)]]** — преобразуют данные между форматом, удобным для сценариев использования, и форматом, удобным для внешних агентов (базы данных, UI, API).
    *   **[[Frameworks and Drivers|Фреймворки и драйверы (Frameworks and Drivers)]]** — самый внешний круг. Содержит детали реализации: веб-фреймворки, ORM, драйверы баз данных, устройства.

3.  **Пересечение границ через [[Dependency Inversion Principle|инверсию зависимостей]]**. Когда внутреннему кругу требуется взаимодействие с внешним (например, сохранение данных), внутренний круг определяет [[Port|порт]] (интерфейс), а внешний круг реализует [[Adapter|адаптер]]. Это сохраняет направление зависимостей внутрь.

4.  **[[Dependency Injection|Внедрение зависимостей]]**. Конкретные реализации адаптеров связываются с портами на этапе композиции приложения, обычно в [[Composition Root|корне композиции]].

5.  **Явное выделение [[Boundary|границ]]**. Каждое пересечение слоя сопровождается созданием интерфейса и, часто, объектов передачи данных. Это делает зависимости прозрачными и контролируемыми.

6.  **[[Repository|Репозиторий]] как порт для доступа к данным**. Внутренний круг определяет интерфейс репозитория; внешний круг реализует его с использованием конкретной СУБД или ORM.

7.  **[[Controller|Контроллер]] как адаптер входящего трафика**. Принимает запрос от внешнего мира, преобразует его во внутреннюю модель, вызывает сценарий использования и возвращает ответ.

8.  **[[Presenter|Представитель]] для формирования ответа**. В некоторых вариациях сценарий использования возвращает простую структуру, а презентер преобразует её в формат, требуемый UI или API. Это сохраняет независимость сценариев от конкретного формата вывода.

9.  **Архитектурные тесты ([[ArchUnit|ArchUnit]])**. Автоматические проверки, запрещающие зависимости от внешних слоёв во внутренних пакетах. Например, доменный слой не должен импортировать ничего из Spring, Django и т.п.

10. **[[Domain Model|Модель предметной области]] без аннотаций**. Сущности и объекты-значения не должны содержать аннотации JPA, Jackson или других фреймворков; это сохраняет их чистыми от инфраструктурных забот.

11. **Постепенное внедрение**. Не требуется изначально строить всю систему по канонам Чистой архитектуры; допустимо начинать с монолитной структуры и по мере роста сложности выделять слои и границы рефакторингом.

12. **Комбинация с [[Bounded Context|ограниченными контекстами]]**. Чистая архитектура естественным образом масштабируется на уровне каждого [[Bounded Context|ограниченного контекста]], позволяя строить независимо развёртываемые микросервисы с собственным ядром и адаптерами.

Таким образом, Чистая архитектура является не жёстким каркасом, а набором принципов, направленных на защиту бизнес-логики от изменчивого окружения. Её последовательное применение требует дисциплины и осознанных компромиссов, но взамен даёт системы, способные адаптироваться к смене технологий, требований и даже бизнес-моделей на протяжении многих лет. Ключевой элемент — правило зависимостей, превращающее архитектуру из «слоёного пирога» в защищённую цитадель предметной области.