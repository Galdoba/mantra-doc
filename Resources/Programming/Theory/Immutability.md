---
updated_at: 2026-02-12T15:07:26.655+10:00
---
**Неизменяемость** ({{Immutability|immutability}}) — это свойство [[Object|объекта]], состояние которого не может быть изменено после его создания. Любая модификация неизменяемого объекта приводит не к обновлению существующего экземпляра, а к созданию нового объекта, содержащего изменённые данные, при этом исходный объект остаётся без изменений.

Неизменяемость является фундаментальной концепцией [[Functional Programming|функционального программирования]] и получила широкое распространение в императивных языках благодаря повышению надёжности и предсказуемости кода.

### Назначение
Применение неизменяемых объектов преследует несколько ключевых целей:

*   **[[Thread Safety|Потокобезопасность]]**. Неизменяемые объекты могут безопасно разделяться между потоками без синхронизации, поскольку отсутствует возможность гонки данных при одновременном чтении.
*   **Отсутствие [[Side Effect|побочных эффектов]]**. Функции, работающие с неизменяемыми данными, не изменяют глобальное состояние и не влияют на вызывающий код, что упрощает тестирование и отладку.
*   **Предсказуемость и прозрачность**. Объект, однажды созданный, всегда находится в известном состоянии; никакие операции не могут изменить его неожиданным образом.
*   **Кэширование и мемоизация**. Результаты вычислений над неизменяемыми объектами могут безопасно кэшироваться, поскольку входные данные гарантированно не изменятся.
*   **Совместное использование без копирования**. Один экземпляр неизменяемого объекта может быть передан множеству потребителей без риска нежелательной модификации, что экономит память.

### Ограничения
Несмотря на преимущества, неизменяемость не является универсальным решением и имеет объективные ограничения:

1.  **Производительность копирования**. Частое создание новых объектов при каждой модификации приводит к повышенной нагрузке на сборщик мусора и увеличению времени выполнения, особенно для крупных структур данных.
2.  **Память**. Хранение множества версий одного объекта (особенно в циклических процессах) может привести к избыточному потреблению памяти без использования специализированных структур.
3.  **Неудобство моделирования изменяемых сущностей**. Некоторые понятия предметной области по своей природе изменяемы (текущее местоположение, состояние выполнения); принудительная неизменяемость усложняет модель и требует дополнительных усилий по управлению версиями.
4.  **Взаимодействие с изменяемым окружением**. Работа с базами данных, файловой системой, внешними API требует преобразования неизменяемых объектов в изменяемые и обратно, что создаёт накладные расходы.
5.  **Повышенная сложность алгоритмов**. Некоторые алгоритмы естественно выражаются через итеративное изменение состояния; реализация их в неизменяемом стиле может быть значительно сложнее и менее эффективной.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к эффективному применению неизменяемости:

1.  **Неизменяемые объекты-значения ([[Value Object|value object]])**. В [[Domain-Driven Design|предметно-ориентированном проектировании]] все [[Value Object|объекты-значения]] проектируются неизменяемыми. Адрес, деньги, дата, диапазон — эти понятия не меняют своей идентичности при изменении атрибутов.

2.  **Персистентные структуры данных ([[Persistent Data Structure|persistent data structure]])**. Специализированные структуры (векторные деревья, хеш-карты с копированием пути) обеспечивают эффективное создание новых версий при модификации, разделяя неизменённые части между версиями. Широко используются в Clojure, Scala, а также реализованы в библиотеках для Java, JavaScript и других языков.

3.  **[[Copy-on-Write|Копирование при записи (Copy-on-Write)]]**. Техника, при которой разделяемый ресурс не копируется до тех пор, пока не потребуется его модификация. Применяется в операционных системах, параллельных коллекциях и для оптимизации неизменяемых структур.

4.  **[[Defensive Copy|Защитная копия (defensive copy)]]**. В интерфейсах, где неизменяемость не гарантируется, создаются копии передаваемых объектов, чтобы предотвратить их модификацию извне. Особенно важно для конструкторов и геттеров, возвращающих ссылки на внутренние массивы или коллекции.

5.  **Использование неизменяемых коллекций**. Многие современные языки и библиотеки предоставляют иммутабельные версии коллекций (Java `List.of()`, `Collections.unmodifiableList`, Kotlin `listOf`, Scala `List`, библиотеки Immutable.js для JavaScript). Предпочтение отдаётся им вместо изменяемых аналогов.

6.  **Финализация ([[Final|final]] / [[Const|const]])**. Поля классов объявляются неизменяемыми с помощью ключевых слов языка (`final` в Java, `const` в C++, `readonly` в C#). Это документирует намерение и обеспечивает проверку на уровне компилятора.

7.  **Обновление через функциональные сеттеры**. Вместо изменения состояния объект предоставляет методы, возвращающие новый экземпляр с изменённым полем: `withName(String newName)` или использование паттерна «строитель» (builder).

8.  **Неизменяемые записи ([[Record|record]] / [[Data Class|data class]])**. Современные языки (Java records, Kotlin data classes, C# records, Python dataclasses) предоставляют лаконичный синтаксис для создания неизменяемых объектов с автоматической реализацией равенства, хеш-кода и копирования.

9.  **Функциональное ядро с изменяемой оболочкой ([[Functional Core, Imperative Shell|functional core, imperative shell]])**. Архитектурный подход, при котором бизнес-логика реализуется через неизменяемые преобразования данных, а взаимодействие с внешним миром (ввод-вывод, базы данных) выносится в тонкий изменяемый слой.

10. **Событийное моделирование изменений ([[Event Sourcing|event sourcing]])**. Вместо изменения состояния сущности каждое изменение фиксируется как событие. Текущее состояние вычисляется повторным применением событий, что обеспечивает полную неизменяемость истории и возможность аудита.

Таким образом, неизменяемость является не абсолютным требованием, а архитектурным инструментом, приносящим наибольшую пользу при целенаправленном применении в критически важных для надёжности и параллелизма частях системы. Дисциплинированное использование иммутабельных объектов-значений, персистентных структур и функциональных подходов позволяет достичь высокой степени потокобезопасности и предсказуемости при приемлемых накладных расходах.