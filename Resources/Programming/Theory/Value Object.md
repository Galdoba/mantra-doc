---
updated_at: 2026-02-12T15:02:00.956+10:00
---
**Объект-значение** ({{Value Object|value object}}) — это объект, характеризующийся исключительно набором своих атрибутов и не имеющий собственной [[Identity|идентичности]]. Два объекта-значения считаются равными, если значения всех их полей совпадают; они взаимозаменяемы и неразличимы. Объекты-значения являются [[Immutability|неизменяемыми]] (immutable): после создания их состояние не может быть изменено.

В [[Domain-Driven Design|предметно-ориентированном проектировании]] объекты-значения противопоставляются [[Entity|сущностям]], которые обладают сквозной идентичностью и изменяемым состоянием.

### Назначение
Объекты-значения играют ключевую роль в построении выразительной, надёжной и безопасной модели предметной области:

*   **Представление описательных атрибутов**. Деньги, даты, адреса, координаты, цвет, диапазоны чисел — все эти понятия не имеют самостоятельной идентичности и описываются своими свойствами.
*   **Инкапсуляция и самодокументирование**. Вместо примитивных типов (`string`, `int`) используются предметно-ориентированные типы: `Email`, `Money`, `PhoneNumber`. Это повышает читаемость и предотвращает ошибки смешения единиц измерения или форматов.
*   **Устранение побочных эффектов**. Неизменяемость гарантирует отсутствие неожиданных изменений состояния; объект-значение можно безопасно разделять между множеством потребителей.
*   **Упрощение тестирования**. Создание и сравнение объектов-значений тривиально, не требует настройки сложных состояний или моков.
*   **Явное выражение инвариантов**. В конструкторе или фабричном методе проверяются все ограничения: неотрицательная сумма, корректный формат, допустимые границы.

### Ограничения
Применение объектов-значений сопряжено с рядом объективных ограничений:

1.  **Отсутствие собственного жизненного цикла**. Объект-значение не может существовать самостоятельно; он всегда является частью [[Entity|сущности]] или другого объекта-значения. Удаление владеющей сущности уничтожает и все связанные объекты-значения.
2.  **Сложность обновления**. Поскольку объект неизменяем, изменение одного атрибута требует создания совершенно нового экземпляра. В сценариях с частыми изменениями это приводит к повышенной нагрузке на сборщик мусора.
3.  **Хранение в базах данных**. Реляционные СУБД не имеют прямой поддержки объектов-значений; они либо сериализуются в одно поле (JSON), либо раскладываются на несколько колонок (embedded), что требует дополнительного mapping-кода.
4.  **Ограниченная выразительность при множестве вариантов**. Некоторые предметные области имеют множество разновидностей одного понятия (например, `Address` с разными наборами полей для разных стран). Моделирование через иерархии объектов-значений возможно, но может усложнить логику.
5.  **Производительность при массовых операциях**. В высоконагруженных системах создание миллионов короткоживущих объектов-значений может создавать измеримые накладные расходы.

### Сложившиеся практики
Индустрия выработала устойчивый набор подходов к проектированию и реализации объектов-значений:

1.  **Неизменяемость ([[Immutability|immutability]])**. Все поля объекта устанавливаются в конструкторе и не имеют публичных сеттеров. Любая операция, изменяющая состояние, возвращает новый экземпляр, оставляя исходный без изменений.

2.  **Переопределение равенства ([[Equality|equality]])**. Объекты-значения обязаны корректно реализовывать сравнение по содержимому: во всех языках переопределяются `equals`/`hashCode` (Java), `__eq__`/`__hash__` (Python), `operator==` (C++), либо используются записи/кортежи (record, tuple).

3.  **Фабричные методы ([[Factory Method|factory method]])**. Сложная логика создания и валидации инкапсулируется в статических фабричных методах с выразительными именами: `Money.ofRUB(100)`, `Email.parse("user@example.org")`. Это улучшает читаемость и позволяет возвращать `null` или `Optional` при неудаче.

4.  **Самовалидация ([[Self-Validation|self-validation]])**. Объект-значение проверяет свои инварианты в момент создания и отклоняет некорректные данные, выбрасывая исключение или возвращая специальный результат. Это гарантирует, что недопустимый объект никогда не появится в системе.

5.  **[[Domain Primitive|Доменные примитивы]]**. Объект-значение, оборачивающий один примитивный тип (например, `UserId`, `OrderNumber`), называется доменным примитивом. Он замещает «строковый хаос» явным типом с проверками и семантикой.

6.  **Целостное значение ([[Whole Value|whole value]])**. Объект-значение должен быть полным, самодостаточным представлением концепции. Например, `Money` включает и сумму, и валюту; разделение этих полей вне объекта-значения разрушает инкапсуляцию.

7.  **Отсутствие идентичности**. Объекты-значения никогда не имеют идентификаторов. Если возникает потребность отслеживать экземпляр во времени или изменять его состояние, это сигнал о необходимости превратить объект в сущность.

8.  **Использование библиотек и языковых средств**. Современные языки предоставляют встроенную поддержку неизменяемых объектов-значений: `record` в Java, `data class` в Kotlin, `namedtuple`/`dataclass` в Python, структуры в Go и Rust. Их применение предпочтительнее ручной реализации.

9.  **Сериализация и хранение**. Объекты-значения проектируются с учётом удобства сериализации. Часто применяются JSON/XML-преобразователи, а в базах данных — embedded-документы (MongoDB) или компонуемые типы (PostgreSQL JSONB, composite types).

10. **Побочные эффекты запрещены**. Методы объекта-значения не должны выполнять ввод-вывод, обращаться к внешним сервисам или модифицировать глобальное состояние. Они являются чистыми функциями над своими данными.

11. **Выделение в отдельный модуль**. Объекты-значения, особенно доменные примитивы, часто выносятся в самый низкоуровневый слой архитектуры, независимый от инфраструктуры и прикладных сервисов. Это обеспечивает их максимальную переиспользуемость.

Таким образом, объект-значение является фундаментальным строительным блоком выразительной предметной модели. Его систематическое применение превращает разрозненные примитивные типы в строго типизированные, самопроверяемые концепции, делающие код самодокументируемым и устойчивым к ошибкам. Неизменяемость и отсутствие идентичности не являются недостатками — это сознательные ограничения, обеспечивающие предсказуемость и потокобезопасность.